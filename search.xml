<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Manacher</title>
      <link href="/2023/01/31/2023-1-31-manacher/"/>
      <url>/2023/01/31/2023-1-31-manacher/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>求一个字符串最长的回文子串。<br>字面意思，回文就是一个串正着读倒着读一样，子串就是一个连续的子序列。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>不难发现对于一个回文字串，有两种情况：</p><ol><li><code>ABBA</code> 即长度为偶数，没有中心字符，半径为 2，长度为 4</li><li><code>ABCBA</code> 即长度为奇数，有中心字符，半径为 3，长度为 5</li></ol><p>懒得给他们处理两种情况，怎么办？只需要插入一些其他字符即可。<br>比如说我们可以在头部插入一个 <code>?</code> 代表串开始，<code>^</code> 代表串结束，然后在新串的每一个字符之间插入一个 <code>#</code> 号，得到的新串就能达到简化情况的目的。<br>按照上面的方法处理之后，原来的两个串会变为：<br>（只观察回文子串）</p><ol><li><code>?#A#B#B#A#^</code> 长度变为奇数，有中心字符，半径为 5，长度为 9</li><li><code>?#A#B#C#B#A#^</code> 长度为奇数不变，有中心字符，半径为 6，长度为 11</li></ol><p>情况被简化成一种，即长度为奇数。与此同时我们发现，新串的回文子串的 <strong>半径$-1$</strong> 就是原串回文子串的 <strong>长度</strong></p><p>与此同时，问题不变，还是求串的最长回文子串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    b += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        b += a[i];</span><br><span class="line">        b += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b += <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    n=b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><del>抽象来说</del>就是对于字符串的每一个位置，维护以这个位置为中心的最长回文串长度同时算出这个回文串的右边界，再通过这个右边界来更新下一个位置的最长回文串长度与右边界。</p><p>具体来说，对于一个字符串 $S$，开一个数组 $P_i$ 记录以 $i$ 为中心的最长回文串半径（含 $S_i$），变量 $mid$ 为在 $i$ 之前边界最靠右的回文子串的中心，$mr$（也就是 $maxright$）记录这个回文子串的右边界，通过这些更新下一个位置的这些值。</p><p>为了方便说明，以 $i$ 为中心的最长回文子串称为 $T_i$</p><h4 id="继承对称点的数据"><a href="#继承对称点的数据" class="headerlink" title="继承对称点的数据"></a>继承对称点的数据</h4><p>枚举到 $i$ 之前的状态：</p><p><img src="https://s1.ax1x.com/2023/01/31/pS0hKFU.png" alt=""></p><p>枚举到 $i$ 后，对于 $mr$ 和 $i$ 来说有两种情况：$i$ 在左侧或 $mr$ 在左侧</p><ul><li>$i$ 在左侧<br>即 $i$ 被 $T_{mid}$ 包含。<br>显然 $i$ 之前的 $P_k$ 都是已知的，同时 $i$ 在一个回文字串内，那么假设 $j$ 是 $i$ 关于 $mid$ 的对称点，则<br><img src="https://s1.ax1x.com/2023/01/31/pS0hKFU.png" alt=""><br>那么 $P_j$ 已知，对于以 $j$ 为中心的最长回文子串 $T_j$ 来说有两种情况<ol><li>$T<em>j$ 被 $T</em>{mid}$ 完全包含，此时 $P_i$ 可以继承 $P_j$ （因为回文）（不用考虑边界问题，后续会处理）</li><li>$T<em>j$ 未被 $T</em>{mid}$ 完全包含，此时 $T<em>i$ 一定被 $T</em>{mid}$ 完全包含。因为如果不被完全包含，则 $P<em>{mid}$ 的值仍可以增大，如下图<br><img src="https://s1.ax1x.com/2023/01/31/pS0hRk8.png" alt=""><br>图中蓝色块通过 $T</em>{mid}$ 串回文的性质已知相等，每个蓝色块均可以通过自身所在回文串推出其外侧橙色块也是相等的。<br>显然这种情况不会出现，因为这种情况下 $P_{mid}$ 是一个假值。</li></ol></li></ul><ul><li>$i$ 在右侧<br>没有可以继承的值则可以直接重新推，不需要过多考虑。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; mr) &#123;</span><br><span class="line">    p[i] = <span class="built_in">min</span>(p[(mid &lt;&lt; <span class="number">1</span>) - i], mr - i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新-P-i"><a href="#更新-P-i" class="headerlink" title="更新 $P_i$"></a>更新 $P_i$</h4><p>直接从当前记录的半径向外继续枚举，直到遇到两个不相同的字符为止（边界上有 <code>$</code> <code>^</code>，枚举到一定会停止，所以不用考虑边界问题）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (b[i - p[i]] == b[i + p[i]]) &#123;</span><br><span class="line">    ++ p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新-mr-和-mid"><a href="#更新-mr-和-mid" class="headerlink" title="更新 $mr$ 和 $mid$"></a>更新 $mr$ 和 $mid$</h4><p>前文说过 $mr$ $mid$ 都是边界最靠右的回文子串的属性，那么只需要判断新找到的回文子串右边界是否大于 $mr$ 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i + p[i] &gt; mr) &#123;</span><br><span class="line">    mr = i + p[i];</span><br><span class="line">    mid = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 Manacher 算法主要过程结束。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::sort;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e7</span> + <span class="number">514</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a, b;</span><br><span class="line"><span class="type">int</span> p[N];  <span class="comment">// p[i] 表示以第 i 个字符为中心的最长回文子串半径</span></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    b += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        b += a[i];</span><br><span class="line">        b += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b += <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    n=b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mr = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mr) &#123;</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[(mid&lt;&lt;<span class="number">1</span>)-i], mr - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b[i-p[i]] == b[i+p[i]]) &#123;</span><br><span class="line">            ++ p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i+p[i]&gt;mr) &#123;</span><br><span class="line">            mr = i+p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">reserve</span>(N);</span><br><span class="line">    b.<span class="built_in">reserve</span>(N);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    n = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">manacher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 最后需要枚举一遍来找出最大值</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度[1]"></a>时间复杂度<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="参考[谷雨的笔记](https://www.acwing.com/file_system/file/content/whole/index/content/7964832/)">[1]</span></a></sup></h3><p>当 $P_j$ 左侧取到左边界及以外时，$P_i$ 才需要更新（其他情况都因为不满足条件而不用进循环），而右端点是单调递增且严格小于等于 $n$ 的，因此总时间复杂度为 $\operatorname{O}(n)$</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">参考<a href="https://www.acwing.com/file_system/file/content/whole/index/content/7964832/">谷雨的笔记</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2023/01/29/2023-1-29-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2023/01/29/2023-1-29-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>顾名思义，树状数组是一种树形结构，但是因为他独特的结构和拆分方式（二进制你又来了是吧），可以直接用数组存储。<br>用途是解决大部分区间修改查询问题，复杂度一般是 $\operatorname{O}(\log n)$ ，同时常数小（暗示线段树不行），同时码量小，好理解（暗示*2），但是复杂的区间修改查询问题不能解决，同时区间最大最小值也不能用它处理（后文会说）</p><h2 id="基本树状数组"><a href="#基本树状数组" class="headerlink" title="基本树状数组"></a>基本树状数组</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>来自学长的一张图<br><strong>注意</strong>下文基本上所有东西都可以/需要搭配这个图进行理解</p><p><img src="https://pic.imgdb.cn/item/63d613b2face21e9ef36c9df.jpg" alt=""></p><p>以求区间和的树状数组为例，树中每一个节点存储一段区间的和，询问时进行前缀和加减即可得出任意区间的和。<br>分区间的方法即利用二进制，对于第 $i$ 节点来说，$i$ 的二进制形式中最低一位 <code>1</code> 的位置为 $x$，那么 $tree_i$ 就存储了 $[i-2^x+1,i]$ 区间的和。<br>注意此处 $x$ 从 <code>0</code> 开始算<br>以 $3$ 为例，$3$ 的二进制为 <code>0000 0011</code>，最低一位 <code>1</code> 的位置是 0，则 $tree_3$ 存储 $[3-1+1,3]$ 即 $[3,3]$ 的区间和。<br>再以 $8$ 为例，$8$ 的二进制为 <code>0000 1000</code>，最低一位 <code>1</code> 的位置是 3，则 $tree_8$ 存储 $[8-8+1,8]$ 即 $[1,8]$ 的区间和。<br><!-- TODO: 制作动画 --></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>实际上不用特意处理建立，直接在输入过程中每输入一个数就<a href="#单点修改">修改</a>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; t1; <span class="comment">// tmp</span></span><br><span class="line">    <span class="built_in">modify</span>(i,t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>本函数实现查找一个数最后一位 $1$ 的位置。</p><p>首先声明一个冷知识（大概冷），位运算是针对内存中存储的原数据的运算，换句话说，进行位运算的是补码而不是原码。</p><p><strong>原码</strong>即一个数本身的二进制表示，<strong>反码</strong>即在原码的基础上符号位不变其他位取反。<br><strong>补码</strong>分类来说，正数的补码是它的原码，负数的补码为其反码$+1$。</p><p>在这里我们只考虑最后一位 <code>1</code> 及它后面的 <code>0</code>。<br>比如 <code>0011 0100</code> 这个二进制数，我们先把它变成负数，即按位取反后加一（易证这就是他的相反数），变为 <code>11001011</code> 再变为 <code>11001100</code>。<br>发现了一件神奇的事情，原来最低一位 <code>1</code> 竟然回来了！<br>显然，这位 <code>1</code> 前面的所有数字因为被取反所以和原数完全不同；后面的所有数字原来一定是 <code>0</code> 取反后变成一排 <code>1</code>，负数的补码是反码$+1$，从而一直进位到原来最后一位 <code>1</code> 这里，而它们本身变回了 <code>0</code> ；又因为这位 <code>1</code> 被取反后是 <code>0</code> 所以无论如何都不会再向前进位。<br>从而保证对于任意一个正数 $x$，$-x$ 与 $x$ 的存储只有 $x$ 本身最后一位 <code>1</code> 是相同的。<br>因此 <code>lowbit()</code> 的实现就非常简单了，直接用 <code>x&amp;-x</code>，得到的结果就是<a href="#原理">原理</a>中所说的 $2^x$，又快又好想，用着还方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x&amp;-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>假设修改为给第 $x$ 个数增加 $v$，那我们就需要修改所有包含第 $x$ 个元素的节点，则从第 $x$ 个节点寻找父亲节点直到根节点为止（参考上图）。<br>$x$ 节点的直接父亲是 $x+\operatorname{lowbit}(x)$，因此直接一层循环实现 $\operatorname{O}(\log(n))$ 修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>查询区间为 $[l,r]$ 时，将问题转化为求 $[1,r] - [1,l-1]$ 的值（前缀和知识），因此我们只需要实现查询前缀和的功能即可。<br>因为 $i$ 节点存储的是一段长度为 $\operatorname{lowbit}(i)$ 的区间的和，因此取完 $i$ 号点的值后再取 $i-\operatorname{lowbit}(i)$ 号节点的值，直到位置变为 $0$（到头）即可（看不懂就结合上面图）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h2 id="改区间查单点"><a href="#改区间查单点" class="headerlink" title="改区间查单点"></a>改区间查单点</h2><p>上文我们解决了求前缀和的问题，本次需要查询单点，那么很容易联想到<strong>差分</strong>。更改区间对应改差分数组上的两个点，查询单点对应查询差分数组的前缀和。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMQ/ST表</title>
      <link href="/2023/01/27/2023-1-28-RMQ/"/>
      <url>/2023/01/27/2023-1-28-RMQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>目标是解决 RMQ 问题，即对于一个大区间，短时间内查询一个小区间的最大最小值</p><p>下文以最大值为例说明</p><p>ST 表本质上是一个动态规划（倍增的）</p><p>先利用倍增（二进制拆分）预处理然后 $\operatorname{O}(1)$ 查询，比线段树快，但是只支持静态区间</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>$f_{i,j}$ 表示从 $i$ 开始，长度为 $2^j$ 的区间中的最大值</p><p>预处理阶段，对于 $f_{i,j}$ 来说，直接</p><script type="math/tex; mode=display">    max\{ f_{i,{j-1}},f_{i+2^{j-1},j-1} \}</script><p>递推即可，非常容易想，时间复杂度为 $O(n\log n)$</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于一个区间 $[L,R]$ 来说，假设他的长度为 $len$ </p><p><img src="https://pic.imgdb.cn/item/63d4c4b0face21e9ef9f3cb9.jpg" alt=""></p><p>很容易能找到一个 $k$ 使得</p><script type="math/tex; mode=display">    \frac{len}{2} < 2^k \leqslant len</script><p><img src="https://pic.imgdb.cn/item/63d4c785face21e9efa61b8e.jpg" alt=""></p><p>显然 $[L,R]$ 被 $[L,2^k],[R-2^k-1,k]$ 严格包含，因此 ST 表中查询最大最小值的时间复杂度是常数级别的，而不是线段树的 $\log$ 级别<br>查询结果就是 $\max<br>{f<em>{L,2^k},f</em>{R-2^k-1k,k}}$</p><p>至于 $k$，肉眼可见 $k=\lfloor\log _2 (len)\rfloor$<br>此处可以直接使用 <code>cmath</code> 库中的 <code>log()</code> 函数，它是用来求以 10 为底的对数的<br>根据换底公式<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="$ \log_xy=\frac{\log_cy}{\log_cx} $">[1]</span></a></sup>可知 <script type="math/tex">k=\lfloor\log_2(len)\rfloor=\lfloor \frac{\lg(len)}{\lg2} \rfloor</script></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!j) &#123;</span><br><span class="line">            f[i][j] = w[i];  <span class="comment">// 从 i 开始长度为 2^0=1 的区间最大值为 i 本身</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后是查询<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(len) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态修改"><a href="#动态修改" class="headerlink" title="动态修改"></a>动态修改</h2><p>这个标题比较诡异，因为我提到过</p><blockquote><p>只支持静态区间</p></blockquote><p>但是实际上我们可以用一些小 trick 实现在 st 表的尾部增加值。<br>（前提是题目要求比较少，比如目前这道题只需要在尾部增加数，同时只需要查询尾部某长度区间的最值）<br>显然对于 st 表的每一个 $ f<em>{i,j} $ 来说，他只会用到 $ f</em>{k,j},k&gt;i $ 的值而不会用到前面的值，因此我们给他做一个倒转。<br>换句话说，现在 $ f_{i,j} $ 表示从 $ i $ 开始，向前长度为 $ 2^j $ 的区间中的最大值。<br>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    a += t;</span><br><span class="line">    a %= d;</span><br><span class="line">    ori[++tail] = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; tail - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span> &gt; <span class="number">0</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!j) &#123;</span><br><span class="line">            f[tail][j] = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[tail][j] = <span class="built_in">max</span>(f[tail][j - <span class="number">1</span>], f[tail - (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = tail - len + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log2</span>(len);</span><br><span class="line">    t =  <span class="built_in">max</span>(f[tail][k], f[l + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">$ \log_xy=\frac{\log_cy}{\log_cx} $<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div>&lt;/div&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/01/17/2022-1-17-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/01/17/2022-1-17-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天讲的最短路啥的感觉有点费劲，先把并查集的东西写了</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>基本上用来处理 <strong>关系</strong><br>什么是关系？比如一个人和他的表弟是亲戚，亲戚的关系可以人为理清<br>但是<del>毒瘤的</del>出题人会给这个人安上 114514 个表弟这些表弟的 1919810 个其他亲戚以及 1145141919810 个其他无关的人，然后问你这个序列里面第 $a$ 个人和第 $b$ 个人是不是亲戚，一般的方法显然处理不了<br>并查集就是专门用来解决这种东西用的</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>“并查集”的操作就是前两个字，即合并与查询<br>此处默认以树实现并查集</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并的操作即把两棵树的根节点连接在一起</p><p>文字解释不清楚，但是直接用树结构实现就比较清楚了</p><p>这里我们只需要开一个数组 $F$ 存储每一个节点的祖先即可<br>每次设置 $i$ 节点的祖先只需要修改 $F_i$ 的值</p><p>比如目前我们有五个点</p><p><img src="https://pic.imgdb.cn/item/63c64e44be43e0d30eb8b23d.png" alt=""></p><p>然后由输入数据可知，<code>1</code> 和 <code>3</code>，<code>2</code> 和 <code>4</code>，<code>5</code> 和 <code>4</code>，<code>4</code> 和 <code>1</code> 是亲戚<br>于是我们把 <code>1</code> 设为 <code>5</code> 的祖先来表示他们的关系， <code>2</code> <code>4</code> 同理<br>相当于把这四个集合（或者说树）两两合并</p><p><img src="https://pic.imgdb.cn/item/63c65028be43e0d30ebcaa53.jpg" alt=""></p><p>下一步</p><p><img src="https://pic.imgdb.cn/item/63c6526dbe43e0d30ec1760c.jpg" alt=""></p><p>以及把以 <code>4</code> 为根的这棵树合并到 <code>1</code> 上，连接他们的根节点</p><p><img src="https://pic.imgdb.cn/item/63c657d0be43e0d30ecda861.jpg" alt=""></p><p>这样我们就基本完成了这个集合的初始化<br>我们只需要再把根节点 <code>1</code> 的祖先设置为自己，来表示它是这棵树的根节点（应该在合并之前初始化每一个结点的祖先为自己，因为图可能会不太清楚所以改到这里了）</p><p><img src="https://pic.imgdb.cn/item/63c6595cbe43e0d30ed06172.jpg" alt=""></p><p>代码实现思路就很清楚了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询两个节点所在树的根</span></span><br><span class="line">    xx = <span class="built_in">find</span>(u);</span><br><span class="line">    yy = <span class="built_in">find</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xx != yy) f[xx] = yy; <span class="comment">//连接根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    .....</span></span><br><span class="line"><span class="comment">    cin &gt;&gt; m &gt;&gt; n; // m 为人数，n 为关系数</span></span><br><span class="line"><span class="comment">    int f[m+10], u, v;</span></span><br><span class="line"><span class="comment">    int p,q;</span></span><br><span class="line"><span class="comment">    memset(f,0,sizeof 0);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= m; ++i) &#123;</span></span><br><span class="line"><span class="comment">        f[i] = i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>假如我们需要查找上一张图里面 <code>2</code> <code>3</code> 是否是亲戚，如何操作呢？</p><p>很容易发现，<code>2</code> <code>3</code>两个节点在同一棵树中，也就是说我们可以直接查找这两个节点的根节点，如果相同则是亲戚。</p><p>查找的实现也很简单，直接递归/迭代寻找上一级的父亲节点，如果一个节点的祖先是自己，就直接输出这个节点即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 pos 的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[pos] == pos) <span class="keyword">return</span> pos; <span class="comment">// 边界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(father[pos]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>由上文可以发现，在并查集中查找一个节点的祖先最坏情况下的时间复杂度是 $O(h)$ 的（$h$ 为树的最大深度）<br>那么对于并查集的主要优化就是减小它的最大深度</p><h3 id="按树的大小合并"><a href="#按树的大小合并" class="headerlink" title="按树的大小合并"></a>按树的大小合并</h3><p>假如说我们有这样两棵树</p><p><img src="https://pic.imgdb.cn/item/63c66020be43e0d30edcc678.jpg" alt=""></p><p>现在 <code>1</code> <code>5</code>两个节点是亲戚，那么把 <code>5</code> 的祖先设为 <code>1</code> 合适还是反过来合适呢？<br>显然是前者</p><p>如果按照前者合并，结果就是</p><p><img src="https://pic.imgdb.cn/item/63c66135be43e0d30edef9df.jpg" alt=""></p><p>最大深度是 3</p><p>如果按照后者合并，最大深度为 4</p><p><img src="https://pic.imgdb.cn/item/63c66158be43e0d30edf4e8c.jpg" alt=""></p><p>也就是说，为了让 $h$ 尽可能地小，需要把深度小的树合并到深度大的树上，作为大深度树的子树</p><p>此处定义一个 $R$ 数组记录以 $i$ 为根节点的树的最大深度为 $R_i$<br>（$R$ 的修改在初始化/添加关系时修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> yy = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xx == yy) <span class="keyword">return</span>; <span class="comment">// 在同一棵树中不需要合并</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r[xx] &gt;= r[yy]) &#123;</span><br><span class="line">        f[yy] = xx;</span><br><span class="line">        r[xx] = <span class="built_in">max</span>(r[xx],r[yy]+<span class="number">1</span>); <span class="comment">// 可能合并后 y 树深度 +1 大于 x 树最大深度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f[xx] = yy;</span><br><span class="line">        r[yy] = <span class="built_in">max</span>(r[yy],r[xx]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><img src="https://pic.imgdb.cn/item/63c66407be43e0d30ee5216d.jpg" alt=""></p><p>以上两棵树显然右侧的树更优，因为它的最大深度更小</p><p>并查集的查询方式为“查询根节点”，这意味着我们查询时只需要关注查询最终的根节点，而不用关心查询途中经过的节点，这就是路径压缩的原理<br>路径压缩即把一个没有连着根的节点（如上图左侧的<code>4</code> <code>5</code> <code>6</code> <code>7</code>），“跳过”所有中间节点，直接把它连到根节点上。<br>对于上图来说，就是把 <code>4</code> <code>5</code> <code>6</code> <code>7</code> 摘出来连接到 <code>2</code> <code>3</code> 的父节点上，即 <code>1</code>，于是形成了右图，最大深度从 2 降到了 1。<br>由于并查集相关的题目中可能初始化之后仍然有需要增删的元素，同时路径压缩也需要耗费时间，所以我们只在查询需要的点时优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != f[x]) &#123; <span class="comment">// 如果 x 不是根节点</span></span><br><span class="line">        f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的查询函数可以结合上图理解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论基础</title>
      <link href="/2023/01/15/2023-1-15-basic-graph/"/>
      <url>/2023/01/15/2023-1-15-basic-graph/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>图论是嗜血分支<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="数学，来自 [GrainRain谷神](https://grainrain.site)">[1]</span></a></sup>，相应的，图论基础并没有什么太多需要思考的东西，只有一堆该死的概念等着记，有如绳之以法抽象了</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>由顶点（点）（Vertex）的集合和边（Edge）的集合组成，记为 $\mathbb{G} = (\mathbb{V}+\mathbb{E})$<br>点的集合用 $\mathbb{V(G)}$ 表示，点用 $u,v$ 等符号表示<br>顶点的数量称为图的“阶”，用 $n$ 表示<br>边的集合用 $\mathbb{E(G)}$ 表示，边用 $e$ 等符号表示<br>边的个数称为图的“边数” <del>感觉说了和没说一样</del>，用 $m$ 表示</p><h3 id="图的种类"><a href="#图的种类" class="headerlink" title="图的种类"></a>图的种类</h3><p>从 $u$ 到 $v$ 的无向边： $(u,v)$<br>从 $u$ 到 $v$ 的有向边：$\langle u,v \rangle$</p><p>有向图：图的所有边都是有向边<br>无向图：图的所有边都是无向边<br>完全图：每个点都与其他所有顶点连接；对于有向图来说，任意顶点 $u,v$ 都有边 $\langle u,v \rangle \langle v,u \rangle$<br>稀疏图/稠密图：边少/多的图<br>平凡图：一个点的图<br>零图：没有边的图</p><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><p>对于顶点 $v$ 来说<br>入度 $ID(v)$：以 $v$ 为终点的边的个数<br>出度 $OD(v)$：以 $v$ 为起点的边的个数<br>度 $D(v)$ = 入度 + 出度</p><p>度为奇数的点为奇点，度为偶数的顶点为偶点</p><p>于是可得：对于图 $\mathbb{G}$ 中所有顶点的度=边数的两倍<br>以及推论：一个图中的奇点数量为偶数</p><p>简短证明：</p><ol><li>每条边一定贡献一个出度一个入度共两个度</li><li>度一定是偶数所以奇点的数量为偶数（奇$\times$偶$=$偶）</li></ol><h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>无向图可以看作有向图但是两个点之间互相有一条有向边，所以只需要考虑有向图存图</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>基本思想是存两个点之间的边权（不连接即为 0 或 -1）</p><p>比如当前图有四个点，则开数组 <code>g[5][5]</code>，初始化为 0。</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>2</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>3</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>4</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>然后 1 到 2，3 到 1 有一条有向边，边权为 1，则修改 <code>g[1][2]</code> <code>g[3][1]</code> 为 1</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td><strong>2</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>3</strong></td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td><strong>4</strong></td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>非常容易理解，缺点也显而易见，如果有 114514 个点但是只有 1 条边，那就需要开 114514*114514 的空间但是只有一个位置有数据，显然造成了巨大的浪费（空间早就炸了）<br>因此需要寻找一个只存边的存图方案，从而诞生邻接表</p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>用链表实现的邻接表</p><p>先说链表，顾名思义，链状链接的列表</p><p>开一个结构体存链的每一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，把链表每一个部分连接起来的东西就是指针 <code>nex</code>，<code>nex</code> 指向当前元素的下一个元素的地址。<br>当然，如果开一个数组存储所有的元素，地址可以改为存储下标，即 <code>nex</code> 可以是一个整数，存储下一个元素在数组里的下标。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">数学，来自 <a href="https://grainrain.site">GrainRain谷神</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在启用 ZSTD 压缩的 ZFS 根分区上安装 ArchLinux 并配置 Windows 双启动</title>
      <link href="/2022/12/15/2022-12-ZFSRootArch/"/>
      <url>/2022/12/15/2022-12-ZFSRootArch/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://pinghigh.github.io/2022/11/28/2022-11-28-ZFSBootMenu/">前情提要</a></p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>分区大概长这样<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分区1 300M FAT16 EFI</span><br><span class="line">分区2 128G ZFS   ArchLinux</span><br><span class="line">分区3 128G NTFS  Windows</span><br><span class="line">分区N **G  **FS  DATA // 其他分区</span><br></pre></td></tr></table></figure><br>然后 ZFS 池里面长这样<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zroot</span><br><span class="line"> ├─ROOT</span><br><span class="line"> |  ├─voidlinux // 实际上可以在这个池里安装多个 Linux，本处计划把所有 Linux 根分区数据集放在 zroot/ROOT/ 里</span><br><span class="line"> |  └─archlinux</span><br><span class="line"> └─data</span><br><span class="line">    └─home // 存放 /home</span><br></pre></td></tr></table></figure><br>ZFS池那块看不懂没关系，只需要跟着文章做就行</p><h2 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h2><p>准备一个有 ZFS 支持的 archiso，这里我们提供两个方案</p><h3 id="CachyOS-LiveCD（推荐）"><a href="#CachyOS-LiveCD（推荐）" class="headerlink" title="CachyOS LiveCD（推荐）"></a>CachyOS LiveCD（推荐）</h3><p>从 <a href="https://sourceforge.net/projects/cachyos-arch/files/gui-installer/">CachyOS 的 Sourceforge 界面</a> 下载带 GUI 的 LiveCD（它的 CLI 安装器没 ZFS 支持），然后扔进 U 盘重启进入即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe zfs # 加载 ZFS 模块</span><br><span class="line"></span><br><span class="line">sudo su # 切换到 root 用户</span><br><span class="line"></span><br><span class="line">timedatectl set-ntp true  # 同步时间</span><br><span class="line"></span><br><span class="line">vim /etc/pacman.d/mirrorlist # 改镜像站</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开头添加</span></span><br><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure></p><h3 id="archiso-zfs"><a href="#archiso-zfs" class="headerlink" title="archiso-zfs"></a>archiso-zfs</h3><p>此处使用 <a href="https://github.com/eoli3n/archiso-zfs">eoli3n 的 archiso-zfs</a> 项目</p><p>首先下载一个<a href="https://archlinux.org/download/">官方的 ArchLinux LiveCD</a>，然后重启进入</p><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwctl # 进入 iwctl 命令行界面</span><br></pre></td></tr></table></figure><p>下面的命令在 <code>iwctl</code> 中输入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">device list # 列出可用设备</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设上面列出的设备是 wlan0</span></span><br><span class="line">station wlan0 scan</span><br><span class="line">station wlan0 connect SSID # 连接名为 SSID 的网络</span><br><span class="line">exit     </span><br></pre></td></tr></table></figure><br>验证联网<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line">timedatectl set-ntp true  # 同步时间</span><br></pre></td></tr></table></figure></p><h4 id="加载-ZFS-模块"><a href="#加载-ZFS-模块" class="headerlink" title="加载 ZFS 模块"></a>加载 ZFS 模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x</span><br></pre></td></tr></table></figure><p>如果连接 github 有问题，则运行下面的命令替代<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://ghproxy.com/https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x</span><br></pre></td></tr></table></figure><br>执行过程因为网络原因会比较慢</p><h4 id="改镜像站"><a href="#改镜像站" class="headerlink" title="改镜像站"></a>改镜像站</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开头添加</span></span><br><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>至此，环境准备完毕，下面的操作不受 livecd 影响</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>此处认为你已经分好区了，总体需要三个分区</p><ul><li>ESP（EFI） 分区，300M，打了 ESP 标签（可以用 <code>cfdisk</code> 打），此处举例为 <code>/dev/nvme0n1p1</code></li><li>Linux 分区（ZFS池），30+G，此处举例为 <code>/dev/nvme0n1p2</code></li><li>Windows 分区（如果不需要安装 Windows 就不用建），40+G，此处举例为 <code>/dev/nvme0n1p3</code></li></ul><h4 id="创建-ZFS-池"><a href="#创建-ZFS-池" class="headerlink" title="创建 ZFS 池"></a>创建 ZFS 池</h4><p><code>ashift = 12</code> 代表 4096 字节扇区大小，9 代表 512 扇区大小，13 代表 8192 字节扇区大小，在 4096/8192 扇区大小的 SSD 上设置 9 会导致性能损失，在 512 字节扇区大小的硬盘上设置 12/13会导致容量损失，扇区大小可以通过 fdisk -l（不准）或者 diskgenius 这类工具查看<br><code>dedup=on</code> 为去重功能，可能会占用较大 RAM，低配机子可以把这行删掉<br><code>compression=zstd</code> 为压缩功能，zstd 目前来看压缩率和性能损失比较平衡，在意性能可以改为快速压缩算法 lz4（gzip 压缩率和性能都比不上 zstd）<br>其他照做即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zpool create -f -o ashift=12           \</span><br><span class="line">             -O acltype=posixacl       \</span><br><span class="line">             -O relatime=on            \</span><br><span class="line">             -O xattr=sa               \</span><br><span class="line">             -O dnodesize=legacy       \</span><br><span class="line">             -O normalization=formD    \</span><br><span class="line">             -O mountpoint=none        \</span><br><span class="line">             -O canmount=off           \</span><br><span class="line">             -O devices=off            \</span><br><span class="line">             -O compression=zstd       \</span><br><span class="line">             -O dedup=on               \</span><br><span class="line">             -R /mnt                   \</span><br><span class="line">             zroot /dev/nvme0n1p2             </span><br></pre></td></tr></table></figure><br>创建数据集<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zfs create -o mountpoint=none zroot/data</span><br><span class="line">zfs create -o mountpoint=none zroot/ROOT</span><br><span class="line">zfs create -o mountpoint=/ -o canmount=noauto zroot/ROOT/archlinux</span><br><span class="line">zfs create -o mountpoint=/home zroot/data/home</span><br></pre></td></tr></table></figure><br>测试zpool是否能够导入导出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zpool export zroot</span><br><span class="line">zpool import zroot -R /mnt  </span><br></pre></td></tr></table></figure><br>挂载zpool<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zfs mount zroot/ROOT/archlinux</span><br><span class="line">zfs mount -a</span><br></pre></td></tr></table></figure><br>设置启动数据集<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool set bootfs=zroot/ROOT/archlinux zroot</span><br></pre></td></tr></table></figure><br>设置zpool缓存<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zpool set cachefile=/etc/zfs/zpool.cache zroot</span><br><span class="line">mkdir /mnt/etc</span><br><span class="line">mkdir /mnt/etc/zfs</span><br><span class="line">cp /etc/zfs/zpool.cache /mnt/etc/zfs/zpool.cache</span><br></pre></td></tr></table></figure><br>查看是否有挂载上<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zroot/ROOT/archlinux   30G  128K   30G   1% /mnt</span><br></pre></td></tr></table></figure></p><h4 id="格式化-EFI-分区"><a href="#格式化-EFI-分区" class="headerlink" title="格式化 EFI 分区"></a>格式化 EFI 分区</h4><p>注意此处挂载点不可以设置成 <code>/boot</code>！<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原因是 ZFSBootMenu 需要从 `/boot` 加载内核，而 ZBM 的 initramfs 启动时大概不会挂载 ESP 分区（我之前这么干寄了">[1]</span></a></sup><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat /dev/nvme0n1p1</span><br><span class="line">mkdir /mnt/efi</span><br><span class="line">mount /dev/nvme0n1p1 /mnt/efi </span><br></pre></td></tr></table></figure></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这部分需要你在 <code>/etc/pacman.conf</code> 里添加 <a href="https://github.com/archzfs/archzfs/wiki">archzfs</a> 源或者按照<a href="https://blog.yidaozhan.top/2022/08/11/arch-linux-upgrade-to-x86-64-v3-microarchitecture/">一刀斩的博客</a>配置 CachyOS 源，此处不再赘述</p><h4 id="安装基本软件包"><a href="#安装基本软件包" class="headerlink" title="安装基本软件包"></a>安装基本软件包</h4><p>如果是 Intel 的 CPU 就把 <code>amd-ucode</code> 换成 <code>intel-ucode</code></p><p>此处使用 <code>zfs-linux</code> 包有可能会因为版本不相同然后挂掉，所以如果你添加了 CachyOS 的软件源，那么我推荐你使用 CachyOS 的自定义内核（它的内核和 zfs 模块同时编译打包，就不会出现版本不统一的问题）（最主要还是因为安装 <code>zfs-linux</code> 还得启用 v3 源），有多种任务调度器可选，比如 BMQ PDS TT 等，还有 LLVM LTO 编译的版本</p><p>使用 CachyOS 内核的话直接改包即可，比如我想用 <code>linux-cachyos-pds</code>，那么把下面 <code>linux linux-headers zfs-linux</code> 换成 <code>linux-cachyos-pds linux-cachyos-pds-headers linux-cachyos-pds-zfs</code> 即可</p><p>如果你不想用 CachyOS 的内核，也不想因为 zfs 模块和 linux 内核版本不统一而滚挂，那么可以使用 dkms 模块，把 <code>zfs-linux</code> 替换为 <code>zfs-dkms</code> 即可，这个的缺点是构建 dkms 模块时会风扇狂转（理论上任何内核都可以用这个当 zfs 内核模块）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux-firmware linux linux-headers zfs-linux base-devel neovim os-prober amd-ucode openssh wget networkmanager zfs-utils </span><br></pre></td></tr></table></figure></p><h4 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 /etc/fstab</span></span><br><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证 /etc/fstab</span></span><br><span class="line">cat /mnt/etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chroot</span> 进 ArchLinux</span></span><br><span class="line">arch-chroot /mnt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置zpool缓存</span></span><br><span class="line">zpool set cachefile=/etc/zfs/zpool.cache zroot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br><span class="line">date</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置语言</span></span><br><span class="line">echo -e &quot;\nen_US.UTF-8 UTF-8\nzh_CN.UTF-8 UTF-8\nzh_TW.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用配置</span></span><br><span class="line">locale-gen</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认语言</span></span><br><span class="line">echo -e &quot;\nLANG=en_US.UTF-8\n&quot; &gt;&gt; /etc/locale.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置root密码</span></span><br><span class="line">passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加非 root 用户</span></span><br><span class="line">pacman -S fish # 如果不想用 fish 可以跳过这一步并把下一步的 fish 字段换成 bash</span><br><span class="line">useradd -m -G wheel -s /bin/fish user # user 替换为你的用户名</span><br><span class="line">passwd user # 设置密码</span><br><span class="line">sed -i &quot;s|#%wheel ALL=(ALL) ALL|%wheel ALL=(ALL) ALL|g&quot; /etc/sudoers # 添加 sudo 权限</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 multilib 和 archlinuxcn 仓库</span> </span><br><span class="line">arch=&#x27;$arch&#x27;</span><br><span class="line">echo -e &quot;\n[multilib]\nInclude = /etc/pacman.d/mirrorlist\n\n[archlinuxcn]\nServer = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch&quot; &gt;&gt; /etc/pacman.conf</span><br></pre></td></tr></table></figure><h4 id="配置内核钩子"><a href="#配置内核钩子" class="headerlink" title="配置内核钩子"></a>配置内核钩子</h4><p>重点部分！<br>编辑 <code>/etc/mkinitcpio.conf</code>，直接在 <code>HOOKS=(......)</code> 里面加上 <code>zfs</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvim /etc/mkinitcpio.conf</span><br><span class="line">HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck)</span><br></pre></td></tr></table></figure><br>编辑完直接借用 ArchLinux 的极为人性化的脚本生成即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -P</span><br></pre></td></tr></table></figure></p><h4 id="设置-zfs-服务以及网络管理服务"><a href="#设置-zfs-服务以及网络管理服务" class="headerlink" title="设置 zfs 服务以及网络管理服务"></a>设置 zfs 服务以及网络管理服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable zfs.target</span><br><span class="line">systemctl enable zfs-import-cache</span><br><span class="line">systemctl enable zfs-mount</span><br><span class="line">systemctl enable zfs-import.target</span><br><span class="line">systemctl enable sshd</span><br><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure><h2 id="配置-ZFSBootMenu-引导"><a href="#配置-ZFSBootMenu-引导" class="headerlink" title="配置 ZFSBootMenu 引导"></a>配置 ZFSBootMenu 引导</h2><p>（需要在 chroot 中完成）<br>重点部分！<br>详细了解可以看我之前那篇<a href="https://pinghigh.github.io/2022/11/28/2022-11-28-ZFSBootMenu/">在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）</a><br>在这里我们使用预构建好的 EFI 文件<del>因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核</del></p><p>首先下载预构建好的 ZBM efi 引导文件<br>（访问不了可以把 <a href="https://github.com/">https://github.com/</a> 换成 <a href="https://ghproxy.com/https://github.com/）">https://ghproxy.com/https://github.com/）</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /efi/EFI</span><br><span class="line">mkdir /efi/EFI/ZBM</span><br><span class="line">wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi</span><br></pre></td></tr></table></figure><br>再进行一个简单的配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zfs set org.zfsbootmenu:commandline=&quot;rw&quot; zroot/ROOT</span><br></pre></td></tr></table></figure><br>这样就做到了启动（如果没有双启动的需求没必要进行下一步了）</p><h2 id="配置-rEFInd-以实现与-Windows-双启动"><a href="#配置-rEFInd-以实现与-Windows-双启动" class="headerlink" title="配置 rEFInd 以实现与 Windows 双启动"></a>配置 rEFInd 以实现与 Windows 双启动</h2><p>安装 refind<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy refind git</span><br><span class="line">refind-install</span><br></pre></td></tr></table></figure><br>这样重启之后就能双启动了<br>但是你还可以美化一下，安装 nord 主题（非必要）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst</span><br></pre></td></tr></table></figure></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>退出 chroot<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><br>解挂载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/efi</span><br><span class="line">zfs umount zroot/ROOT/archlinux</span><br><span class="line">zfs umount -a</span><br></pre></td></tr></table></figure><br>导出 zfs 池<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zpool export zroot</span><br></pre></td></tr></table></figure><br>（导出没成功也没关系，直接重启即可）<br>重启<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><br>然后你的 archlinux 就可以正常使用了</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>还是在年前完成了虚拟机上的测试，能够完美安装，原来写的还是有点低级错误的<br>Hyper-V 上安装可能会涉及到 pacman 检测不到架构之类的问题，因此启用 archlinuxcn 源需要你在 <code>/etc/pacman.conf</code> 改 <code>Architecture = auto</code> 中的 <code>auto</code> 为你的架构，如 <code>x86_64</code> <code>x86_64-v3</code><br>另外不启用 CachyOS-v3 源，只启用 CachyOS 源也可以安装 CachyOS 的优化内核，但是没有 lto 版本<br>以及我个人宣布，这是本博客 2022 年的最佳博文</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原因是 ZFSBootMenu 需要从 <code>/boot</code> 加载内核，而 ZBM 的 initramfs 启动时大概不会挂载 ESP 分区（我之前这么干寄了<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> ArchLinux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZFSBootMenu </tag>
            
            <tag> ArchLinux </tag>
            
            <tag> ZFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）</title>
      <link href="/2022/11/28/2022-11-28-ZFSBootMenu/"/>
      <url>/2022/11/28/2022-11-28-ZFSBootMenu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇博客的缘由挺简单的，当时 ClearArch 开发组讨论文件系统应当使用 ZFS 还是 F2FS，由于使用过 F2FS 作为根文件系统（它没有 Windows 下的驱动，透明压缩也不会提供额外的空间），同时查到<a href="https://qiedd.com/1386.html">企鹅大大的一篇文章</a>，看到近 2x 的压缩率不禁心动，随后走上了 ZFS+zstd 作为根文件系统的折腾之路</p><p>企鹅大大使用 SysLinux 引导，我在服务器尝试安装结果无法启动；看到 <a href="https://cachyos.org">CachyOS</a> 的仓库中有一个打了 ZFS+zstd 支持补丁的 grub，尝试，启动不了（后来询问了 CachyOS 的开发团队得知那个补丁是不起效果的），随后，我遇到了一个完美的解决方式（指 <a href="https://github.com/eoli3n/arch-config/blob/master/scripts/zfs/install/02-install.sh">eoli3n 的使用 ZFSBootMenu 的安装脚本</a>）（如果想实机全盘单系统可以直接用他的安装脚本）</p><p>本文的目的是用 ZFSBootMenu 引导 zstd 压缩的 ZFS 文件系统根目录，同时附带双启动教程</p><h2 id="ZFSBootMenu-介绍"><a href="#ZFSBootMenu-介绍" class="headerlink" title="ZFSBootMenu 介绍"></a>ZFSBootMenu 介绍</h2><p><a href="https://github.com/zbm-dev/zfsbootmenu/">官方仓库</a> 介绍：</p><blockquote><p>ZFSBootMenu 是用于 root-on-ZFS 系统的 ZFS 引导加载程序，支持快照和本机全盘加密</p></blockquote><p>其原理比较容易理解，总的来说：</p><ol><li>引导 ZFSBootMenu，他是一个 initramfs 映像</li><li>找到并导入所有的 ZFS 存储池，然后挂载用户选择的根数据集</li><li>用 <code>kexec</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="`kexec` 是 Linux 内核的一种机制，它允许从当前运行的内核启动新内核。`kexec` 会跳过由系统固件（BIOS 或 UEFI）执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。">[1]</span></a></sup> 将系统内核、initramfs 映像加载到内存中</li><li>卸载所有 ZFS 数据集</li><li>启动最终内核</li></ol><p>总之，它能启动以 ZFS 为根目录的 Linux，速度不慢，适用环境广，是作为本文环境下引导器的不二之选</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>确保你的电脑为 UEFI 启动，且已经分区完成，建立了根分区相应的子数据集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -d /sys/firmware/efi] &amp;&amp; echo UEFI || echo BIOS</span><br></pre></td></tr></table></figure><p>输入该命令，若输出 <code>UEFI</code>，则可以进行下一步，否则退出本教程。</p><h3 id="挂载-ESP-分区"><a href="#挂载-ESP-分区" class="headerlink" title="挂载 ESP 分区"></a>挂载 ESP 分区</h3><p>ESP 分区一般是磁盘头部 300M 左右的 FAT16/32 分区，同时有 EFI System 标记，可以通过 <code>fdisk -l</code> 查看各个分区的标记<br>此处挂载点绝对不可以是 <code>/boot</code>，一般来说有两个其他选择：<code>/boot/efi</code> 和 <code>/efi</code>，我在这里选择了 <code>/efi</code><br>例如我的 ESP 分区是 /dev/nvme0n1p1<br>则<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/efi</span><br><span class="line">mount /dev/nvme0n1p1 /mnt/efi</span><br></pre></td></tr></table></figure></p><h3 id="设置-ZFS-Hook"><a href="#设置-ZFS-Hook" class="headerlink" title="设置 ZFS Hook"></a>设置 ZFS Hook</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先 arch-chroot</span></span><br><span class="line">arch-chroot /mnt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入后编辑 /etc/mkinitcpio 加入 zfs 支持，在 HOOKS=(.......) 中加入 zfs</span></span><br><span class="line">vim /etc/mkinitcpio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如正常安装的 <span class="built_in">arch</span> 修改后应该长这样，确保其中有 zfs 即可</span></span><br><span class="line">HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑后加载</span></span><br><span class="line">mkinitcpio -P</span><br></pre></td></tr></table></figure><h2 id="安装-ZFSBootMenu"><a href="#安装-ZFSBootMenu" class="headerlink" title="安装 ZFSBootMenu"></a>安装 ZFSBootMenu</h2><p>在这里我们使用预构建好的 EFI 文件<del>因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/efi 换成你的 ESP 挂载目录</span></span><br><span class="line">mkdir /efi/EFI</span><br><span class="line">mkdir /efi/EFI/ZBM</span><br><span class="line">wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此处假设你的根目录的数据集为 zroot/ROOT/arch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样可以引导 zroot/ROOT 下的任意子数据集，比如 zroot/ROOT/arch 上安装 <span class="built_in">arch</span>，zroot/ROOT/void 上安装 voidlinux，这就实现了 Linux 的双启动</span></span><br><span class="line">zfs set org.zfsbootmenu:commandline=&quot;rw&quot; zroot/ROOT</span><br></pre></td></tr></table></figure><h2 id="配置-rEFInd"><a href="#配置-rEFInd" class="headerlink" title="配置 rEFInd"></a>配置 rEFInd</h2><p>rEFInd 能够每次开机都搜索 EFI 分区下的 efi 文件，这样就不用更新引导文件了，同时插启动盘的时候也不需要进 bios 里调启动顺序，rEFInd 会自动搜索到<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设当前还在 <span class="built_in">chroot</span> 里</span></span><br><span class="line">pacman -Sy refind</span><br><span class="line">refind-install</span><br></pre></td></tr></table></figure><br>非常简单，这样就实现了 Windows/macOS(HFS+) 与 Linux on ZFS 的双启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 nord 主题</span></span><br><span class="line">pacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst</span><br></pre></td></tr></table></figure></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>实验并整理整个安装流程</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><code>kexec</code> 是 Linux 内核的一种机制，它允许从当前运行的内核启动新内核。<code>kexec</code> 会跳过由系统固件（BIOS 或 UEFI）执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> ArchLinux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZFSBootMenu </tag>
            
            <tag> ArchLinux </tag>
            
            <tag> ZFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/10/27/2022-10-xianduanshu/"/>
      <url>/2022/10/27/2022-10-xianduanshu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><del>闪击线段树</del></p><h2 id="基本线段树"><a href="#基本线段树" class="headerlink" title="基本线段树"></a>基本线段树</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><code>push_up()</code> 通过子区间计算父区间的数据</p><p><code>build()</code> 将一段区间初始化成线段树</p><p><code>modify()</code> </p><ul><li>修改单点数据</li><li>修改区间数据 (即 <code>push_down()</code>)</li></ul><p><code>query()</code> 查询</p><p><code>push_down()</code> 修改区间数据并递归修改子区间的数据</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>还是用图理解</p><p><img src="https://pic.imgdb.cn/item/63d63113face21e9ef80106d.jpg" alt=""></p><p>简单来说就是把一个区间整成类似上图的完全二叉树，父节点（区间）的数据可以由子节点（区间）的数据推出（如区间最大值，区间和等），同时父节点的更改可以推到子节点里。<br>可能有点抽象，但是把操作挨个解释就比较易懂了。</p><h3 id="存储节点"><a href="#存储节点" class="headerlink" title="存储节点"></a>存储节点</h3><p>使用结构体感觉比较清晰，配上指针就能脱离中括号的束缚了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    Node *lc, *rc;</span><br><span class="line">    <span class="type">int</span> l, r, mid;</span><br><span class="line">    <span class="type">int</span> lazy;  <span class="comment">// 懒标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        l = L;</span><br><span class="line">        r = R;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>同时 <code>mid</code> 是需要用到的变量，我这里选择直接存在里面，同时写一个初始化函数，直接传进去区间的左右端点，非常方便。</p><h3 id="建立线段树"><a href="#建立线段树" class="headerlink" title="建立线段树"></a>建立线段树</h3><p>第一层区间为 $[l,r]$</p><p>取 $mid = \lfloor \frac{l+r}{2} \rfloor $</p><p>则第二层的区间分别是 $[l,mid], [mid+1,r]$</p><p>目前节点为 $u$，线段树数组为 $tr$，<code>build()</code> 函数如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    nod-&gt;<span class="built_in">init</span>(L, R); <span class="comment">// 记录区间范围</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// 到达叶子节点就回溯</span></span><br><span class="line">        nod-&gt;v = ori[L];</span><br><span class="line">        nod-&gt;lc = nod-&gt;rc = tr; <span class="comment">// 防止空指针，左右儿子指向第一个空节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nod-&gt;lc = ++tail; <span class="comment">// tail 是一个指向最后创建的节点的指针，这样是一个类似动态开点的操作</span></span><br><span class="line">    nod-&gt;rc = ++tail;</span><br><span class="line">    <span class="built_in">build</span>(nod-&gt;lc, L, nod-&gt;mid);</span><br><span class="line">    <span class="built_in">build</span>(nod-&gt;rc, nod-&gt;mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">push_up</span>(nod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>以区间和为例</p><p>设查询的区间为 $[l,r]$，目前节点区间为 $[T_l,T_r]$</p><p>则有二种情况</p><ol><li>$[l,r] \ni [T_l,T_r]$ 查询区间包含目前节点区间（因为每次查询都可能把查询区间切割开再下传，所以这种情况可视为严格包含）</li><li>$[l,r]\cap[T_l,T_r] \neq \varnothing$</li><li>$[l,r]\not\ni[T_l,T_r]$ （不存在）</li></ol><p>把第二种情况还需要再分开成三种情况</p><ol><li>$[l,r] \in [lc_l,lc_r]$ 即被左儿子区间包含</li><li>$[l,r] \in [rc_l,rc_r]$ 即被右儿子区间包含</li><li>$l \leqslant mid , r &gt; mid$ 即左右区间都不能单独覆盖查询区间，这种情况把查询区间从 mid 劈成两半再分别在左右儿子区间查询即可。</li></ol><p>所以只用处理相应的情况就可以了</p><p>这里直接给出一个维护区间最大值的查询函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">push_down</span>(nod);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;r == R &amp;&amp; nod-&gt;l == L) &#123; <span class="comment">// 严格覆盖</span></span><br><span class="line">        <span class="keyword">return</span> nod-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lc-&gt;r &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;lc, L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nod-&gt;rc-&gt;l &lt;= L) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;rc, L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;lc, L, nod-&gt;lc-&gt;r) + <span class="built_in">query</span>(nod-&gt;rc, nod-&gt;rc-&gt;l, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从子节点推出父节点数据"><a href="#从子节点推出父节点数据" class="headerlink" title="从子节点推出父节点数据"></a>从子节点推出父节点数据</h3><p>还是以区间和为例，父区间最大值为两个子区间最大值中的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Node* nod)</span> </span>&#123;</span><br><span class="line">    nod-&gt;v = nod-&gt;lc-&gt;v + nod-&gt;rc-&gt;v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改区间值"><a href="#修改区间值" class="headerlink" title="修改区间值"></a>修改区间值</h3><p>理解起来其实挺简单的，比如给区间 $[L,R]$ 都加一个数 $x$，朴素写法直接用类似<a href="#查询">查询</a>的方法递归到底部回溯的时候一个一个更新即可。<br>但是显然这样做效率很低，对于长度为 $n$ 的一个区间，最坏情况下它对应 $\log n$ 个极大区间（这些区间不存在可以合并的两个）；对于每一个极大区间来说修改它和它所有子区间的值的时间复杂度显然是他的长度，即 $\operatorname{O}(len)$。则如上朴素写法每次修改的时间复杂度最坏为 $\operatorname{O}(n\log n)$，属于是飞慢了。<br>优化的方式很容易想到，就是每次修改只需要保证需要用到的节点是正确的，其他节点先不管，需要用到的时候再更改。这种方式很像前端里面的一个优化“懒加载”，即一个网页如果有很多元素，一次全部加载完可能会缓慢，所以设备显示到哪里就只加载哪里的元素，看不到的元素能不加载就不加载。同样的，这种优化方式需要打标记，同时能不下放就不下放，子节点能不修改就不修改，被称为“懒标记”。<br>也就是说若一个节点拥有懒标记，那么该节点的子节点们都不知道这个懒标记的存在，同时也就表明该节点的叶子节点存储的信息均不是真实信息。如果需要用到当前拥有懒标记的节点的真实信息，就需要把懒标记下放到子节点，通过懒标记更改子节点数据，然后处理子节点更改造成的数据更改即可（直接 <code>push_up</code>）</p><p>假设目前要求维护区间和的同时处理区间加的操作，对于每一个节点来说，我们需要维护一个懒标记 $lazy$ ，代表“当前区间的子区间需要加一个 $lazy$ ”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123; <span class="comment">// 给 [L,R] 每个数加 v</span></span><br><span class="line">    <span class="keyword">if</span> (L == nod-&gt;l &amp;&amp; R == nod-&gt;r) &#123; <span class="comment">// 包含了</span></span><br><span class="line">        nod-&gt;lazy += v; <span class="comment">// 该区间的每个子区间都需要加 v</span></span><br><span class="line">        nod-&gt;v += (nod-&gt;r - nod-&gt;l + <span class="number">1</span>) * v; <span class="comment">// 当前区间一共有 R-L+1 个元素（因为严格包含所以 L 和 R 就是区间的左右端点）</span></span><br><span class="line">        <span class="comment">// 用不上子区间的数据，不下传懒标记直接结束</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(nod);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断三种情况</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (nod-&gt;lc-&gt;r &gt;= R) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;lc, L, R, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nod-&gt;rc-&gt;l &lt;= L) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;rc, L, R, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;lc, L, nod-&gt;lc-&gt;r, v);</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;rc, nod-&gt;rc-&gt;l, R, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(nod);</span><br><span class="line">        <span class="built_in">push_up</span>(nod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(Node* nod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lc) nod-&gt;lc-&gt;lazy += nod-&gt;lazy;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;rc) nod-&gt;rc-&gt;lazy += nod-&gt;lazy;</span><br><span class="line">    nod-&gt;lc-&gt;v += (nod-&gt;mid - nod-&gt;l + <span class="number">1</span>) * nod-&gt;lazy;</span><br><span class="line">    nod-&gt;rc-&gt;v += (nod-&gt;r - nod-&gt;mid) * nod-&gt;lazy;</span><br><span class="line">    nod-&gt;lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，加上懒标记之后，为了保证查询时访问的节点数据正确，需要在查询时添加 <code>push_down()</code> 操作（上文已加）。</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>区间加修改&amp;求区间和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    Node *lc, *rc;</span><br><span class="line">    <span class="type">int</span> l, r, mid;</span><br><span class="line">    <span class="type">int</span> lazy;  <span class="comment">// 懒标记</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">        l = L;</span><br><span class="line">        r = R;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line"><span class="type">int</span> ori[N];</span><br><span class="line"><span class="type">char</span> beh;</span><br><span class="line"><span class="type">int</span> t1, t2, t3;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">Node* tail = tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Node* nod)</span> </span>&#123;</span><br><span class="line">    nod-&gt;v = nod-&gt;lc-&gt;v + nod-&gt;rc-&gt;v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    nod-&gt;<span class="built_in">init</span>(L, R);</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        nod-&gt;v = ori[L];</span><br><span class="line">        nod-&gt;lc = nod-&gt;rc = tr;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nod-&gt;lc = ++tail;</span><br><span class="line">    nod-&gt;rc = ++tail;</span><br><span class="line">    <span class="built_in">build</span>(nod-&gt;lc, L, nod-&gt;mid);</span><br><span class="line">    <span class="built_in">build</span>(nod-&gt;rc, nod-&gt;mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">push_up</span>(nod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(Node* nod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lc) nod-&gt;lc-&gt;lazy += nod-&gt;lazy;</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;rc) nod-&gt;rc-&gt;lazy += nod-&gt;lazy;</span><br><span class="line">    nod-&gt;lc-&gt;v += (nod-&gt;mid - nod-&gt;l + <span class="number">1</span>) * nod-&gt;lazy;</span><br><span class="line">    nod-&gt;rc-&gt;v += (nod-&gt;r - nod-&gt;mid) * nod-&gt;lazy;</span><br><span class="line">    nod-&gt;lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == nod-&gt;l &amp;&amp; R == nod-&gt;r) &#123;</span><br><span class="line">        nod-&gt;lazy += v;</span><br><span class="line">        nod-&gt;v += (nod-&gt;r - nod-&gt;l + <span class="number">1</span>) * v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(nod);</span><br><span class="line">        <span class="keyword">if</span> (nod-&gt;lc-&gt;r &gt;= R) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;lc, L, R, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nod-&gt;rc-&gt;l &lt;= L) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;rc, L, R, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;lc, L, nod-&gt;lc-&gt;r, v);</span><br><span class="line">            <span class="built_in">modify</span>(nod-&gt;rc, nod-&gt;rc-&gt;l, R, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(nod);</span><br><span class="line">        <span class="built_in">push_up</span>(nod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node* nod, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">push_down</span>(nod);</span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;r == R &amp;&amp; nod-&gt;l == L) &#123;</span><br><span class="line">        <span class="keyword">return</span> nod-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nod-&gt;lc-&gt;r &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;lc, L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nod-&gt;rc-&gt;l &lt;= L) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;rc, L, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(nod-&gt;lc, L, nod-&gt;lc-&gt;r) + <span class="built_in">query</span>(nod-&gt;rc, nod-&gt;rc-&gt;l, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ori[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(++tail, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; beh;</span><br><span class="line">        <span class="keyword">if</span> (beh == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;</span><br><span class="line">            <span class="built_in">modify</span>(tr + <span class="number">1</span>, t1, t2, t3);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(tr + <span class="number">1</span>, t1, t2) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加乘同时存在"><a href="#区间加乘同时存在" class="headerlink" title="区间加乘同时存在"></a>区间加乘同时存在</h2><p>上文介绍了加法的懒标记，如果是单独乘法的懒标记也很好实现。但是如果需要同时处理加法、乘法两个区间操作该怎么办捏？</p><p>只需要使用一下分配律即可。</p><p>$(nod_cnod_v + nod_a) \cdot d=d \cdot nod_cnod_v+d \cdot nod_a$ </p><p>$nod_c$ 即乘法懒标记， $nod_a$ 即加法懒标记，$d$ 是需要乘的数（操作数）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-10 初级数论</title>
      <link href="/2022/10/24/2022-10-math/"/>
      <url>/2022/10/24/2022-10-math/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="模运算相关"><a href="#模运算相关" class="headerlink" title="%%% 模运算相关"></a><del>%%%</del> 模运算相关</h2><p>首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\leqslant r&lt;m$，$q$ 就是商，$r$ 就是余数。<br>C++ 中模运算可能结果是负数。当 $n&lt;0$ 时，模运算结果满足 $-m&lt;r \leqslant 0$。<br>因此可以使用 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((n%m)+m)%m</span><br></pre></td></tr></table></figure><p>进行取余操作。</p><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a><a href="https://pinghigh.github.io/2022/07/14/2022-7-14-OI%E7%AC%94%E8%AE%B0/#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">辗转相除法</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,r;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$a\bmod m = b \bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \equiv b \pmod m$</p><p>等价于 $m$ 整除 $(a-b)$，即 $m\mid(a-b)$</p><h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><p>$ax \equiv b \pmod n$</p><p>已知 $a,b,n$，求解 $x$。<br>当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解<br>若 $x_0$ 是方程的一个解，那么所有的解就是 ${x_0+k\cdot n/\gcd(a,n) | k\in \mathbf{Z}}$</p><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><p>对于任意 $a,b$ $\exists x,y,ax+by=\gcd(a,b)$<br>即 $ax\equiv \gcd(a,b)\pmod b$</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>求解同余方程 $ax \equiv \gcd(a,n) \pmod n$<ul><li>对任意 $a,b$，存在$x,y$满足 $ax+by=\gcd(a,b)$ (裴蜀定理)<br>即 $ax\equiv \gcd(a,b) \pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出</li></ul></li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>回想辗转相除法，$\gcd(a,b) = \gcd(b,a\bmod b)$ 即<strong>缩小问题规模</strong>，当 $b\mid a$ 时，问题解决  </p><p>可得 $ax+by= \gcd(a,b) \Leftrightarrow bx’ + (a\bmod b)y’ = \gcd(b,a\bmod b)$ </p><p>即当 $b\mid a$ 时，问题解决，$x’ = 1, y’ = 0 $</p><p>$\begin{aligned} ax+by &amp;= bx’+(a\bmod b)y’ \ &amp;=bx’+(a-a/b\cdot b)y’=b(x’-a/b\cdot y’) + ay’ \end{aligned}$</p><p>即每层递归结束时，$ x=y’, y=x’-a/b\cdot y’$</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>算法：函数 <code>ex_gcd(a,b)</code><ul><li>若 <code>b=0</code>，<code>ax+by=gcd(a,b)</code> 的解是 <code>x=1</code>, <code>y=0</code>，直接返回</li><li>否则递归调用 <code>ex_gcd(b,a%b)</code>，求解 <code>bx&#39;+(a%b)y&#39;=gcd(b,a%b)</code></li><li>用上一步解的 <code>x&#39;,y&#39;</code>，令 <code>x=y&#39;，y=x&#39;-a/b*y&#39;</code>，<code>x</code>和<code>y</code>就是当前方程的解</li><li>返回<code>x,y</code></li></ul></li><li>对于任意同余方程 $ax\equiv b \pmod n$，只要满足 $\gcd(a,n)\mid b$<br>就可以先用扩欧求出 $ax’\equiv \gcd(a,n)\ \pmod n$<br>即 $d=\gcd(a,n)$，得到 $ax’(b/d)\equiv b\ \pmod n$<br>所以原方程一解 $x_0=x’(b/d)$，通解 $x_0+k(n/d), k\in \mathbf{Z}$</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> xx, yy;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">ex_gcd</span>(v, u%v, xx ,yy);</span><br><span class="line">    x = yy; y = xx - u/v*yy;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 同余方程 </tag>
            
            <tag> 扩展欧几里得算法 </tag>
            
            <tag> 模 </tag>
            
            <tag> 裴蜀定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包DP</title>
      <link href="/2022/10/23/2022-9-backpack/"/>
      <url>/2022/10/23/2022-9-backpack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次使用 $\KaTeX + \LaTeX$</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[MAXN], w[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m];  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维优化"><a href="#一维优化" class="headerlink" title="一维优化"></a>一维优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123; <span class="comment">// 按照物品从头到尾枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j --) &#123; <span class="comment">// 按照体积从最大体积到当前（第 i 个）物品枚举</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(</span><br><span class="line">                f[j], <span class="comment">// 此时未更新的 f[j] 是上一次（i-1）枚举的数据，即 f[j] 是不选第 i 个物品的 f[j]</span></span><br><span class="line">                f[j - v[i]] + w[i] </span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>即 3 维做法</p><ul><li>状态表示 $f_{i,j}$  <ul><li>集合：所有只考虑前 $i$ 个物品，且总体积不大于 $j$ 的所有选法</li><li>属性：$max$ （最大）</li></ul></li><li>状态计算 -&gt; 即集合的划分<ul><li>目前我们要求 $max f_{i,j}$，不容易直接求，就采用类似 01 背包问题的“曲线救国”方法<ol><li>去掉 $k$ 个第 $i$ 个物品，变为 $max f_{i-1,j}$</li><li>去掉相应的 $k$ 个第 $i$ 个物品的空间，变为 $max f_{i-1,j-v_ik}$</li><li>求上面的 $max$</li><li>加回 $k$ 个第 $i$ 个物品的价值，变为 $max f_{i-1,j-v_ik} + w_ik$</li></ol></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">backpack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,m; <span class="comment">//! 应当定义在函数外部，原因我不说，因为没人看</span></span><br><span class="line">    <span class="type">int</span> v[MAXN],w[MAXN];</span><br><span class="line">    <span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k *v[i] &lt;= j; k ++) </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-维优化"><a href="#2-维优化" class="headerlink" title="2 维优化"></a>2 维优化</h3><p>状态转移方程为 $f<em>{i,j} = max{f</em>{i,j}, f_{i-1,j - v_ik} + w_ik}$</p><p>因此可得<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i,j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>,j], f[i<span class="number">-1</span>,j-v] + w, f[i<span class="number">-1</span>,j<span class="number">-2</span>*v] + <span class="number">2</span>*w, f[i<span class="number">-1</span>,j<span class="number">-3</span>*v] + <span class="number">3</span>*w, ...... ) </span><br><span class="line">f[i,j-v] = <span class="built_in">max</span>(        f[i<span class="number">-1</span>,j-v]    , f[i<span class="number">-1</span>,j<span class="number">-2</span>*v] +   w, f[i<span class="number">-1</span>,j<span class="number">-3</span>*v] + <span class="number">2</span>*w, ...... ) </span><br></pre></td></tr></table></figure></p><p><del>从我这拙劣的对齐</del> 可以看出他们的关系捏</p><p>也就是说 <strong>第一行</strong> 后面的一大坨<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i<span class="number">-1</span>,j-v] + w, f[i<span class="number">-1</span>,j<span class="number">-2</span>*v] + <span class="number">2</span>*w, f[i<span class="number">-1</span>,j<span class="number">-3</span>*v] + <span class="number">3</span>*w, ......</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i,j-v] + w</span><br></pre></td></tr></table></figure></p><p>最终我们可以把该节第一行的状态转移方程优化为 $f<em>{i,j} = max(f</em>{i-1,j}, f_{i,j-v})$</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">full_backpack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,m; <span class="comment">//! 应当定义在函数外部，原因我不说，因为没人看</span></span><br><span class="line">    <span class="type">int</span> v[MAXN],w[MAXN];</span><br><span class="line">    <span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">        <span class="comment">//  原做法</span></span><br><span class="line">        <span class="comment">//  for (int k = 0; k *v[i] &lt;= j; k ++) </span></span><br><span class="line">        <span class="comment">//      f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j-v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后强删一维，变成一维DP数组捏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">backpack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,m; <span class="comment">//! 应当定义在函数外部，原因我不说，因为没人看</span></span><br><span class="line">    <span class="type">int</span> v[MAXN],w[MAXN];</span><br><span class="line">    <span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++) &#123;</span><br><span class="line">            <span class="comment">// f[i][j] = f[i - 1][j]; 恒等式直接删除</span></span><br><span class="line">            <span class="comment">// if (j &gt;= v[i]) 直接从 v[i] 开始循环就完事了</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="朴素-1"><a href="#朴素-1" class="headerlink" title="朴素"></a>朴素</h3><p>$N$ 种物品，背包容量为 $V$，第 $i$ 件物品最多能选 $C_i$ 个，每件物品占空间 $v_i$，价值为 $w_i$</p><p>第一种容易想到的解法是把完全背包的方法拿来用，因为多重背包只是加了 $k$ 的限制<br>状态转移方程即 $f<em>{i,j} = max{f</em>{i,j}, f_{i-1,j - C_ik} + w_ik 0 | } $</p><p>考虑多重背包和完全背包的区别可以发现，多重背包虽然每种物品不只一种，但是有确定的数量，而完全背包没有数量限制，则可以轻松地在忽略时间复杂度的情况下把多重背包<strong>拆分</strong>成 01 背包，即把 $M_i$ 件第 $i$ 件物品挨个算单个物品再按照 01 背包的方式处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(c[i],j/w[i])<span class="comment">/* 数量和体积两个都限制数量 */</span>; ++ k) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>这种暴力方式求解比较慢，容易发现，在求解过程中，每个<strong>同种</strong>物品是按照<strong>不同种</strong>物品进行处理的，换句话说，我选第一个 a 物品与选第二个 a 物品，实际上效果都是选 1 个 a 物品，但是这样的情况在上文解法中做了两次决策，显然有一种是多余的。<br>也就是说，接下来的优化方向是<strong>减少</strong>每次决策所遇到的<strong>同数量同种</strong>物品，那会联想到什么呢？<br>01 背包的决策是 <strong>选</strong> 与 <strong>不选</strong>，因此称为“01”背包，而 01 能够提醒我们利用<strong>二进制</strong>表示<strong>不同的数</strong>（不管想不想到反正这就是优化方法）</p><p>易证，使用 $2^0, 2^1, 2^2, 2^3… 2^{k-1}$ 能够表示出 $0$ 到 $2^{k-1}$ 之间的所有的数，即二进制计数。也就是说，如果把物品的数量 $C_i$ 拆分成 $2^0, 2^1, 2^2…2^{k-1} + p,0 \leq p &lt; 2^{k-1}$，由 $p$ 的范围可得，其中 $2^0+…2^{k-1}$ 能够表示出 $[0,p]$ 的所有整数，然后也能轻松得出 $2^0+…+2^{k-1}$ 选出若干与 $p$ 相加能表示出 $[p,p+2^k-1]$ 之间所有整数，两个合并即是 $[0,C_i]$</p><p>因此可以将 $C_i$ 拆分为 $k+1$ 种新的物品，每种新物品的体积和价值分别为：</p><script type="math/tex; mode=display">2^0*w[i],2^1*w[i],2^2*w[i],...,2^{k-1}*w[i],p*w[i]\\2^0*v[i],2^1*v[i],2^2*v[i],...,2^{k-1}*v[i],p*v[i]</script><p>拆分完再进行 01 背包即可。</p><p>代码来自 <a href="https://grainrain.site/2022/10/13/2022.10.13%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">GrainRain ‘s Blog</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>;</span><br><span class="line"><span class="comment">// 一共有 1000 项，每项最多拆分成 log s项  </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, s;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>) &#123; <span class="comment">// 从2^0 开始枚举 2 的次幂</span></span><br><span class="line">        s -= k;</span><br><span class="line">        v[++ cnt] = a * k;</span><br><span class="line">        w[cnt] = b * k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        v[++ cnt] = a * s;</span><br><span class="line">        w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">n = cnt;</span><br><span class="line"><span class="comment">// 二进制拆分读入</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j --)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 01背包解题过程</span></span><br></pre></td></tr></table></figure></p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>$N$ 组物品，第 $i$ 组有 $C<em>i$ 个物品，第 $i$ 组的第 $j$ 个物品的价值是 $w</em>{i,j}$，体积为 $v_{i,j}$，背包体积为 $M$，每组物品只能选择 $1$ 个</p><p>直接枚举组时挨个枚举物品就行了。<br>按照组划分阶段，第 $i$ 组不选则 $f<em>{i,j} = f</em>{i-1,j}$，第 $i$ 组选第 $k$ 个则 $f<em>{i,j} = f</em>{i-1,j-v<em>{i,k}} + w</em>{i,k}$</p><p>这里直接给出数组删维优化过的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= m; -- j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= c[i]; ++ k) &#123;</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[j], f[j-v[i][k]] + w[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h2><p><del>我的 Windows 盘还剩 3 个 G，LLVM 依赖于 MSVC 生成工具，MSVC 占用 2G 磁盘，LLVM 占用 2G 磁盘，问我应该怎么安装收益最大</del><br><del>reboot to archlinux!</del></p><p>A 物品依赖于 B，选 B 物品之前需要先选 A 物品，问最大价值</p><p>容易发现对于任意有依赖关系的物品 A B 来说，一共有以下三种可能的决策<br>（A 依赖 B）</p><ol><li>A B 都不选</li><li>选 B 不选 A</li><li>A B 都选</li></ol><p>因为这三种情况只会出现一个，联想分组背包的特征，将这三种情况每个看成一个组里的物品，即转化为了分组背包。</p><p>直接 dfs 就能解决依赖关系，但是这种情况怎么看都是要涉及到树形 DP 或者图论的）</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP/动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/2022/08/07/2022-8-7-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/07/2022-8-7-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h2><p>深度优先搜索： 一棵树从一个枝向下搜索，搜到头之后回溯，继续搜下一个枝<br>宽度优先搜索（Breath First Search不是Brain Fuck Scheduler）（后者已经停止维护了）： 一层一层搜到底部</p><div class="table-container"><table><thead><tr><th>搜索方式</th><th>数据结构</th><th>空间复杂度</th><th>最短路特性</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td>不具有</td></tr><tr><td>BFS</td><td>queue</td><td>O(2<sup>h</sup>)</td><td>具有<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="在一个权值都为1的树中，使用BFS搜索到的目标点一定离起始点距离最短">[1]</span></a></sup></td></tr></tbody></table></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>注意回溯需要“恢复现场”</p><p><a href="https://luogu.com.cn/problem/P1706">一个例题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 层数</span></span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">// 存储状态</span></span><br><span class="line"><span class="type">bool</span> state[N]; <span class="comment">// 存储各个枝是否被使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == n) &#123; <span class="comment">// 到达最底层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!state[i]) &#123; <span class="comment">// i没有被使用</span></span><br><span class="line">            path[a] = i;</span><br><span class="line">            state[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(a+<span class="number">1</span>); <span class="comment">// 搜索下一层</span></span><br><span class="line">            state[i] = <span class="number">0</span>; <span class="comment">// dfs结束之后，开始回溯，恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">在一个权值都为1的树中，使用BFS搜索到的目标点一定离起始点距离最短<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2022/07/23/2022-7-23-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/23/2022-7-23-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="vector-变长数组"><a href="#vector-变长数组" class="headerlink" title="vector 变长数组"></a>vector 变长数组</h3><p>需要引入头文件<code>vector</code></p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;类型&gt; 名称</span><br></pre></td></tr></table></figure><p>多个vector组成的数组<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;类型&gt; 名称[some_num]</span><br></pre></td></tr></table></figure><br>此处的类型也可以是自定义的结构体、类</p><p>示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[<span class="number">233</span>];</span><br></pre></td></tr></table></figure></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><a href="##STL容器常用命令">常用命令</a></h4><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>类似指针/数组下标之类的东西</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="string">&quot;NVIDIA&quot;</span>,<span class="string">&quot;FUCK&quot;</span>,<span class="string">&quot;YOU&quot;</span>,<span class="string">&quot;EOF&quot;</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *a.<span class="built_in">begin</span>() &lt;&lt; std::endl; <span class="comment">// a.begin() 指向 a 的第一个元素 此处相当于 a[0]</span></span><br><span class="line">    std::cout &lt;&lt; *(a.<span class="built_in">end</span>()<span class="number">-1</span>) &lt;&lt; std::endl; <span class="comment">// a.end() 指向 a 的最后一个元素的后一位，直接使用是越界访问，此处相当于 a[a.size()-1]</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it_end = a.<span class="built_in">end</span>(); <span class="comment">// C++11 显然使用 auto it=a.begin(); 更好写</span></span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 此时相当于 a[0] 与 *a.begin()</span></span><br><span class="line">    <span class="comment">// vector 的迭代器是一个随机访问迭代器，可以加减</span></span><br><span class="line">    std::cout &lt;&lt; *(it + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// 相当于 a[1]</span></span><br><span class="line">    std::cout &lt;&lt; *(it-it_end) &lt;&lt; std::endl; <span class="comment">// 求两个下标之间的距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL容器常用命令"><a href="#STL容器常用命令" class="headerlink" title="STL容器常用命令"></a>STL容器常用命令</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sth.<span class="built_in">size</span>(); <span class="comment">// 返回容器 sth 的实际长度（包含的元素个数）</span></span><br><span class="line">sth.<span class="built_in">empty</span>(); <span class="comment">// 返回一个 bool 值，表示容器 sth 是否为空</span></span><br><span class="line">sth.<span class="built_in">clear</span>(); <span class="comment">// 把容器 sth 清空</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类、结构体 斐波那契数列题解</title>
      <link href="/2022/07/19/2022-7-19-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/19/2022-7-19-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="类-class-与-结构体-struct"><a href="#类-class-与-结构体-struct" class="headerlink" title="类 (class) 与 结构体 (struct)"></a>类 (class) 与 结构体 (struct)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// Person类私有 只能在 Person 这个类里面调用</span></span><br><span class="line">        <span class="type">int</span> age, height;</span><br><span class="line">         <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age; <span class="comment">// Person 类中可以调用由 Person 类私有的量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_money</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">          money += a;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// private/public 可以有多个</span></span><br><span class="line">        string books[<span class="number">1000</span>]; </span><br><span class="line">&#125;;  <span class="comment">// 类定义结束要加分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">pinghigh</span><span class="params">()</span></span>;</span><br><span class="line">    Person persons; <span class="comment">// 可以定义一个 Person 类的数组</span></span><br><span class="line">    pinghigh.name = <span class="string">&quot;Tibrella&quot;</span>; <span class="comment">// name 是公有变量，外部可以访问</span></span><br><span class="line"><span class="comment">//  pinghigh.age = 15;    //!错误， age 是私有变量，外部不可访问</span></span><br><span class="line">    pinghigh.<span class="built_in">add_money</span>(<span class="number">12345</span>);</span><br><span class="line">    pinghigh.<span class="built_in">say</span>();</span><br><span class="line">    cout &lt;&lt; pinghigh.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m Tibrella</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p><h3 id="class-与-struct的异同"><a href="#class-与-struct的异同" class="headerlink" title="class 与 struct的异同"></a>class 与 struct的异同</h3><p>唯一一点不同是 class 中的量默认为 private , struct 中的量默认为 public<br>其他完全相同</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>递归无记忆搜索的写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以及等差数列(1+2+…..+n)(不允许判断，乘除)二逼做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[n][n+<span class="number">1</span>]; <span class="comment">//二维数组的size代替乘法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(a)&gt;&gt;<span class="number">1</span>; <span class="comment">//二进制右移一位表示除以2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构体 </tag>
            
            <tag> 类 </tag>
            
            <tag> 斐波那契数列 </tag>
            
            <tag> 二逼做法 </tag>
            
            <tag> 等差数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符数组与字符串 2</title>
      <link href="/2022/07/18/2022-7-18-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/18/2022-7-18-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="String类型字符串"><a href="#String类型字符串" class="headerlink" title="String类型字符串"></a><a href="www.acwing.com">String类型字符串</a></h2><p>可变长的字符序列，需要引入头文件<code>&lt;string&gt;</code></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1; <span class="comment">// 默认空字符串</span></span><br><span class="line">    string s2 = s1; <span class="comment">// string 类型可以互相赋值，无需 memcpy() 或 strcpy() 。 s2 是 s1 的一个副本</span></span><br><span class="line">    string s3 = <span class="string">&quot;hiya&quot;</span>; <span class="comment">// s3 是该字符串(&quot;hiya&quot;)字面值的一个副本（我也不知道是什么，总之 s3 的值是&quot;hiya&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;T&#x27;</span>)</span></span>; <span class="comment">// s4 的内容是“TTTTT” </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入无空格字符串</span></span><br><span class="line">    cin &gt;&gt; s1; <span class="comment">// scanf() fgets() 不能读入 string 类型</span></span><br><span class="line"><span class="comment">//读入一行</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,s2);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf() 不能直接输出string类型</span></span><br><span class="line"><span class="comment">    需要写成 printf(&quot;%s&quot;,s1.c_str())</span></span><br><span class="line"><span class="comment">    这里 s.c_str() 作用是把 string 类型转化为字符数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当然也可以 puts(s1.c_str())</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>使用 <code>getline(cin,str)</code> 输入时需要注意回车符<br>什么意思呢？举个例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string a,b;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  <span class="built_in">getline</span>(cin, s);</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时你输入<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIDIA</span><br><span class="line">FUCK U</span><br></pre></td></tr></table></figure><br>程序会在你输入完第一行后直接输出一个<code>NVIDIA</code>与几个换行符<br>原因是cin遇到回车停止，此时getline直接把<code>NVIDIA</code>后的部分(空)读入然后再次遇到回车符，停止输入。<br>为了避免这种情况，我们需要忽略掉一个回车符，可以使用<code>getchar()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string a,b;</span><br><span class="line">  cin &gt;&gt; a; <span class="comment">// NVIDIA</span></span><br><span class="line">  <span class="built_in">getchar</span>(); <span class="comment">// \n（跳过一个换行符）</span></span><br><span class="line">  <span class="built_in">getline</span>(cin, s); <span class="comment">// FUCK U</span></span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li><code>str.empty()</code><ul><li>返回一个bool值。</li><li>如果string为空返回1，非空返回0。</li></ul></li><li><code>str.size()</code> 返回string的长度，等价于 <code>s.length()</code><ul><li><code>strlen()</code> 需要循环一遍数组，时间复杂度为O(n)。</li><li><code>str.size()</code>  不需要循环，时间复杂度为O(1)。</li></ul></li><li>比较<ul><li>string 型之间按字典序比较直接 <code>str1 &lt; str2</code> 即可，<code>== != &lt;= &gt;= &lt; &gt;</code>都支持。</li></ul></li><li>相加<ul><li>string 型之间相加直接 <code>str1 += str2</code>、<code>str3 = str1 + str2</code> 这样写即可。</li><li>与其他类型（字符、字符串）相加时会先把这些类型的量转化为 string 对象，可以直接加这些类型的量，如 <code>str += &#39;a&#39;</code> 、 <code>str1 = str2 + &quot;abc&quot;</code></li><li>相加运算时，必须保证等号两边都有 string 型，<code>str1 = str2 + &quot;hello&quot; + &#39;a&#39;</code>、 <code>str1 += &quot;hello&quot;</code> 是可以的， 但是 <code>str1 = &quot;hello&quot; + &#39;a&#39;</code> 会报错。<ul><li>注意运算顺序，如 <code>string s1 = s2 + &quot;abc&quot; + &#39;d&#39;</code> 正确，因为会先将 s2 与 “abc” 相加得到另一个 string 对象，再继续运算。而 <code>string s1 = &quot;abc&quot; + &#39;d&#39; + s2</code> 会报错，因为 “abc” 和 ‘d’ 不能相加 （”abc”和”cde”也不行）</li></ul></li></ul></li><li>操作单个字符<ul><li>可以当作字符数组处理，如 <code>str[0]</code> , <code>str[3]</code></li><li>独特的遍历方式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;So, NVIDIA,&quot;</span> &lt;&lt; endl;</span><br><span class="line">  string s = <span class="string">&quot;Fuck U&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123; <span class="comment">// char c可以写作 auto c</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">So, NVIDIA,</span><br><span class="line">F</span><br><span class="line">u</span><br><span class="line">c</span><br><span class="line">k</span><br><span class="line"></span><br><span class="line">U</span><br></pre></td></tr></table></figure></li></ul></li><li><code>str.pop_back()</code> 删除string型字符串的最后一个字符</li><li><code>str.substr(int i,int len)</code><ul><li>输出字符串str从i开始长度为len的字符串</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符数组与字符串 1</title>
      <link href="/2022/07/17/2022-7-17-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/17/2022-7-17-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a href="www.acwing.com">字符串</a></h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">3</span>]=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">// 以下三种输出方式都是遇到换行或空格不停止，而是遇到&#x27;\0&#x27;才停止</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">// 等价于上面的printf语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">### 读入  </span><br><span class="line">分两种情况  </span><br><span class="line"><span class="number">1.</span>读入一个字符串，遇到空格/回车停止  </span><br><span class="line">使用cin</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">3</span>];</span><br><span class="line">    cin &gt;&gt; str; <span class="comment">//输入</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">或使用scanf</span><br><span class="line">```C++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//输入</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里注意一点，str 不能写作 &amp;str</span></span><br><span class="line"><span class="comment">    数组名实际上是一个指针，存储数组的第一个元素的内存地址（指向数组的第一个元素）</span></span><br><span class="line"><span class="comment">    scanf(&quot;%s&quot;,__) 这里下划线部分应当是一个内存地址，而整型、浮点、字符等类型变量中存储的不是地址而是它对应的内容，所以需要用‘&amp;’取出它的内存地址，如取出整型（int）变量a的内存地址就是 &amp;a。</span></span><br><span class="line"><span class="comment">    而数组名本身就存储着内存地址，所以不需要再用 &amp; 取一遍内存地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.读入一行内容，输入空格不停止<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">fgets</span>(str,<span class="number">100</span>,stdin); <span class="comment">// gets() 函数在 C11 标准中因为容易溢出而被删除，取而代之的是 fgets()</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    &quot;str&quot;为字符串名</span></span><br><span class="line"><span class="comment">    “100”是读入的最大字符数（一般使用数组长度即可）</span></span><br><span class="line"><span class="comment">    “stdin”应该是一个接口，不用管，照着写就行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">或   </span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    string str1;</span><br><span class="line">    cin.<span class="built_in">getline</span>(str,<span class="number">100</span>); <span class="comment">// 字符数组使用 cin.getline()</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,str1); <span class="comment">// string 使用 getline()</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常用函数-lt-span-class-”hint—top-hint—error-hint—medium-hint—rounded-hint—bounce”-aria-label-”以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。"><a href="#常用函数-lt-span-class-”hint—top-hint—error-hint—medium-hint—rounded-hint—bounce”-aria-label-”以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。" class="headerlink" title="常用函数&lt;span class=”hint—top hint—error hint—medium hint—rounded hint—bounce” aria-label=”以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。"></a>常用函数<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint—top hint—error hint—medium hint—rounded hint—bounce” aria-label=”以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。</h3><pre><code>如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(str); i++) </span><br></pre></td></tr></table></figure>最好改写成```c++for (int i =  0, len=strlen(str); i &lt;= len; i++)```   </code></pre><p>“&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;</p><ul><li>strlen(str) 求字符串长度（不包含’\0’）</li><li>strcmp(a,b) 比较两个字符串大小(ASCII码)， a &lt; b 返回 -1 ，a == b 返回 0， a &gt; b 返回 1（比较方式为字典序<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="字典序：从前向后比，如2与10，比较数字则10大，按字典序比较则是2大（因为2>1）">[2]</span></a></sup>）</li><li>strcpy(a,b) 将字符串b赋值给从a开始的字符数组<h4 id="strlen-示例"><a href="#strlen-示例" class="headerlink" title="strlen()示例"></a>strlen()示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 用于输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 或者string.h，这是C语言的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 用于输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">###<span class="meta"># strcmp()示例  </span></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 用于输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 或者string.h，这是C语言的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 用于输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strcmp</span>(s,<span class="string">&quot;abc&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此处将输入的字符串与abc进行比较<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">#1 bac</span><br><span class="line">#2 abc</span><br><span class="line">#3 aac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">#1 1</span><br><span class="line">#2 0</span><br><span class="line">#3 -1</span><br></pre></td></tr></table></figure></li></ul><h3 id="strcpy示例"><a href="#strcpy示例" class="headerlink" title="strcpy示例"></a>strcpy示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 用于输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 或者string.h，这是C语言的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 用于输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>]=<span class="string">&quot;abc&quot;</span>,s2[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(s2,s1); <span class="comment">// s1 复制到 s2</span></span><br><span class="line">    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为<code>abc</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">strlen</span>(str); i++) </span><br></pre></td></tr></table></figure>最好改写成<code>c++ for (int i = 0, len=strlen(str); i &lt;= len; i++)</code><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">字典序：从前向后比，如2与10，比较数字则10大，按字典序比较则是2大（因为2&gt;1）<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 字符数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埃氏筛 &amp; cstring 部分函数</title>
      <link href="/2022/07/15/2022-7-15-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/15/2022-7-15-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="7-15日-OI笔记"><a href="#7-15日-OI笔记" class="headerlink" title="7.15日 OI笔记"></a>7.15日 OI笔记</h1><p>浮点数比较要容忍误差（精度问题导致后几位出现误差）</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="https://www.acwing.com">数组</a></h2><p>高精度竖式算除法，试商时可以使用二分查找（非重点）</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处a为数组名，40为赋值范围（int为4byte,数组大小为10，4*10=40）<br>不会把每个元素赋值为0，而是把每个字节赋值为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">1</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处a中每一个byte赋值为<code>0000 0001</code>，取出a[1]为<code>16843009</code>，即<code>0000 0001 0000 0001 0000 0001 0000 0001</code>。 </p><p>为了达到初始化数组的目的，我们也可以把它每一位赋值为1（二进制1111 1111十进制为-1）<br>即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">-1</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h4><p>输出一个量所占内存byte数</p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">sizeof</span> a;</span><br></pre></td></tr></table></figure><p>因此我们可以写作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a); <span class="comment">//sizeof a等价于sizeof(a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memcpy</span> (b,a,<span class="keyword">sizeof</span> a); <span class="comment">//sizeof a等价于sizeof(a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做题要点"><a href="#做题要点" class="headerlink" title="做题要点"></a>做题要点</h3><p>1.<a href="https://www.acwing.com/activity/content/problem/content/1917/">例题</a><br>这种题可以列表来找规律<del>避免大脑便秘</del></p><p>如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i   左   右</span><br><span class="line">0   1   10</span><br><span class="line">1   2    9</span><br><span class="line">2   3    8</span><br><span class="line">3   4    7</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">i  i+1  10-i</span><br></pre></td></tr></table></figure><h2 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 //筛掉2的倍数</span><br><span class="line"></span><br><span class="line">2 3 5 7 ~~9~~ //筛掉3的倍数</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b[<span class="number">100000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123; <span class="comment">// 注意枚举质数的范围</span></span><br><span class="line">        <span class="keyword">if</span> (!b[i])&#123; <span class="comment">// b[i]值为0表示i为质数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n/i; j++) &#123; <span class="comment">// 筛掉i的倍数</span></span><br><span class="line">                b[i*j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11 行处为一个小优化：$i$ 的倍数从 $i^2$ 开始枚举 （考虑 $j = k\cdot i&lt;i\cdot i$， $j$ 一定会被 $k$ 的质因数筛去）</p><p>举个例子：筛 $2$ 的倍数时，被打标记的数字分别是<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2*2,2*3,2*4......2*n/2</span><br></pre></td></tr></table></figure><br>那么我们筛 $i$ 的倍数时，无优化算法被打标记的数分别是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i*2,i*3,i*4.......i*n/i</span><br></pre></td></tr></table></figure><br>可以发现，$2i$ 和 $4i$ (即 $2\cdot 2i$)在枚举 $2$ 的倍数时已经被打过标记了<br>其他任意一个 $k\cdot i, 2\leqslant k&lt; i$ 都同理。</p><h3 id="线性筛-转载"><a href="#线性筛-转载" class="headerlink" title="线性筛 (转载)"></a><a href="https://blog.csdn.net/qq_41653433/article/details/88976544">线性筛</a> (转载)</h3><p>初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数<br>把这些合数都筛掉，即算法名字的由来。但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。</p><p>例如 $30=5\times 3\times 2$，它被 $2\times 15$ 筛了一次，又被 $3\times 10$ 筛了一次，所以就有了如下算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mark[MAXN];  </span><br><span class="line"><span class="type">int</span> prime[MAXN];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断是否是一个素数  Mark 标记数组 index 素数个数  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="comment">//如果未标记则得到一个素数  </span></span><br><span class="line">        <span class="keyword">if</span>(mark[i] == <span class="number">0</span>) prime[++index] = i;  </span><br><span class="line">        <span class="comment">//标记目前得到的素数的i倍为非素数  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= index &amp;&amp; prime[j] * i &lt; n; j++)&#123;  </span><br><span class="line">            mark[i * prime[j]] = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> index;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用了每个合数必有一个最小素因子。每个合数仅被它的最小素因子筛去正好一次。所以为线性时间。<br>代码中体现在：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>$prime$ 数组中的素数是递增的,当 $i$ 能整除 $prime<em>j$，那么 $i\cdot prime</em>{j+1}$ 这个合数肯定也可以被 $prime<em>j$ 筛掉，因为 $i$ 中含有 $prime_j$, $prime_j$ 比 $prime</em>{j+1}$ 小。</p><p>接下去的素数同理，所以不用筛下去了。<br>在满足 $i\  \% \ prime_j = 0$这个条件之前以及第一次满足该条件时,$prime_j$ 必定是 $prime_j\cdot i$ 的最小因子</p><pre><code>版权声明：本文为lyf_018原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/qq_41653433/article/details/88976544</code></pre><h2 id="例题与作业"><a href="#例题与作业" class="headerlink" title="例题与作业"></a>例题与作业</h2><p>P1046 P1427 P1047 P1554 P1996 P2043 OJ1.6.03</p><p>Oj1.6.01 OJ1.6.04-05 OJ1.6.07 P5463 P1059 </p>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 埃氏筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读入未知数量的数据</title>
      <link href="/2022/07/14/2022-7-14-read-unknown-length/"/>
      <url>/2022/07/14/2022-7-14-read-unknown-length/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="读入未知数量的数据"><a href="#读入未知数量的数据" class="headerlink" title="读入未知数量的数据"></a>读入未知数量的数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k) != EOF)   <span class="comment">// EOF是读取结束标识</span></span><br><span class="line">    <span class="comment">// 又因为 scanf 在读取到 EOF 会返回 -1，所以也可以写成 while (~scanf(&quot;%d&quot;,&amp;k))</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一点值得注意的是，关于使用 <code>cin &gt;&gt; x</code> 时的返回值并不是 <code>cin</code> 的返回值，<code>cin</code> 只是一个对象，而实际进行运算的是流运算符 <code>&gt;&gt;</code>。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="查到的，你问我流运算符是啥我也不知道[^组合键]: 本文中\^z、\^d都指组合键，\^d为Ctrl+D，\^z为Ctrl+Z。">[1]</span></a></sup></p><p>Windows系统输入 <sup><a href="#fn_组合键" id="reffn_组合键">组合键</a></sup></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">^z</span><br></pre></td></tr></table></figure><p>GNU/Linux输入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">^d</span><br></pre></td></tr></table></figure></p><p>输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">查到的，你问我流运算符是啥我也不知道[^组合键]: 本文中^z、^d都指组合键，^d为Ctrl+D，^z为Ctrl+Z。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcd 最大公约数</title>
      <link href="/2022/07/14/2022-7-14-OI%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/14/2022-7-14-OI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="辗转相除法求最大公约数"><a href="#辗转相除法求最大公约数" class="headerlink" title="辗转相除法求最大公约数"></a>辗转相除法求最大公约数</h3><p>例：<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">70 % 50 = 20</span><br><span class="line">50 % 20 = 10</span><br><span class="line">20 % 10 = 0</span><br></pre></td></tr></table></figure></p><p>取模到0为止，此时10就是70、50最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,r;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span> (a % b != <span class="number">0</span>)&#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际应用中可以直接用 <code>__gcd()</code> 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::__gcd(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更相减损术求最大公约数"><a href="#更相减损术求最大公约数" class="headerlink" title="更相减损术求最大公约数"></a>更相减损术求最大公约数</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">54 24</span><br><span class="line">|        除以2（可除可不除，除后方便计算）</span><br><span class="line">V</span><br><span class="line">27 12</span><br><span class="line">27-12=15    大减小</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">6-3=3</span><br></pre></td></tr></table></figure><p>此处3=3,所以最大公约数为3</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钛合金伞的垃圾场</title>
      <link href="/2022/05/21/%E9%92%9B%E5%90%88%E9%87%91%E4%BC%9E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9C%BA/"/>
      <url>/2022/05/21/%E9%92%9B%E5%90%88%E9%87%91%E4%BC%9E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ArchLinux-添加证书（感谢Marisa）"><a href="#ArchLinux-添加证书（感谢Marisa）" class="headerlink" title="ArchLinux 添加证书（感谢Marisa）"></a>ArchLinux 添加证书（感谢<a href="https://yjacks.github.io/">Marisa</a>）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo trust anchor --store myCA.crt</span><br></pre></td></tr></table></figure><h2 id="Grub-提示-usr-share-grub-grub-mkconfig-lib-第-237-行：printf-“-”：无效格式字符"><a href="#Grub-提示-usr-share-grub-grub-mkconfig-lib-第-237-行：printf-“-”：无效格式字符" class="headerlink" title="Grub 提示 /usr/share/grub/grub-mkconfig_lib: 第 237 行：printf: “$”：无效格式字符"></a>Grub 提示 <code>/usr/share/grub/grub-mkconfig_lib: 第 237 行：printf: “$”：无效格式字符</code></h2><p>在英文环境下 <code>grub-mkconfig</code> 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env LANG=en_US.UTF-8 sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="gcc-编译提示-编译器内部错误：File-size-limit-exceeded-signal-terminated-program-as"><a href="#gcc-编译提示-编译器内部错误：File-size-limit-exceeded-signal-terminated-program-as" class="headerlink" title="gcc 编译提示 编译器内部错误：File size limit exceeded signal terminated program as"></a>gcc 编译提示 <code>编译器内部错误：File size limit exceeded signal terminated program as</code></h2><p>编译的时候爆内存了</p><p>可能是你用了形如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a[<span class="number">100000010</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><br>的语句进行初始化。<br>这个语句虽然只会给你的 $a_0,a_1$ 赋值，但是在编译预处理和程序运行的过程时，它都会将数组全部展开再进行赋值/初始化</p><p>所以还是老老实实赋值吧<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a[<span class="number">100000010</span>];</span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h2 id="gcc-编译提示-relocation-truncated-to-fit-R-X86-64-PC32-against-39-bss-39"><a href="#gcc-编译提示-relocation-truncated-to-fit-R-X86-64-PC32-against-39-bss-39" class="headerlink" title="gcc 编译提示 relocation truncated to fit: R_X86_64_PC32 against &#39;.bss&#39;"></a>gcc 编译提示 <code>relocation truncated to fit: R_X86_64_PC32 against &#39;.bss&#39;</code></h2><p>静态数组爆内存了，一般的解决方法是加编译选项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cxx -o test -mcmodel=medium</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cxx -o test -mcmodel=large</span><br></pre></td></tr></table></figure></p><p><del>其实换 clang++ 编译有的时候就能过</del><br><del>但是测评机肯定还是 gcc ，所以应该考虑下自己是不是写错数了</del></p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
            <tag> grub </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
