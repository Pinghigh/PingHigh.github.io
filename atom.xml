<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伞的隙间</title>
  
  <subtitle>天终会再明。</subtitle>
  <link href="http://blog.tibrella.top/atom.xml" rel="self"/>
  
  <link href="http://blog.tibrella.top/"/>
  <updated>2023-08-19T14:29:14.849Z</updated>
  <id>http://blog.tibrella.top/</id>
  
  <author>
    <name>Tibrella</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023.8.19 闲话</title>
    <link href="http://blog.tibrella.top/post/diary-2023-08-19/"/>
    <id>http://blog.tibrella.top/post/diary-2023-08-19/</id>
    <published>2023-08-19T14:05:17.000Z</published>
    <updated>2023-08-19T14:29:14.849Z</updated>
    
    <content type="html"><![CDATA[<p>首先是破事。</p><p>二南有个在灌水区吐槽 S2赛制的，讨论快完了之后某个姓听的教皇小猴子出来跳脚了，这人是个著名洛谷网红，有种地头蛇看谁不顺眼就怼谁的美感。上次一帮人和xht 对线的帖子里面我还没急这小猴子就指着我骂了。</p><p>于是听说他们在 HL 群对线，我 UID正好是偶数，进去就看见他还是那么桀骜不驯。于是和他耍一耍无赖就让他自尊心爆炸把我拉黑了。</p><p>啊，当然我针对他不是因为他骂我，而是长时间当洛谷网红四处引战，甚至作为一个山东人还要嘲讽山东天灾。早看他不顺眼了，可是他那么爱口嗨，怎么骂两句就破防了呢。</p><p>对线就是放下自尊心和对面耍无赖，所以对线是没意义的，唯一的作用是恶心人。所以不要对线，遇到这种人该拉黑拉黑该举报举报就完事了，没必要耽误自己时间。</p><p>我实在没想到一个金钩爷心理素质这么差，希望明年打国赛的时候心态别像今天这么崩溃就好了，反正人有钱买d 队，进不进队线无所谓。</p><p>拉黑完了之后想在群里恶心我，恶心得不伦不类的，给我逗笑了。</p><hr /><p>破事还是少点好。</p><p>打了场 ABC，C 题吃了 5发罚时，结果是一个非常傻逼的少更新一个数组的错误。（赛时没调出来）<br />非常完美的跳题策略，成功跳过 D 题并直接拿下 E 题，但是 F题太急了当贪心做了。</p><hr /><p>推歌</p><p>《ヒカリ》—— めらみぽっぷ，专辑 凋叶棕《綴》</p><p>梅拉米唱歌一直很有感染力，我认为这首是她感染力最强的一首。</p><p>第一次见这首歌是在 2023 东方新春宴的一个静止系 mad，差点看哭了。</p><p>讲的是神琦创作一个人偶爱丽丝，逐渐将其认可成为自己女儿的事。</p><p>没啥说的，梅拉米牛逼，这首歌从人声和伴奏上都很有感染力，对神琦的塑造非常形象。</p><hr /><p>abc315 e 题</p><p>实际上就是找出 1 这个任务依赖的所有任务。</p><p>于是建反图，从 1 开始 dfs，输出 dfs的出栈序列（逆后序）即可。由于栈顶一定没有依赖，所以相当于做了拓扑排序，是正确的。</p><hr /><p>要退役了，我要学跳表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先是破事。&lt;/p&gt;
&lt;p&gt;二南有个在灌水区吐槽 S2
赛制的，讨论快完了之后某个姓听的教皇小猴子出来跳脚了，这人是个著名洛谷网红，有种地头蛇看谁不顺眼就怼谁的美感。上次一帮人和
xht 对线的帖子里面我还没急这小猴子就指着我骂了。&lt;/p&gt;
&lt;p&gt;于是听说他们在 H</summary>
      
    
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/categories/%E9%97%B2%E8%AF%9D/"/>
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/tags/%E9%97%B2%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>2023.8.18 闲话</title>
    <link href="http://blog.tibrella.top/post/diary-2023-08-18/"/>
    <id>http://blog.tibrella.top/post/diary-2023-08-18/</id>
    <published>2023-08-18T13:54:19.000Z</published>
    <updated>2023-08-18T14:20:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>好好好，闲话日更了。</p><hr /><p>上午搜到了一个用 sdcc 支持的语法写的 <ahref="https://www.jianshu.com/p/bf313788b37b">LED控制程序</a>，还有完整的注释，于是就用了。现在单片机能够控制 LED灯亮灭了。就是用杜邦线串起来的两个 6 厘米多长的电阻看起来有点傻逼😅。然后还得串一个 LED 进去。</p><p>8051这块貌似被商业工具链占据大部分市场了，个人认为这是很恐怖的事情，所以迅速使用sdcc 报平安。Keil再对个人免费你也没法确定什么时候割韭菜，对商业公司人也肯定得收费。</p><p>ARM 和 RISC-V 之类架构的板子，LLVM 应该够用了，在这基础之上你还能写Rust 之类支持 LLVM 后端的语言。</p><p>买的 RGB灯环好傻逼，不能用杜邦线接，口太细还焊不了，买的时候应该看看接口型号的😅。</p><p>下一步就是折腾数码管了，打算搞一个 IO口用来校准时间，然后用塑料定一个包装送给谢特以报答他从他们学校小卖部给我买的东方明信片。</p><p>会发博客的，这方面教程还是太少了。</p><hr /><p>推歌。</p><p>まりおさんに贈るナイト・オブ・ナイツ2018 —— marasy，专辑是COOL&amp;CREATE 的骑士之夜。</p><p>听到的第一首来自触手猴的东方组曲，这首曲子在音色（收音），编曲，节奏上都无可挑剔，感觉是非常养耳朵的一首歌，它的收音要比很多猴子专辑中的曲子好的。</p><p>实际上就是在骑士之夜里串了好几首曲子（笑）</p><p>但是多少有点中耳炎，这段时间不太能听歌了。</p><hr /><p>题目分享继续见<a href="/post/count-misc-questions">计数杂题</a>。</p><hr /><p><ahref="https://www.luogu.com.cn/blog/tibrella/fei-yang-di-xiao-niao-ben-ji">飞扬的小鸟本纪</a></p><hr /><p>篮球基本不会打了，现在干什么都跟半身不遂一样不协调。</p><hr /><p>博客的 MathJax 终于让咱给修好了，改了一下目录结构，把 MathJax相关的文件扔到了和评论同级的 <code>plugins</code>目录下，然后仿照一刀斩给 waline/valine 写的加载脚本给 MathJax贺了一份。</p><p>现在可能出现的问题是打开某一个页面是白色的，原因未知，刷新就好了。</p><p>对了，我编写的 MathJax 加载脚本是使用原配置文件中的 cdn选项的，所以不用担心选项失效什么的问题。本站现在使用最新的 MathJax4.0.0-beta.3 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好好好，闲话日更了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;上午搜到了一个用 sdcc 支持的语法写的 &lt;a
href=&quot;https://www.jianshu.com/p/bf313788b37b&quot;&gt;LED
控制程序&lt;/a&gt;，还有完整的注释，于是就用了。现在单片机能够控制 </summary>
      
    
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/categories/%E9%97%B2%E8%AF%9D/"/>
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/tags/%E9%97%B2%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>2023.8.17 闲话</title>
    <link href="http://blog.tibrella.top/post/diary-2023-08-17/"/>
    <id>http://blog.tibrella.top/post/diary-2023-08-17/</id>
    <published>2023-08-17T13:46:27.000Z</published>
    <updated>2023-08-18T06:49:49.794Z</updated>
    
    <content type="html"><![CDATA[<p>首先一个喜报，两天时间把博客迁移到 Hexo上了，更好的是，很多东西都有国内 CDN支持，所以你访问本博客不会太慢。</p><p><del>不太好的是，由于 InstantClick 的一些东西没搞明白，对 JSX还不够熟悉，导致你从本站某一个页面转到另一个页面的时候会导致数学失效。同时首页摘要上的<span class="math inline">\(\LaTeX\)</span> 可能会炸。</del>修好了。</p><p>这个主题实在太强了，很多自定义标签，还有时间轴和项目文档支持，刚刚给linux-tikogasa写了个介绍，可以点击页面底部的文档字样进入。时间轴进入方法同理。</p><hr /><p>再来一个喜报，经过 2天的等待，我买的晶振到了。然后经过一中午和晚上一小时的折腾，成功让电脑检测到了单片机的信息。不得不说，这方面教程还是太少了，过两天写一个基础安装的文档。</p><p>下一步是用 sdcc 编写程序，但是为什么这个 RGB灯环没有文档啊，可恶。</p><hr /><p>推歌。</p><p>《亡霊》 —— あよ，专辑《ダイナマイト》。</p><p>非常好的慵懒感，可能是因为长时间缺乏睡眠精神紧张导致喜欢这种感觉的吧（笑）。</p><hr /><p>题目分享可以看<a href="/post/count-misc-questions">计数杂题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先一个喜报，两天时间把博客迁移到 Hexo
上了，更好的是，很多东西都有国内 CDN
支持，所以你访问本博客不会太慢。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不太好的是，由于 InstantClick 的一些东西没搞明白，对 JSX
还不够熟悉，导致你从本站某一个页面转到另一个</summary>
      
    
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/categories/%E9%97%B2%E8%AF%9D/"/>
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/tags/%E9%97%B2%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>计数杂题</title>
    <link href="http://blog.tibrella.top/post/count-misc-questions/"/>
    <id>http://blog.tibrella.top/post/count-misc-questions/</id>
    <published>2023-08-17T11:54:05.000Z</published>
    <updated>2023-08-18T14:08:50.449Z</updated>
    
    <content type="html"><![CDATA[<p>部分题目来自<ahref="https://www.luogu.com.cn/training/2019#problems">这个题单</a>。</p><h2 id="luogu-p6075-jsoi2015-子集选取">Luogu P6075 [JSOI2015]子集选取</h2><p>首先，发现可以把元素单独拎出来考虑，假设对于一个元素来说有 <spanclass="math inline">\(x\)</span> 种放置方案，则答案为 <spanclass="math inline">\(x^n\)</span>。</p><p>继续转化题意。</p><p>对于 <spanclass="math inline">\(A_{i,j}\)</span>，它必须是它左边集合的子集，也得是上边集合的子集。<br />也就是说，如果 <span class="math inline">\(A_{i,j}\)</span> 包含元素<spanclass="math inline">\(x\)</span>，则在它正上方、左上方、左侧的所有集合都包含<span class="math inline">\(x\)</span>。（形式化来说，即 <spanclass="math inline">\(A_{a,b},1\leqslant a \leqslant i,1\leqslant b\leqslant j\)</span> 均包含 <span class="math inline">\(x\)</span>）</p><p>然后想象一种合法方案，容易发现每种方案就相当于把整个三角形分成两半，左上一半右下一半。</p><p>每两种方案不同当且仅当左上右下的分界线不同。</p><p>于是我们就能很轻松地求方案数了，即一个分界线从左下走到右上的方案。每一步可以向左或者向右走，即<span class="math inline">\(2^k\)</span>。</p><p>快速幂即可。</p><h2 id="luogu-p6146-usaco20feb-help-yourself-g">Luogu P6146 [USACO20FEB]Help Yourself G</h2><p>首先为了划分未求解和已求解的部分，我们需要把线段按照左端点排序。</p><p>给一个不排序会遇到错误的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---- 1  ------3</span><br><span class="line">  --------- 2</span><br></pre></td></tr></table></figure><p>用下面的做法做的话，先算 <span class="math inline">\(1,3\)</span>和先算 <span class="math inline">\(1,2\)</span>是不一样的，可以自己体会一下。</p><p>然后设 <span class="math inline">\(f_i\)</span> 为前 <spanclass="math inline">\(i\)</span>个线段的答案。为什么只有一维？因为容易发现子集这个东西很难用来划分阶段。另外前面的排序已经使得这种状态划分是唯一的了。</p><p>考虑如何推出 <span class="math inline">\(f_i\)</span>。</p><p><span class="math inline">\(f_i\)</span> 的答案由两部分组成：</p><ul><li>前 <span class="math inline">\(i-1\)</span> 个线段的答案 <spanclass="math inline">\(f_{i-1}\)</span></li><li>前面所有子集加上第 <span class="math inline">\(i\)</span>条线段的答案。</li></ul><p>发现后者实际上也是分两部分的：</p><ul><li>新增的连通块（复杂度）</li><li>除去新增，也就是原有的复杂度 <spanclass="math inline">\(f_{i-1}\)</span></li></ul><p>好了，那么新增的连通块怎么算？实际上就是与第 <spanclass="math inline">\(i\)</span> 条线段不相交的前 <spanclass="math inline">\(i-1\)</span> 条线段的子集的数量。为啥呢？<br />那我们可以把前 <span class="math inline">\(i-1\)</span>条线段的子集分两类：与 <span class="math inline">\(i\)</span>相交与不相交。显然相交的子集不会贡献答案，不相交的子集会且仅会贡献 <spanclass="math inline">\(1\)</span> 的答案。</p><p>然后问题就转化为：对前 <span class="math inline">\(i-1\)</span>条线段与线段 <span class="math inline">\(i\)</span>不相交的子集计数。<br />容易发现就是与线段 <span class="math inline">\(i\)</span>不相交的所有线段集合 <span class="math inline">\(\mathbb X\)</span>的子集数量，计数就是 <span class="math inline">\(2^{\lvert \mathbb X\rvert}\)</span></p><p>得到递推式：</p><p><span class="math display">\[f_i = 2f_{i-1}+2^{\lvert \mathbb X \rvert}\]</span></p><p><span class="math inline">\(\mathbb X\)</span>的大小我们可以预处理出来：统计每一个右端点出现的次数 <spanclass="math inline">\(s_i\)</span>，然后做一个前缀和，最后 <spanclass="math inline">\(s_{i-1}\)</span> 就是不覆盖点 <spanclass="math inline">\(i\)</span> 的线段数量。</p><p>用快速幂优化，复杂度 <spanclass="math inline">\(\operatorname{O}(n\log n+n\logn)\)</span>，如果用光速幂可以干到 <spanclass="math inline">\(\operatorname{O}(n\log n+n+\sqrt n)\)</span>。</p><h2 id="p6008-usaco20jan-cave-paintings-p">P6008 [USACO20JAN] CavePaintings P</h2><p>首先发现答案就是把每个连通块的方案数乘起来。</p><p>那对于一个连通块怎么算答案？一个比较蛋疼的事实是，即使是同一个连通块，我们也不能保证它每个部分的水位是一样的，比如下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">########</span><br><span class="line">###  ###</span><br><span class="line">#      #</span><br><span class="line">#  ##  #</span><br><span class="line">#  ##  #</span><br><span class="line">########  </span><br></pre></td></tr></table></figure><p>显然左右侧在分割开的时候可以水位高度不同。</p><p>那我们能不能对分割开的两块分别算呢？答案是不行，因为连通器原理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">########</span><br><span class="line">#  ##  #</span><br><span class="line">#  ##  #</span><br><span class="line">#      #</span><br><span class="line">#      #</span><br><span class="line">########  </span><br></pre></td></tr></table></figure><p>初中物理可知，左右两侧水位必须一样高。</p><p>所以我们需要动态维护这个关系，用啥呢？并查集。</p><p>初始化每个格子答案为1，然后对于每个连通块从下往上涨水，过程如下：</p><ul><li>把这一行相邻的能放水的位置连在一起，表示他们必须是一个水位的。</li><li>遍历该行每一个空位，如果这个位置下面也是空位且二者目前没有相连，那么当前位置方案数<code>*=</code>正下方一格方案数，同时把两个格子相连，表示两个连通块接在一起了。</li><li>遍历该行每一个空位，每遇到一个连通块（<code>find(x) == x</code>）就把该格方案数加一。</li></ul><p>最后用前面提到过的判断连通块的方式把答案乘起来就好了。</p><h2 id="luogu-p1350-车的放置">Luogu P1350 车的放置</h2><p>同样是蓝题，但是比上一道水多了。</p><p>每一行每一列都只能放一个棋子，那直接从上往下遍历行，同时枚举放几颗棋子递推计数即可。</p><p>具体来说，设 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span> 行放了 <spanclass="math inline">\(j\)</span> 个棋子的方案数量，则转移方程如下：</p><p><span class="math display">\[f_{i,j} = f_{i-1,j} + f_{i-1,j-1} (len-j+1)\]</span></p><p>其中 <span class="math inline">\(len\)</span> 是行长度。</p><p>记得把 <span class="math inline">\(f_{0\sim b+d, 0}\)</span> 设为<span class="math inline">\(1\)</span>。</p>]]></content>
    
    
    <summary type="html">计数太烂了，多写几道题吧...</summary>
    
    
    
    <category term="题解" scheme="http://blog.tibrella.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="组合数学" scheme="http://blog.tibrella.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="计数" scheme="http://blog.tibrella.top/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023.8.10 闲话</title>
    <link href="http://blog.tibrella.top/post/diary-2023-08-10/"/>
    <id>http://blog.tibrella.top/post/diary-2023-08-10/</id>
    <published>2023-08-10T05:48:11.000Z</published>
    <updated>2023-08-16T14:10:12.404Z</updated>
    
    <content type="html"><![CDATA[<p>在四机房尝试了一下双显示器（笔记本+机房显示器）</p><p>机房屏幕是真大，但是 dpi 太低了。将近 1.5 倍的尺寸于我的笔记本，但是dpi 我的笔记本是机房显示器的 1.25 倍，实际观感要差的很多。</p><p>所以说啊，拯救字体渲染的最好方式还是换高 dpi 显示屏。</p><p>但是我觉得微软雅黑真是一坨大便。</p><hr /><p>学习 <a href="https://www.cnblogs.com/CDOI-24374">jijidawang</a> 和<a href="www.cnblogs.com/crimsonawa">crimson000</a> 进行一个推歌。</p><p>MY Heart Rate —— あよ，专辑：森羅万象《シンクロ2》</p><p>ayo 牛逼，没得说。</p><p>这首歌总能带来一些轻松的感觉呢，想必是编曲的时候考虑到灵梦日常的无聊心情吧（笑）</p><p>另外，Heart Rate 用比较 Japanglish 的口音读的话，应该能发现这是はくれい（Hakurei）的谐音。</p><hr /><p>改天需要把 dotfile 分享一下了，还有安装指南的坑没填</p><p>pacman 实在是太好用了</p><hr /><p>改了 T2，因为这题能体现出来长时间摆烂让我的思维脱离了“OI”。</p><p><a href="https://www.luogu.com.cn/problem/P7165">题面</a></p><p>首先看到题目要求断两条边，应当能够立刻想到暴力：<spanclass="math inline">\(n^2\)</span> 枚举两条边。</p><p>但是我他妈没想到，我直接找的重心，导致这题就算不绑包我也就过了一个点。</p><p>枚举应当是最基本的东西，但是我没想到，说明我状态还没回来。<br />希望能尽快吧。</p><p>然后走向玄学乱搞。</p><p>这题显然不是让你找到一个点然后乱搞出分割方案的，因为要断两条边，所以找一个点的方式应当排除。</p><p>考虑枚举一条边，另一条边用根号或者 <spanclass="math inline">\(\log\)</span> 的时间复杂度搞出来。</p><p>考虑当你枚举断掉一条边的时候，也就是拎出来了一棵子树，树的剩下的部分怎么选比较合适？显然是把它们切成一半。</p><p>于是大体思路形成：dfs，到每个节点的时候将这棵树从当前节点的父边断开，然后形成了两棵树，形如Archlabs 的 logo。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64d4f0d01ddac507cc618df0" fancybox="true"/></div></div><p>开两个 <code>std::multiset&lt;int&gt;</code> 维护 dfs过程中遍历过的所有子树的大小。</p><p>为啥是两个呢，对于 <span class="math inline">\(u\)</span>的父节点，其 <span class="math inline">\(siz\)</span> 是包含 <spanclass="math inline">\(siz_u\)</span> 的，所以对于 <spanclass="math inline">\(u\)</span> 的祖先节点的 <spanclass="math inline">\(siz\)</span> 需要单独维护一个集合。</p><p>然后对于这两种子树，分别利用<code>std::multiset&lt;int&gt;::lower_bound</code>找到最接近该树一半大小的子树，然后比大小更新答案。大于小于不知道哪个更接近的话，两个都判一下就完事了。</p><hr /><p>tho 和 thu，一个都去不了，这就是独属于我的悲伤吧。</p><hr /><p>闲话不够多，以后改进。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在四机房尝试了一下双显示器（笔记本+机房显示器）&lt;/p&gt;
&lt;p&gt;机房屏幕是真大，但是 dpi 太低了。将近 1.5 倍的尺寸于我的笔记本，但是
dpi 我的笔记本是机房显示器的 1.25 倍，实际观感要差的很多。&lt;/p&gt;
&lt;p&gt;所以说啊，拯救字体渲染的最好方式还是换高</summary>
      
    
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/categories/%E9%97%B2%E8%AF%9D/"/>
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/tags/%E9%97%B2%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>（转载）什么是 P 问题、NP 问题和 NPC 问题</title>
    <link href="http://blog.tibrella.top/post/p-np-npc/"/>
    <id>http://blog.tibrella.top/post/p-np-npc/</id>
    <published>2023-08-05T23:36:57.000Z</published>
    <updated>2023-08-17T11:40:07.504Z</updated>
    
    <content type="html"><![CDATA[<p><ahref="https://www.matrix67.com/blog/archives/7084">原文传送门</a>，本人对其进行了格式上的改动。</p><p>这或许是众多 OIer 最大的误区之一。你会经常看到网上出现“这怎么做，这不是 NP问题吗”、“这个只有搜了，这已经被证明是 NP问题了”之类的话。你要知道，大多数人此时所说的 NP 问题其实都是指的 NPC问题。他们没有搞清楚 NP 问题和 NPC 问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P 问题，什么是 NP 问题，什么是 NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把 NP 问题当成是NPC 问题是一个多大的错误。</p><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有<span class="math inline">\(\Theta(1)\)</span>的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是<span class="math inline">\(\Theta(n)\)</span>，比如找 <spanclass="math inline">\(n\)</span>个数中的最大值；而像冒泡排序、插入排序等，数据扩大 <spanclass="math inline">\(2\)</span> 倍，时间变慢 <spanclass="math inline">\(4\)</span> 倍的，属于 <spanclass="math inline">\(\Theta(n^2)\)</span>的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是 <spanclass="math inline">\(\Theta(a^n)\)</span> 的指数级复杂度，甚至 <spanclass="math inline">\(\Theta(n!)\)</span> 的阶乘级复杂度。不会存在 <spanclass="math inline">\(\Theta(2n^2)\)</span>的复杂度，因为前面的那个“<spanclass="math inline">\(2\)</span>”是系数，根本不会影响到整个程序的时间增长。同样地，<spanclass="math inline">\(\Theta(n^3+n^2)\)</span> 的复杂度也就是 <spanclass="math inline">\(\Theta(n^3)\)</span>的复杂度。因此，我们会说，一个 <spanclass="math inline">\(\Theta(0.01n^3)\)</span> 的程序的效率比 <spanclass="math inline">\(\Theta(100n^2)\)</span> 的效率低，尽管在 <spanclass="math inline">\(n\)</span>很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 <spanclass="math inline">\(\Theta(n^3)\)</span> 的复杂度将远远超过 <spanclass="math inline">\(\Theta(n^2)\)</span>。我们也说，<spanclass="math inline">\(\Theta(n^{100})\)</span> 的复杂度小于 <spanclass="math inline">\(\Theta(1.01^n)\)</span> 的复杂度。<br />容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是<span class="math inline">\(\Theta(1),\Theta(\logn),\Theta(n^a)\)</span> 等，我们把它叫做多项式级的复杂度，因为它的规模<span class="math inline">\(n\)</span> 出现在底数的位置；另一种是 <spanclass="math inline">\(\Theta(a^n)\)</span> 和 <spanclass="math inline">\(\Theta(n!)\)</span>型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”（UndecidableDecision Problem）。The Halting Problem 就是一个著名的不可解问题，在我的Blog 上有过专门的介绍和证明<a href="#fn1" class="footnote-ref"id="fnref1" role="doc-noteref"><sup>1</sup></a>。再比如，输出从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 这 <spanclass="math inline">\(n\)</span>个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC 问题。</p><p>下面引入 P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P 问题。P 是英文单词多项式的第一个字母。哪些问题是 P 类问题呢？通常 NOI和 NOIP 不会出不属于 P 类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。<br />接下来引入 NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我 RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于<span class="math inline">\(100\)</span>个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度<span class="math inline">\(98\)</span>，比 <spanclass="math inline">\(100\)</span> 小。于是答案出来了，存在比 <spanclass="math inline">\(100\)</span>小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比<span class="math inline">\(100\)</span>小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要<span class="math inline">\(\Theta(n)\)</span>的时间复杂度，也就是说我可以花 <spanclass="math inline">\(\Theta(n)\)</span>的时间把我猜的路径的长度加出来。那么，只要我 RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP 问题。当然有不是 NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton 回路是 NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton 回路”。<br />之所以要定义 NP 问题，是因为通常只有 NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨 NP 问题与 P 类问题的关系。</p><p>很显然，所有的 P 类问题都是 NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP 问题都是 P 类问题。我们可以再用集合的观点来说明。如果把所有 P类问题归为一个集合 <span class="math inline">\(\mathbb P\)</span>中，把所有 NP 问题划进另一个集合 <span class="math inline">\(\mathbb{NP}\)</span> 中，那么，显然有 <span class="math inline">\(\mathbb P \in\mathbb {NP}\)</span>。现在，所有对 NP问题的研究都集中在一个问题上，即究竟是否有 <spanclass="math inline">\(P=NP\)</span>？通常所谓的“NP问题”，其实就一句话：证明或推翻 <spanclass="math inline">\(P=NP\)</span>。<br />NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。<br />目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，<spanclass="math inline">\(P=NP\)</span>不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP 问题。人们如此坚信 <span class="math inline">\(P\neq NP\)</span>是有原因的，就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做NP-完全问题，也即所谓的 NPC 问题。C 是英文单词“完全”的第一个字母。正是NPC 问题的存在，使人们相信 <span class="math inline">\(P\neqNP\)</span>。下文将花大量篇幅介绍 NPC 问题，你从中可以体会到 NPC 问题使<span class="math inline">\(P=NP\)</span> 变得多么不可思议。</p><p>为了说明 NPC问题，我们先引入一个概念——约化（Reducibility，有的资料上叫“归约”）。<br />简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B的解法解决问题 A，或者说，问题 A 可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为<spanclass="math inline">\(0\)</span>。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为 TSP 问题（Travelling Salesman Problem，旅行商问题）：在Hamilton 回路问题中，两点相连即这两点距离为 <spanclass="math inline">\(0\)</span>，两点不直接相连则令其距离为 <spanclass="math inline">\(1\)</span>，于是问题转化为在 TSP问题中，是否存在一条长为 <span class="math inline">\(0\)</span>的路径。Hamilton 回路存在当且仅当 TSP 问题中存在长为 <spanclass="math inline">\(0\)</span> 的回路。<br />“问题 A 可约化为问题 B”有一个重要的直观意义：B 的时间复杂度高于或者等于A 的时间复杂度。也就是说，问题 A 不比问题 B 难。这很容易理解。既然问题 A能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A的算法就可以改进为 B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br />很显然，约化具有一项重要的性质：约化具有传递性。如果问题 A 可约化为问题B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题C。这个道理非常简单，就不必阐述了。现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A 的输入，都能按这个法则变换成程序 B的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B。<br />当然，我们所说的“可约化”是指的可“多项式地”约化（Polynomial-timeReducible），即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P 和 NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP 问题的一个稍复杂的大 NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级 NP 问题？答案居然是肯定的。也就是说，存在这样一个 NP问题，所有的 NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是 NP-完全问题。NPC 问题的出现使整个 NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC 问题”。此时，我的目的终于达到了，我已经把 NP 问题和 NPC问题区别开了。到此为止，本文已经写了近 5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>NPC 问题的定义非常简单。同时满足下面两个条件的问题就是 NPC问题。首先，它得是一个 NP 问题；然后，所有的 NP问题都可以约化到它。证明一个问题是 NPC 问题也很简单。先证明它至少是一个NP 问题，再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC问题定义的第二条也得以满足；至于第一个 NPC问题是怎么来的，下文将介绍），这样就可以说它是 NPC 问题了。<br />既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP也就等于 P 了。因此，给 NPC找一个多项式算法太不可思议了。因此，前文才说，“正是 NPC问题的存在，使人们相信 <span class="math inline">\(P\neqNP\)</span>”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下 NP-Hard 问题。NP-Hard 问题是这样一种问题，它满足 NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard 问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于 NP-Hard放宽了限定条件，它将有可能比所有的 NPC问题的时间复杂度更高从而更难以解决。</p><p>不要以为 NPC 问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于 NPC问题。下文即将介绍它。<br />下文即将介绍逻辑电路问题。这是第一个 NPC 问题。其它的 NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC类问题的“鼻祖”。<br />逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br />什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│IN 1├──┐  ┌────┐</span><br><span class="line">└────┘  └─→┤    │</span><br><span class="line">           │ or ├→───┐</span><br><span class="line">┌────┐  ┌─→┤    │    │  ┌────┐</span><br><span class="line">│IN 2├──┘  └────┘    └─→┤    │</span><br><span class="line">└────┘                  │ AND├──→OUT</span><br><span class="line">                  ┌────→┤    │</span><br><span class="line">┌────┐  ┌────┐    │     └────┘</span><br><span class="line">│IN 3├─→┤NOT ├─→──┘</span><br><span class="line">└────┘  └────┘</span><br></pre></td></tr></table></figure><p>这是个较简单的逻辑电路，当输入 1、输入 2、输入 3 分别为True、True、False 或 False、True、False 时，输出为 True。有输出无论如何都不可能为 True的逻辑电路吗？有。下面就是一个简单的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│IN 1├→─┐  ┌────┐</span><br><span class="line">└────┘  └─→┤    │</span><br><span class="line">           │AND ├─→┐</span><br><span class="line">        ┌─→┤    │  │</span><br><span class="line">        │  └────┘  │ ┌────┐</span><br><span class="line">        │          └→┤    │</span><br><span class="line">┌────┐  │            │AND ├─→OUT</span><br><span class="line">│IN 2├→─┤ ┌────┐   ┌→┤    │</span><br><span class="line">└────┘  └→┤NOT ├→──┘ └────┘</span><br><span class="line">          └────┘</span><br></pre></td></tr></table></figure><p>上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为 True 的一组输入。回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。 逻辑电路问题属于 NPC问题。这是有严格证明的。它显然属于 NP 问题，并且可以直接证明所有的 NP问题都可以约化到它（不要以为 NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些0 和 1 的运算），因此对于一个 NP 问题来说，问题转化为了求出满足结果为True 的一个输入（即一个可行解）。</p><p>有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC问题的有很多，任何一个找到了多项式算法的话所有的 NP问题都可以完美解决了。因此说，正是因为 NPC 问题的存在，<spanclass="math inline">\(P=NP\)</span> 变得难以置信。<spanclass="math inline">\(P=NP\)</span>问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><liid="fn1"><p>编者注：即停机问题。大体来说就是判断一个程序是否是死循环。本文原作者博客的证明：<ahref="https://www.matrix67.com/blog/archives/55">传送门</a><ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">对 P NP NPC NP-Hard 问题的解释，深度好文</summary>
    
    
    
    <category term="杂文" scheme="http://blog.tibrella.top/categories/%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>2023.8.5 闲话</title>
    <link href="http://blog.tibrella.top/post/diary-2023-08-05/"/>
    <id>http://blog.tibrella.top/post/diary-2023-08-05/</id>
    <published>2023-08-05T05:46:11.000Z</published>
    <updated>2023-08-16T14:09:59.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dear all,</p><p>It is with a heavy heart that we have to inform you that BramMoolenaar passed away on 3 August 2023.我们不得不怀着沉重的心情通知您，布拉姆·穆伦纳尔于 2023 年 8 月 3日去世。</p><p>Bram was suffering from a medical condition that progressed quicklyover the last few weeks.布拉姆患有一种疾病，在过去几周里病情迅速加深。</p><p>Bram dedicated a large part of his life to VIM and he was very proudof the VIM community that you are all part of. Bram将他生命中的大部分时间奉献给了 VIM，他为你们所在的 VIM社区感到非常自豪。</p><p>We as family are now arranging the funeral service of Bram which willtake place in The Netherlands and will be held in the Dutch lanuage. Theextact date, time and place are still to be determined.作为家人，我们现在正在安排布拉姆的葬礼。该葬礼将在荷兰以荷兰语举行。具体日期、时间和地点待定。</p><p>Should you wish to attend his funeral then please send a message tofuner...@gmail.com. This email address can also be used to get incontact with the family regarding other matters, bearing in the mind thesituation we are in right now as family. 如果您想参加他的葬礼，请给（一个登录才能看到的邮箱地址）发送邮件。考虑到我们现在作为家人的处境，这个电子邮件地址也可以用来与家人就其他事项取得联系。</p><p>With kind regards, The family of Bram Moolenaar</p></blockquote><p>Vim 之父于 2023.8.3 去世。</p><p>总有这样的一天的，Vim能够挺过它多个曾经的主要开发者的离世，实际上说明了 Vim本身的优秀性。</p><p>但是，当 Linus 脱离了 Linux 的开发呢？疫情时看见 Linus爆喷内核邮件列表里的疫苗阴谋论者，其他时候也总能看见他对待不规范不合适的patch 坚决的态度，这确实让 Linux Kernel仓库足够的健康。但是人总归要离开的。</p><p>人世太无常了。感觉和 <ahref="https://archlinux.org/news/in-memory-of-jonathon-fernyhough/">ArchLinux 社区一位贡献者的去世</a>还没有多久啊...</p><p>看一眼新闻，就在去年的 2 月份，Bram Moolenaar 的好友，Vim的重要开发者&amp;宣传者之一 Sven Guckes 因脑瘤去世，当时 Bram Moolenaar还说要用 Vim 9 来纪念他。</p><p>想成为他们那样的人，尽力地在世界上留下一些东西。于是退役前的我突然努力写博客一样。</p><p>剩下的时间...多陪陪家人朋友吧。</p><hr /><p><strong>AGC013D</strong></p><p>首先发现，一个取球的序列实际上就是一个合法的操作方案。</p><p>能不能直接操作方案计数？发现不能。为什么？</p><p>什么时候取球序列不同？仅当<strong>每次拿出的球</strong>不同。</p><p>什么时候操作方案不同？即使取球序列是相同的，如果最初黑白球数量不同，也算不同的操作方案。</p><p>设白球数量为 <span class="math inline">\(n\)</span>。</p><p>对于一个取球序列，它对应哪些东西呢？</p><p>把操作过程中白球数量的变化画出折线图： <div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png" fancybox="true"/></div></div></p><p>显然一个操作方案对应一条折线。</p><p>那么让初始的 <span class="math inline">\(n\)</span>变化一下，就相当于让这个折线上下移动。</p><p>向上移动到头就是折线触碰了 <spanclass="math inline">\(n\)</span>，向下移动到头就是折线触碰了 <spanclass="math inline">\(0\)</span>。</p><p>发现一个取球序列对应且仅对应一个折线触底的操作方案。</p><p>于是可以直接统计触底方案数。</p><p>具体：设 <span class="math inline">\(f_{i,j,0/1}\)</span> 为第 <spanclass="math inline">\(i\)</span> 次取球，箱子里有 <spanclass="math inline">\(j\)</span> 个白球，是/否触过底的方案数。</p><p>初始化直接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i32 i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    f[<span class="number">0</span>][i][i == <span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>就行。</p><p>转移看兔队博客吧。</p><p><a href="https://www.luogu.com.cn/record/119213073">代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Dear all,&lt;/p&gt;
&lt;p&gt;It is with a heavy heart that we have to inform you that Bram
Moolenaar passed away on 3 August 2023.
我</summary>
      
    
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/categories/%E9%97%B2%E8%AF%9D/"/>
    
    
    <category term="闲话" scheme="http://blog.tibrella.top/tags/%E9%97%B2%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>KMP 相关</title>
    <link href="http://blog.tibrella.top/post/KMP/"/>
    <id>http://blog.tibrella.top/post/KMP/</id>
    <published>2023-08-04T03:49:41.000Z</published>
    <updated>2023-08-19T02:55:40.162Z</updated>
    
    <content type="html"><![CDATA[<p>今天是 8 月 4 日喵，距离退役还有 3 个月左右喵。<br />写字符串的时候感觉突然悟了，于是来写笔记。</p><h2 id="前缀函数">前缀函数</h2><p>实际上看了 OI Wiki 才知道有这个名词……但是也应该有，因为 KMP只是一个匹配算法。</p><h3 id="定义">定义</h3><p>约定：为了方便表示，此处字符串下标从 <spanclass="math inline">\(1\)</span> 开始；对于串 <spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(X(i,j)\)</span> 表示截取 <spanclass="math inline">\(X\)</span> 的 <spanclass="math inline">\([i,j]\)</span> 段。</p><p>对于串 <span class="math inline">\(S\)</span>，其前缀函数 <spanclass="math inline">\(P\)</span> 为一个数组，<spanclass="math inline">\(P_i\)</span> 表示 <spanclass="math inline">\(S(1,i)\)</span> 这段前缀字符串的最长border（不包含 <span class="math inline">\(S(1,i)\)</span> 本身）。</p><p>呃，什么是 border？简单来说，串 <spanclass="math inline">\(X\)</span> 的一个 border 就是 <spanclass="math inline">\(X\)</span> 的一对相等的前缀后缀。</p><p>举个例子，设 <span class="math inline">\(X =\texttt{abcssfabc}\)</span>，则 <spanclass="math inline">\(\texttt{abc}\)</span> 是 <spanclass="math inline">\(X\)</span> 的一个 border。同样的，对于 <spanclass="math inline">\(\texttt{abbabba}\)</span> 来说，存在三个border，即 <spanclass="math inline">\(\texttt{a},\texttt{abba},\texttt{abbabba}\)</span><ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>。</p><p>好了，现在我们设 <spanclass="math inline">\(S=\texttt{abcabc}\)</span>，尝试一下求 <spanclass="math inline">\(S\)</span>的前缀函数？如果上面的概念你还没有理解，可以直接参考下图。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64cced901ddac507ccfe0344" fancybox="true"/></div></div><p>于是，<span class="math inline">\(S\)</span> 的前缀函数则为 <spanclass="math inline">\(\left[0,0,0,1,2,3\right]\)</span></p><h3 id="性质">性质</h3><p>遇到 border 相关要对“跳 border”敏感一些。啥叫跳 border 呢？</p><p>拿 <span class="math inline">\(\texttt{abbabba}\)</span>来举例子，假设其前缀函数为 <spanclass="math inline">\(P\)</span>，容易求得 <spanclass="math inline">\(P=[0,0,0,1,2,3,4]\)</span>。<br />末尾的 <span class="math inline">\(P_7 = 4\)</span>，代表的是 <spanclass="math inline">\(\texttt{abba}\)</span> 这个border。然后就出现了一个神奇的事情：如果把该串所有合法的 border按照长度排序，则 <span class="math inline">\(\texttt{abba}\)</span>的上一个 border 就是 <span class="math inline">\(\text a\)</span>。</p><p>那这个 <span class="math inline">\(\texttt a\)</span> 是什么呢？就是<span class="math inline">\(P_{P_7}\)</span> 代表的 border 喵。</p><p>换句话说，如果 <span class="math inline">\(X\)</span> 的前缀函数<span class="math inline">\(P\)</span> 已知，则：令 <spanclass="math inline">\(m\gets X.length\)</span>，反复让 <spanclass="math inline">\(m \getsP_m\)</span>，则能够按长度从大到小遍历完原串所有的合法border。这就是所谓“跳 border”。</p><h3 id="线性递推求前缀函数">线性递推求前缀函数</h3><p>实际上如果前面的东西你都明白了，这个部分是可以轻松想出来的。</p><p>以防万一，我还是写一份思考过程。</p><p>假设目前位置是 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(i-1\)</span> 以及之前的 <spanclass="math inline">\(P\)</span> 都已知，再令 <spanclass="math inline">\(j\gets P_{i-1}\)</span>，想办法递推求出 <spanclass="math inline">\(P_i\)</span>。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64ccf7bb1ddac507cc16d2e7" fancybox="true"/></div></div><p>如果红色部分是 <span class="math inline">\(S(1,i)\)</span> 的合法border 且长度不为 <spanclass="math inline">\(1\)</span>，则蓝色部分必然是 <spanclass="math inline">\(S(1,i-1)\)</span> 的合法 border。</p><p>因此，我们可以枚举 <span class="math inline">\(S(1,i-1)\)</span>的所有合法 border，看看能不能接上 <spanclass="math inline">\(S_i\)</span> 这个字母形成 <spanclass="math inline">\(S(1,i)\)</span> 的 border。遍历 border可以采用上面说过的跳 border实现。由于这个过程是从长到短遍历，因此找到的合法 border 必然是最长的合法border。</p><p>于是可以反复使 <span class="math inline">\(j \gets P_j\)</span> 直到<span class="math inline">\(S(1,j+1)\)</span> 成为 <spanclass="math inline">\(S(1,i)\)</span> 的合法 border。</p><p>细节见代码实现。代码实现中认为下标从 <spanclass="math inline">\(0\)</span> 开始，<code>nxt</code> 数组即为 <spanclass="math inline">\(P\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">(string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; str[i - <span class="number">1</span>] != str[j]) </span><br><span class="line">            j = nxt[j];  <span class="comment">// 如果 border 不合法就跳，直到没 border 为止</span></span><br><span class="line">        <span class="keyword">if</span> (str[i - <span class="number">1</span>] == str[j]) </span><br><span class="line">            ++j;  <span class="comment">/* 实际上上面循环完之后的 j 可能是合法 border</span></span><br><span class="line"><span class="comment">                   的结尾也有可能是无解（0），同时如果 border 合</span></span><br><span class="line"><span class="comment">                   法，需要 +1（因为跳 border 的时候跳的是之前的</span></span><br><span class="line"><span class="comment">                   border）*/</span></span><br><span class="line">        </span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒得证明是线性的了。</p><h2 id="kmp-字符串匹配算法">KMP 字符串匹配算法</h2><p>总的来说：借助前缀函数实现时空复杂度均为 <spanclass="math inline">\(\operatorname{O}(n+m)\)</span> 的字符串匹配。</p><p>过程和上面递推前缀函数差不多。</p><p>具体来讲，为什么要借助前缀函数呢？</p><p>假设我们有一个文本串 <spanclass="math inline">\(S\)</span>，一个模式串 <spanclass="math inline">\(T\)</span>，接下来需要找出 <spanclass="math inline">\(S\)</span> 中 <spanclass="math inline">\(T\)</span> 出现的所有位置。一旦到 <spanclass="math inline">\(T\)</span> 的 <spanclass="math inline">\(i\)</span> 这个位置匹配失败，我们难道一定就要返回<span class="math inline">\(T_1\)</span> 从头匹配吗？</p><p>并不是，我们可以利用 <span class="math inline">\(T(1,i)\)</span> 的border 来减少匹配次数。border 的定义是“相等的前缀和后缀”，那 <spanclass="math inline">\(T(1,i)\)</span>的这个后缀匹配成功，其对应的前缀也一定能匹配成功，只需要从这个前缀结束的位置继续匹配即可。</p><p>做了个动画： <div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64cd02b21ddac507cc33adee" fancybox="true"/></div></div></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != t[j])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>()) <span class="comment">// 匹配成功</span></span><br><span class="line">        cout &lt;&lt; i - (<span class="type">int</span>)t.<span class="built_in">size</span>() + <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 答案要求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>border 在能不能包含原串这方面没有权威定义，实际上 border这个概念就只是有一部分人在用，仅用于理解。<a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">这玩意实际上比 AC 自动机简单。</summary>
    
    
    
    <category term="字符串" scheme="http://blog.tibrella.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="KMP" scheme="http://blog.tibrella.top/tags/KMP/"/>
    
    <category term="exKMP" scheme="http://blog.tibrella.top/tags/exKMP/"/>
    
  </entry>
  
  <entry>
    <title>二项式反演</title>
    <link href="http://blog.tibrella.top/post/binomial-inversion/"/>
    <id>http://blog.tibrella.top/post/binomial-inversion/</id>
    <published>2023-07-21T04:55:23.000Z</published>
    <updated>2023-08-19T03:09:16.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义">定义</h2><p>直接给出式子：</p><p><span class="math display">\[g_i=\sum_{k\geqslant i}\binom ki f_k \rightarrow f_i=\sum_{k\geqslanti}\binom ki (-1)^{k-i}g_k\]</span></p><p>看起来不知道咋用？待会再说，我们先证明。</p><h2 id="证明">证明</h2><h3 id="前置知识">前置知识</h3><p><a href="/post/basic-combinatorics#常用记号">组合数学常用记号</a></p><p><a href="/post/basic-combinatorics#二项式定理">二项式定理</a></p><h3 id="正文">正文</h3><p>已知：<span class="math inline">\(g_i=\sum_{k\geqslant i}\binom kif_k\)</span><br />求证：<span class="math inline">\(f_i=\sum_{k\geqslant i}\binom ki(-1)^{k-i}g_k\)</span></p><p>把求证右边那个式子单独拿出来，想办法把它导成 <spanclass="math inline">\(f_i\)</span>。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{k\geqslant i}\binom ki (-1)^{k-i}g_k \newline=&amp;\sum_{k\geqslant i}\binom ki (-1)^{k-i} \sum_{j\geqslant k}\binomjk f_j\end{aligned}\]</span></p><p>把第二个求和号以及 <span class="math inline">\(f_j\)</span>挪动一下，感性理解一下，发现最后每一项出现的次数还是不变的，所以正确。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{k\geqslant i}\binom ki (-1)^{k-i} \sum_{j\geqslant k}\binomjk f_j \newline=&amp;\sum_{j\geqslant i}f_j \sum_{j\geqslant k \geqslant i}\binom jk\binom ki (-1)^{k-i} \newline=&amp;\sum_{j\geqslant i}f_j \sum_{j\geqslant k \geqslanti}\frac{j!k!}{k!(j-k)!i!(k-i)!} (-1)^{k-i} \newline=&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!}\sum_{j\geqslant k \geqslanti}\frac 1{(j-k)!(k-i)!} (-1)^{k-i}\end{aligned}\]</span></p><p>展开之后不知道怎么往下算了，想办法把那个大分式化成点什么，比如二项式（组合数）。</p><p>上下同乘 <span class="math inline">\((j-i)!\)</span>，然后 <spanclass="math inline">\((j-k)=[(j-i)-(k-i)]\)</span>，然后就可以轻松化成组合数形式继续往下导公式了。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \sum_{j\geqslant k \geqslanti}\frac 1{(j-k)!(k-i)!} (-1)^{k-i} \newline=&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \sum_{j\geqslant k \geqslanti}\frac {(j-i)!}{[(j-i)-(k-i)]!(k-i)!(j-i)!} (-1)^{k-i} \newline=&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \sum_{j\geqslant k \geqslanti}\frac {\binom{j-i}{k-i}}{(j-i)!} (-1)^{k-i} \newline\end{aligned}\]</span></p><p>换个形式</p><p><span class="math display">\[\sum_{j\geqslant i}f_j\frac{j!}{i!} \cdot \frac{\sum_{j\geqslant k\geqslant i } \binom{j-i}{k-i} (-1)^{k-i}}{(j-i)!}\]</span></p><p>大分式上面的分母可以用 <ahref="/post/basic-combinatorics#二项式定理">二项式定理</a>处理掉。想不出来可以直接看下面式子。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \cdot \frac{\sum_{j\geqslant k\geqslant i } \binom{j-i}{k-i} (-1)^{k-i}}{(j-i)!} \newline=&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \cdot\frac{(1-1)^{j-i}}{(j-i)!}\end{aligned}\]</span></p><p>右下方的分母和左侧分数扔一起是一个非常典型的组合数。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{j\geqslant i}f_j\frac{j!}{i!} \cdot\frac{(1-1)^{j-i}}{(j-i)!} \newline=&amp;\sum_{j\geqslant i}f_j\binom ji 0^{j-i}\end{aligned}\]</span></p><p>注意，在组合数学中，<spanclass="math inline">\(0^0=1\)</span>。<br />于是很容易地发现，求和号右边的式子值非零，当且仅当 <spanclass="math inline">\(i=j\)</span>。</p><p>于是就出来了：</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{j\geqslant i}f_j\binom ji 0^{j-i}\newline=&amp;f_i\binom ii 0^0 \newline=&amp;f_i\end{aligned}\]</span></p><p>证毕。</p><h2 id="例题">例题</h2><h3 id="分特产">分特产</h3><p><a href="https://www.luogu.com.cn/problem/P5505">题目链接</a></p><h4 id="题意">题意</h4><p><span class="math inline">\(m\)</span> 种特产，<spanclass="math inline">\(n\)</span> 个人，每种特产 <spanclass="math inline">\(s_i\)</span> 个。</p><p>人有标号，两个特产相同当且仅当其种类相同。</p><p>求让每个人都拿到至少一份特产的分配方案总数，答案对 <spanclass="math inline">\(10^9+7\)</span> 取模。</p><h4 id="题解">题解</h4><p>首先，记住开头给你的式子。</p><p>然后把下面的东西看一遍，这应该是二项式反演的基本套路。</p><p>大体上设两个东西，<span class="math inline">\(g_i\)</span> 和 <spanclass="math inline">\(f_i\)</span>。这里设 <spanclass="math inline">\(g_i\)</span> 为<strong>钦定</strong> <spanclass="math inline">\(i\)</span>个人不满足要求（即没有特产），其他人随意分配（可能也没有）的方案数，然后<span class="math inline">\(f_i\)</span> 为<strong>恰好</strong> <spanclass="math inline">\(i\)</span>个人没有特产，其他人都有特产的方案总数。</p><p>然后模仿条件式，用 <span class="math inline">\(f_i\)</span> 表示<span class="math inline">\(g_i\)</span>。</p><p>容易发现：</p><ol type="1"><li>对于 <span class="math inline">\(g_i\)</span>，每一个 <spanclass="math inline">\(f_j,j\in [i,n]\)</span> 都一定被包含在里面。</li><li>对于每一个包含在里面的 <spanclass="math inline">\(f_j\)</span>，被钦定的集合会不同，一共有 <spanclass="math inline">\(\binom ji\)</span> 个，所以每个 <spanclass="math inline">\(f_j\)</span> 被算了 <spanclass="math inline">\(\binom ji\)</span> 次。</li></ol><p>综上，<span class="math inline">\(g_i = \sum_{j=i}^n \binom jif_j\)</span>。</p><p>二项式反演的常见入手点就是设 <spanclass="math inline">\(g,f\)</span>。其中 <spanclass="math inline">\(g_i\)</span> 表示钦定集合中 <spanclass="math inline">\(i\)</span> 个元素满足/不满足要求，其他不管；<spanclass="math inline">\(f_i\)</span> 表示集合中恰好 <spanclass="math inline">\(i\)</span> 个元素满足/不满足要求（是否满足与 <spanclass="math inline">\(g\)</span> 一致）。在此之后用 <spanclass="math inline">\(f_i\)</span> 表示 <spanclass="math inline">\(g_i\)</span>，二项式反演之后问题就变化成了求 <spanclass="math inline">\(g\)</span>。</p><p>然后大力二项式反演，套一下式子就能得出来：</p><p><span class="math display">\[f_i = \sum_{j=i}^n \binom ji g_j (-1)^{j-i}\]</span></p><p>答案就是恰好没有不合法元素的方案总数，于是：</p><p><span class="math display">\[\begin{aligned}ans &amp;= f_0 \newline&amp;= \sum_{j=0}^n \binom j0 g_j (-1)^{j-0} \newline&amp;= \sum_{j=0}^n g_j (-1)^j\end{aligned}\]</span></p><p>问题被转化成了求 <span class="math inline">\(g\)</span>。</p><p>假设目前正在求 <span class="math inline">\(g_i\)</span>，显然只需要有<span class="math inline">\(n-i\)</span> 个人需要考虑。由于剩下 <spanclass="math inline">\(i-1\)</span>是钦定不合法的，我们不用考虑；但是非常魔法的事情来了：由于这 <spanclass="math inline">\(n-i\)</span>个人是随便排列的，我们只需要把特产随意分发就行。</p><p>怎么个随意分发法？对于每一种特产 <spanclass="math inline">\(x\)</span>，可以转化为：有 <spanclass="math inline">\(s_x\)</span> 个无标号小球，装进 <spanclass="math inline">\(n-i\)</span>个有标号盒子里的方案数。直接插板法解决就好啦！显然有 <spanclass="math inline">\(s_x-1\)</span>个空，除此以外，盒子可以为空，所以就是 <spanclass="math inline">\(s_x-1\)</span> 加 <spanclass="math inline">\(n-i\)</span> 个空，插 <spanclass="math inline">\(n-i-1\)</span> 个板的方案数，即 <spanclass="math inline">\(\binom{s_x-1+n-i}{n-i-1}\)</span>。</p><p>每一种特产的分配方案数互不影响，所以乘起来；同时 <spanclass="math inline">\(n\)</span> 个人里面选出来 <spanclass="math inline">\(i\)</span> 个钦定不合法，再乘一个 <spanclass="math inline">\(\binom ni\)</span>，即：</p><p><span class="math display">\[g_i = \binom ni \prod_{j=1}^m \binom{s_x-1+n-i}{n-i-1}\]</span></p><p>然后代入上面计算答案的式子算就完了。</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> tkgs &#123;</span><br><span class="line">    <span class="keyword">using</span> i32 = <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> i64 mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 2005</span></span><br><span class="line">    <span class="keyword">namespace</span> mat &#123;</span><br><span class="line">        i64 x, y, tmp;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">const</span> i64&amp; a, <span class="type">const</span> i64&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">                x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">exgcd</span>(b, a % b);</span><br><span class="line">                tmp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = tmp - a / b * y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">i64 <span class="title">inv</span><span class="params">(<span class="type">const</span> i64&amp; a, <span class="type">const</span> i64&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">exgcd</span>(a, b);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i64 fact[NUM], ifact[NUM];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">const</span> i32 n = <span class="number">2000</span>;</span><br><span class="line">            fact[<span class="number">0</span>] = ifact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i32 i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">            ifact[n] = <span class="built_in">inv</span>(fact[n], mod);</span><br><span class="line">            <span class="keyword">for</span> (i32 i = n - <span class="number">1</span>; i; --i)</span><br><span class="line">                ifact[i] = ifact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">i64 <span class="title">getC</span><span class="params">(i32 a, i32 b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> fact[a] * ifact[b] % mod * ifact[a - b] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace mat 实现了初始化阶乘与阶乘逆元，求组合数</span></span><br><span class="line"></span><br><span class="line">    i32 s[N], n, m;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">g</span><span class="params">(i64 i)</span> </span>&#123;</span><br><span class="line">        i64 res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i32 j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            res = res * mat::<span class="built_in">getC</span>(s[j] + n - i - <span class="number">1</span>, n - i - <span class="number">1</span>) % mod;</span><br><span class="line">        res = res * mat::<span class="built_in">getC</span>(n, i) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (i32 i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            cin &gt;&gt; s[i];</span><br><span class="line">        mat::<span class="built_in">init</span>();</span><br><span class="line">        i64 ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i32 j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            (ans += <span class="built_in">g</span>(j) * ((j &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>)) %= mod;</span><br><span class="line">        cout &lt;&lt; (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace tkgs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tkgs::<span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc309g"><a href="/post/abc309g-solution">ABC309G</a></h3>]]></content>
    
    
    <summary type="html">炫酷二项式反演魔法。</summary>
    
    
    
    <category term="数学" scheme="http://blog.tibrella.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="组合数学" scheme="http://blog.tibrella.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥" scheme="http://blog.tibrella.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="二项式反演" scheme="http://blog.tibrella.top/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>ABC309G Ban Permutation 题解</title>
    <link href="http://blog.tibrella.top/post/abc309g-solution/"/>
    <id>http://blog.tibrella.top/post/abc309g-solution/</id>
    <published>2023-07-19T05:06:28.000Z</published>
    <updated>2023-08-17T11:28:45.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><ul><li>二项式反演（以后会补上笔记的！）</li><li>状压 DP</li></ul><h2 id="符号约定">符号约定</h2><p><span class="math inline">\(\lor\)</span> 为逻辑或，相当于 C++ 中的<code>|</code> 运算符。</p><h2 id="题意简化">题意简化</h2><p>求 <span class="math inline">\(n\)</span> 的排列 <spanclass="math inline">\(P\)</span> 的方案数，要求 <spanclass="math inline">\(\lvert P_i - i \rvert \geqslant X\)</span>。</p><h2 id="分析">分析</h2><p>排列问题有点抽象，于是有套路：把一个排列看成 <spanclass="math inline">\(n\times n\)</span> 的棋盘上放车的方案——数字 <spanclass="math inline">\(p_i\)</span> 在 <spanclass="math inline">\(i\)</span> 的位置上，相当于棋盘的 <spanclass="math inline">\((i,p_i)\)</span> 位置放了一个车。显然 <spanclass="math inline">\(i,p_i\)</span> 都不会重复，所以正确。</p><p>然后发现是个计数题，给出了<strong>不合法</strong>的条件，而且条件与位置相关，往二项式反演方向思考。</p><p>按照套路，设 <span class="math inline">\(g_i\)</span> 为钦定 <spanclass="math inline">\(i\)</span> 个数不合法，其他随便排的方案数，<spanclass="math inline">\(f_i\)</span> 为恰好 <spanclass="math inline">\(i\)</span> 个数不合法的方案数。发现每个 <spanclass="math inline">\(g_i\)</span> 包含 <spanclass="math inline">\(f_j,j\in[i,n]\)</span>，然后每次选择不同的 <spanclass="math inline">\(i\)</span> 个数进行钦定，所以一个 <spanclass="math inline">\(f_j\)</span> 要算 <spanclass="math inline">\(\binom ji\)</span> 次。于是有：</p><p><span class="math display">\[g_i=\sum_{j=i}^n f_i \binom ji\]</span></p><p>脸上都写上二项式反演这五个字了，套一下式子，有：</p><p><span class="math display">\[f_i = \sum_{j=i}^n(-1)^{j-i}\binom ji g_j\]</span></p><p>答案即为：</p><p><span class="math display">\[\begin{aligned}ans &amp;= f_0 \newline    &amp;= \sum_{j=0}^n(-1)^{j-0}\binom j0 g_j \newline    &amp;= \sum_{j=0}^n(-1)^j g_j\end{aligned}\]</span></p><p>考虑怎么求 <span class="math inline">\(g_i\)</span>。</p><p>回过头来看不合法的条件：<span class="math inline">\(\lvert P_i - i\rvert &lt; X\)</span>，转化为 <span class="math inline">\(P_i\)</span>这个棋子不能放在 <span class="math inline">\([i-X+1,i+X-1]\)</span>这些横行上。</p><p>发现 <span class="math inline">\(X\leqslant5\)</span>，非常小，也许可以状压？结合上面的转化，如果要状压的话，状态可以直接表示<span class="math inline">\([i-X+1,i+X-1]\)</span>中不合法棋子的集合。</p><p>然后 DP 状态设计就有了（这里我们开出来一个新的 <spanclass="math inline">\(f\)</span> 数组）：<spanclass="math inline">\(f_{i,j,s}\)</span> 表示棋盘前 <spanclass="math inline">\(i\)</span> 行，放了 <spanclass="math inline">\(j\)</span> 个不合法棋子，状态为 <spanclass="math inline">\(s\)</span> 的方案数量。</p><p>怎么转移？假设当前是 <spanclass="math inline">\(f_{i,j,s}\)</span>，然后分类讨论：</p><ul><li>不放新的不合法棋子。 发现这种情况下转移到 <spanclass="math inline">\(i+1\)</span> 时，新状态就是 <spanclass="math inline">\(s\)</span> 右移一位，即 <spanclass="math inline">\(2^{-1}s\)</span>。 为了方便，我们设这个状态为<span class="math inline">\(ns\)</span>，表示什么都不放时转移到 <spanclass="math inline">\(i+1\)</span> 时的状态。 转移方程也就简单了：<spanclass="math inline">\(f_{i,j,ns} \gets(f_{i,j,ns}+f_{i,j,s})\)</span></li><li>放新的不合法棋子。 可以枚举一下这个不合法棋子能放到的位置（就是<span class="math inline">\([i-X+1,i+X-1]\)</span>区间的空位），直接转移即可。但是注意，当前要做的是向后转移，所以应当枚举的是<span class="math inline">\(ns\)</span> 这个状态的空位。假设 <spanclass="math inline">\(p\)</span> 是一个空位，则有转移方程：<spanclass="math inline">\(f_{i,j,(ns\lor 2^p)} \gets (f_{i,j,(ns\lor2^p)}+f_{i,j,s})\)</span>。</li></ul><p>对于 <span class="math inline">\(g_i\)</span>，由于是钦定了 <spanclass="math inline">\(i\)</span>个位置不合法，其他位置随便排，所以我们对 <spanclass="math inline">\(f_{n,i,s}\)</span> 枚举 <spanclass="math inline">\(s\)</span> 求和之后，还要乘一个 <spanclass="math inline">\((n-i)!\)</span> 满足“剩下位置随便排列”的要求。</p><p>按照前面 <span class="math inline">\(ans\)</span>的式子求和即可。</p><p>时间复杂度 <spanclass="math inline">\(\operatorname\Theta(4^Xn^2)\)</span>。</p><p>Code:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">valid</span>(pos: <span class="type">usize</span>, i: <span class="type">usize</span>, n: <span class="type">usize</span>, x: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    ((i + pos + <span class="number">1</span> - x) &lt;= n &amp;&amp; (i + pos + <span class="number">1</span> - x) &gt; <span class="number">0</span>) <span class="keyword">as</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> MD: <span class="type">usize</span> = <span class="number">998244353</span>;</span><br><span class="line">    <span class="keyword">const</span> N: <span class="type">usize</span> = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">const</span> ST: <span class="type">usize</span> = <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">usize</span> = s.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">usize</span> = s.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = [[[<span class="number">0</span>; ST]; N]; N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mxst</span>: <span class="type">usize</span> = (<span class="number">1</span> &lt;&lt; ((x &lt;&lt; <span class="number">1</span>) - <span class="number">2</span> + <span class="number">1</span>)) - <span class="number">1</span>; <span class="comment">// 区间长度本来是 (x &lt;&lt; 1) - 2，但是还要包含 i 本身，所以 + 1</span></span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=n &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..=i - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> <span class="number">0</span>..=mxst &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">ns</span>: <span class="type">usize</span> = s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                f[i][j][ns] = (f[i][j][ns] + f[i - <span class="number">1</span>][j][s]) % MD;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">p</span> <span class="keyword">in</span> <span class="number">0</span>..=(x &lt;&lt; <span class="number">1</span>) - <span class="number">2</span> &#123;</span><br><span class="line">                    <span class="title function_ invoke__">if</span> ((<span class="number">1</span> &lt;&lt; p) &amp; ns) == <span class="number">0</span> &amp;&amp; <span class="title function_ invoke__">valid</span>(p, i, n, x) &#123;</span><br><span class="line">                        f[i][j + <span class="number">1</span>][ns | (<span class="number">1</span> &lt;&lt; p)] =</span><br><span class="line">                            (f[i][j + <span class="number">1</span>][ns | (<span class="number">1</span> &lt;&lt; p)] + f[i - <span class="number">1</span>][j][s]) % MD</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fact</span> = [<span class="number">0</span>; N];</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=n &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % MD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ans</span>: <span class="type">i64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..=n &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> <span class="number">0</span>..=mxst &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">                ans -= (f[n][i][s] * fact[n - i] % MD) <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (f[n][i][s] * fact[n - i] % MD) <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans %= MD <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans % MD <span class="keyword">as</span> <span class="type">i64</span> + MD <span class="keyword">as</span> <span class="type">i64</span>) % MD <span class="keyword">as</span> <span class="type">i64</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">容斥大哥组合大哥我错了我滚出 OI</summary>
    
    
    <content src="https://pic.imgdb.cn/item/64b91bce1ddac507cc1f4492" type="image"/>
    
    
    <category term="题解" scheme="http://blog.tibrella.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="组合数学" scheme="http://blog.tibrella.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="容斥" scheme="http://blog.tibrella.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="二项式反演" scheme="http://blog.tibrella.top/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>AMD P-STATE 折腾历程</title>
    <link href="http://blog.tibrella.top/post/amd-p-state-honor/"/>
    <id>http://blog.tibrella.top/post/amd-p-state-honor/</id>
    <published>2023-06-19T22:00:34.000Z</published>
    <updated>2023-08-19T02:56:45.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><blockquote><p><code>amd-pstate</code> 是 AMD CPU 性能扩展驱动程序，它在 Linux内核的现代 AMD APU 和 CPU 系列上引入了新的 CPU频率控制机制。新机制基于协作处理器性能控制 (CPPC)，它提供比传统 ACPI硬件 P-States 更精细的频率管理。当前的 AMD CPU/APU 平台使用 ACPIP-states 驱动程序来管理 CPU 频率和时钟，仅在 3 个 P-states 中切换。 CPPC取代了 ACPI P-states 控件，并允许 Linux内核使用灵活、低延迟的接口直接将性能提示传达给硬件 （摘自 <ahref="https://www.kernel.org/doc/html/latest/admin-guide/pm/amd-pstate.html#:~:text=amd-pstate%20is%20the%20AMD%20CPU%20performance%20scaling%20driver,grain%20frequency%20management%20than%20legacy%20ACPI%20hardware%20P-States.">KernelDocs</a>）</p></blockquote><h2 id="折腾">折腾</h2><p>这玩意支持 AMD ZEN 2 和更新版本，我的荣耀本使用R7-4800H，理论上可以跑，于是按照 <ahref="https://note.ay1.us/#/15-amd-cpufreq">Aya 的博客</a>添加了内核参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">zfs <span class="built_in">set</span> org.zfsbootmenu:commandline=<span class="string">&quot;rw amd_pstate=passive&quot;</span> zroot/ROOT</span></span><br></pre></td></tr></table></figure><p>然后就没管了。</p><p>有一天忘记从哪里又看见了 AMDP-State，然后发现一个验证方法，跑了一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver</span><br><span class="line"></span><br><span class="line">acpi-cpufreq</span><br></pre></td></tr></table></figure><p>我去，这我可忍不了。于是我先检查内核 module 有没有 AMD P-State存在，结果是没有。但是检查内核 config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ zcat /proc/config.gz | grep PSTATE</span><br><span class="line"></span><br><span class="line">CONFIG_X86_AMD_PSTATE=y</span><br></pre></td></tr></table></figure><p>那得了，这玩意都 built-in 了咋可能不存在？于是检查日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl -b 0 | grep pstate</span><br></pre></td></tr></table></figure><p><del>经过群友提醒，我使用翻译发现第一次设置的 passive可能出了些幽灵字符导致无法识别，再设置一次才出现了根本问题</del></p><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_CPC object is not present in SBIOS</span><br></pre></td></tr></table></figure><p>哈哈荣耀操你妈的，这问题不就一眼顶针了？傻逼厂商的傻逼主板又没有把CPPC 的选项留给我自己设置捏。</p><p>tg 群里：<br />我：好像是硬件的问题，傻逼荣耀。<br />群友：试试 <ahref="https://github.com/DavidS95/Smokeless_UMAF">Smokeless_UMAF</a>？discussion里有 CPPC 相关的东西。</p><p>随后我想起来当时用 Smokeless_UMAF 把傻逼荣耀设置的 512M 显存干到 4G的过程，心想这玩意也能设置？事实上，是的。</p><p>我手上有一个现成的 ventoy 盘，于是直接拿来使用，扔进去 <ahref="https://github.com/mio-19/UniversalAMDFormBrowser-Ventoy">为ventoy 提前制作好的 img 镜像</a> 就能启动了。</p><p>另外提醒一句，UMAF基于一个漏洞，这个漏洞貌似联想在去年三月份就修复了，所以不一定能正常启动。蛤蛤，但是傻逼荣耀已经三年没更新过任何驱动了，所以我怕个吊，直接开干。<br />同时，这玩意不开源，恶意代码存在可能性待议，但是利用漏洞 Hack主板设置肯定有变砖的风险存在。因此 USE AT YOUR OWNRISK。有条件的建议备份一下BIOS（有刷写工具的情况下），或者直接买<del>六七个</del> BIOS芯片，坏了直接换上。</p><p>但是我电脑太冷门了，没有卖的，手上还没有刷写工具，但是保修期内，大不了送回去修，我还有机房电脑可以用。</p><p>按照 <ahref="https://github.com/DavidS95/Smokeless_UMAF/discussions/29#discussioncomment-6143331">discussion#29</a> 的做法，进入 Device Manager - AMD CBS - NBIO - SMU page，启用CPPC，直接一路 esc 出来，它会提醒你选择是否保存，保存后会直接重启。</p><p>再次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver</span><br><span class="line"></span><br><span class="line">amd-pstate</span><br></pre></td></tr></table></figure><p>就这样，没了，感谢阅读。</p>]]></content>
    
    
    <summary type="html">AMD 的一个频率控制工具</summary>
    
    
    <content src="https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg" type="image"/>
    
    
    <category term="Linux" scheme="http://blog.tibrella.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://blog.tibrella.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AC 自动机</title>
    <link href="http://blog.tibrella.top/post/ac-automaton/"/>
    <id>http://blog.tibrella.top/post/ac-automaton/</id>
    <published>2023-06-06T19:43:04.000Z</published>
    <updated>2023-08-19T02:55:30.575Z</updated>
    
    <content type="html"><![CDATA[<p>真的比 KMP 简单！（指好理解）</p><h2 id="前置知识">前置知识</h2><p>trie 树（必会）<br />KMP（知道一点思想就行，不用详细学习）</p><h2 id="用途">用途</h2><p>我们知道 KMP 能够 <spanclass="math inline">\(\operatorname{O}(|T|+|S|)\)</span> 匹配单个文本串<span class="math inline">\(T\)</span> 与模式串 <spanclass="math inline">\(S\)</span>。但是如果有 <spanclass="math inline">\(n \leq 10^5\)</span>个模式串（小串）匹配一个文本串（大串）呢？AC 自动机能够在 <spanclass="math inline">\(\operatorname{O}(|T|+\sum |S|)\)</span>的复杂度内求出每一个模式串的出现次数。</p><p>核心思想和 KMP相似，除去多余的匹配，即在当前匹配状态的基础上转移着匹配。（我也不知道我说了啥）</p><h2 id="基本结构">基本结构</h2><p>多个模式串，先去重前缀，建立前缀树（即 trie 树）。假设我们当前有四个模式串：<spanclass="math inline">\(\texttt{abc,ac,bc,bd}\)</span></p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64813e2a1ddac507cc19c8df" fancybox="true"/></div></div><p>对每个模式串终止字符记录其出现的次数作为其在 trie树上对应节点的权值，然后遍历文本串的每一个字符，在 trie树上向下走，<span class="math inline">\(ans\)</span>加上当前点的权值，如果走不了了就把文本串的当前指针回跳到上一个有多个子节点的节点，从trie树根节点继续匹配。（当然这个不重要，理解不理解无所谓）（理解不了就自己匹配一下试试）</p><p>合并了一些模式串的前缀，于是有了一定优化，但是优化还不够，考虑对后缀优化。</p><h2 id="fail-边">fail 边</h2><h3 id="含义">含义</h3><p>AC 自动机的核心就是 fail 边。</p><p>fail 边的含义：如果 <span class="math inline">\(u\)</span> 点的 fail边指向 <span class="math inline">\(v\)</span>，则 <spanclass="math inline">\(v\)</span> 点所代表的字符串<a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>是<span class="math inline">\(u\)</span>点所代表的字符串的后缀，且前者是除后者自身以外满足要求的最长字符串。</p><p>先不管怎样建 fail 边，按照要求人脑建立一下，如下图：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/648140721ddac507cc1d77e5" fancybox="true"/></div></div><p>然后假设有文本串 <spanclass="math inline">\(\texttt{abc}\)</span>，进行匹配。</p><p>为什么上一次匹配的时候，我们需要把文本串的指针回跳？因为没有办法除去后缀的影响——一个模式串是另一个模式串的后缀，或前者的一部分是后者的后缀。意味着：后者匹配失败不代表前者也会匹配失败。于是我们可以记录一下合法后缀，如果匹配失败就跳到自己最长后缀所在节点上（没有的话就跳根节点），容易发现这样一直跳下去，能把最开始的串的合法后缀全部跳完！说明后缀的影响已经排除掉了。</p><p>为了方便，我们把没有合法后缀的节点的 fail 边指向根节点。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/6481466b1ddac507cc291a6d" fancybox="true"/></div></div><p>实际上此时的 fail边的含义：无法向下一个子节点匹配（没有子节点或匹配失败）时要走的边。</p><p>动画演示：</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/64814ec31ddac507cc38599e" fancybox="true"/></div></div><h3 id="建立">建立</h3><p>BFS 的过程。</p><ol type="1"><li><p>第一层（根节点为第零层）的 fail 全部指向根节点<a href="#fn2"class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>，压入队列。</p></li><li><p>取出队头，遍历子节点，如果子节点存在，假设这个子节点代表字符<span class="math inline">\(c\)</span>，当前节点 fail 指针指向 <spanclass="math inline">\(lf\)</span>，<spanclass="math inline">\(lf\)</span> 的子节点集合为 <spanclass="math inline">\(son\)</span>，则将其 fail 指针指向 <spanclass="math inline">\(son_c\)</span>。</p></li></ol><p>没了。</p><h2 id="优化">优化</h2><p>我们一般把 trie 树的一个节点的儿子用长度为 26的数组存下，导致遍历子节点的时候会遍历到傻逼空节点。</p><p>对于当前节点的空子节点指针，可以直接指向当前 fail指针指向的节点的子节点集合中，对应的子节点。</p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;i32&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (i32 i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (trie[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(trie[<span class="number">0</span>].son[i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        i32 nod = q.<span class="built_in">front</span>(), lfail = trie[q.<span class="built_in">front</span>()].fail; <span class="comment">// 当前节点和当前节点的 fail 节点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i32 i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            i32&amp; to = trie[nod].son[i];</span><br><span class="line">            <span class="keyword">if</span> (to) &#123;</span><br><span class="line">                trie[to].fail = trie[lfail].son[i];</span><br><span class="line">                q.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                to = trie[lfail].son[i]; <span class="comment">// 节点为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><liid="fn1"><p>字典树上除根节点外的每一个节点到根的路径都代表一个字符串。<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>模拟一下会发现：如果 fail还按照正常情况定义来建的话会死循环。<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">这玩意比 KMP 简单多了。</summary>
    
    
    
    <category term="字符串" scheme="http://blog.tibrella.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="AC 自动机" scheme="http://blog.tibrella.top/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SPOJ 4060 题解</title>
    <link href="http://blog.tibrella.top/post/spoj-4060-solution/"/>
    <id>http://blog.tibrella.top/post/spoj-4060-solution/</id>
    <published>2023-05-30T01:25:03.000Z</published>
    <updated>2023-08-17T11:28:45.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>给定一定数量的石子，两个人抛硬币，抛到正面则拿走一颗石子，否则什么都不做。拿走最后一颗石子的人胜利。<br />已知石子数量，假设双方都采用最优方案，两个人分别抛到自己想要的那一面的概率分别为<span class="math inline">\(0.5 \leqslant q,p &lt; 1\)</span><del>这不唯物</del>，求先手的获胜概率。</p><h2 id="题解">题解</h2><p>要点：对概率的熟悉程度，对 DP的熟练程度，奇怪的缩小数据范围的方法</p><p>首先考虑直接硬算，发现希望掷得的面会变化，没法直接算，考虑 DP。</p><h3 id="设计状态">设计状态</h3><ul><li>表示出当前到达第几颗石子</li><li>表示出当前谁拿石子</li></ul><p>于是得到状态：<span class="math inline">\(f_{i,0/1}\)</span> 表示<span class="math inline">\(i\)</span> 个石子，第 <spanclass="math inline">\(1\)</span> 或第 <spanclass="math inline">\(2\)</span> 个人获胜的概率</p><p>显然 <span class="math inline">\(f_{0,0}\)</span> 和 <spanclass="math inline">\(f_{0,1}\)</span> 是两种确定结果，则概率分别为<span class="math inline">\(1,0\)</span>。于是考虑倒推。</p><p>看概率的取值，说明只要我们希望抛到一个面，抛到这个面概率就会更大。<br />由于很容易判断出当前状态下应该希望取得/不取得石子（通过前一个状态的概率大小），所以不用单独表示出希望取得/不取得石子。</p><p>状态是否可行？根据 lzp 大佬的教诲，我们需要判断该状态：</p><ul><li>是否能表示单独状态：显然可以，上面解释过了。</li><li>是否可递推：直觉是可以递推，但是需要列柿子看一下</li></ul><h3 id="转移方程">转移方程</h3><p>开始写柿子：<br />希望取得这颗石子（正面）：</p><p><span class="math display">\[\begin{aligned}f_{i,0} &amp;= f_{i-1,1}\cdot p + f_{i,1} \cdot (1-p)\newlinef_{i,1} &amp;= f_{i-1,0}\cdot q + f_{i,0} \cdot (1-q)\end {aligned}\]</span></p><p>发现这玩意没法递推，但是发现可以运用初中二元一次方程的思路，代入消元。</p><p><span class="math display">\[\begin{aligned}f_{i,0} &amp;= f_{i-1,1}\cdot p + f_{i,1} \cdot (1-p) \newlinef_{i,0} &amp;= f_{i-1,1} \cdot p + (f_{i-1,0}\cdot q + f_{i,0} \cdot(1-q))(1-p) \newlinef_{i,0} &amp;= f_{i-1,1} \cdot p + f_{i-1,0}\cdot (1-p)q + f_{i,0} \cdot(1-q)(1-p) \newline(1-(1-q)(1-p))f_{i,0} &amp;= f_{i-1,1} \cdot p + f_{i-1,0}\cdot (1-p)q\newlinef_{i,0} &amp;= \frac {p\cdot f_{i-1,1} + (1-p)q\cdotf_{i-1,0}}{1-(1-q)(1-p)}\end{aligned}\]</span></p><p>发现这玩意就可以递推了，再依照同样的方式能够列出 <spanclass="math inline">\(f_{i,1}\)</span>的转移方程和不希望取得这颗石子的两个转移方程。不再赘述过程（基本上和上面完全一样），给出柿子希望取得：</p><p><span class="math display">\[\begin{aligned}f_{i,0} &amp;= \frac {p\cdot f_{i-1,1} + (1-p)q\cdotf_{i-1,0}}{1-(1-q)(1-p)} \newlinef_{i,1} &amp;= \frac {q\cdot f_{i-1,0} + (1-q)p\cdotf_{i-1,1}}{1-(1-p)(1-q)}\end {aligned}\]</span></p><p>不希望取得：</p><p><span class="math display">\[\begin{aligned}f_{i,0} = \frac{p(1-q)\cdot f_{i-1,0} + (1-p)\cdot f_{i-1,1}}{1-qp}\newlinef_{i,1} = \frac{q(1-p)\cdot f_{i-1,1} + (1-q)\cdot f_{i-1,0}}{1-qp}\end{aligned}\]</span></p><p>对比一下容易发现：希望取得与不希望取得的转移方程中，区别仅仅是 <spanclass="math inline">\(p,(1-p)\)</span> 和 <spanclass="math inline">\(q,(1-q)\)</span>。于是，当取石子比不取石子优的时候，把<span class="math inline">\(p,q\)</span> 把 <spanclass="math inline">\(1\)</span> 减一下就行了。</p><p>于是 DP 部分解决，复杂度 <spanclass="math inline">\(\operatorname{O}(n)\)</span></p><h3 id="优化">优化</h3><p>但是题目中 <span class="math inline">\(n\)</span>的范围比较申必，<span class="math inline">\(n \leqslant10^9-1\)</span>，还有多测，显然过不了。怎么办？开始考虑减少递推次数</p><ul><li>“自身简化专业玄 —— lzp”矩阵快速幂之类的优化...不好评价，转移方程貌似有点巨大；单调队列或者斜率？已经线性了，这种方法貌似没啥用。</li><li>概率还可以考虑是否会出现<strong>趋于稳定</strong>的情况。可以打表测一下<del>（或者提交试一下）</del>，<del>试一下发现确实可以</del><br /><span class="math inline">\(n = \min(n,100)\)</span> 即可。</li></ul><h3 id="易错提示">易错提示</h3><ol type="1"><li>要确定好自己选择的是正推还是逆推。（从这个状态推到下一个状态还是从上一个状态推到当前状态），换句话说，注意<span class="math inline">\(i-1,i,i+1\)</span> 的区别。</li><li>要确定好自己递推使用的是哪一个柿子，不要写反（谁因为这个调了半天我不说</li></ol><h2 id="示例代码">示例代码</h2><p>不得不说 rust 某些方面比 C++严格，读入也比较麻烦，但是从另一方面来说非常人性化...</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">solution</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lis</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span>: <span class="type">usize</span> = lis.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span>: <span class="type">f64</span> = lis.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">q</span>: <span class="type">f64</span> = lis.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span>: [<span class="type">Vec</span>&lt;<span class="type">f64</span>&gt;; <span class="number">2</span>] = [<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(), <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="comment">// 推到第 100 个石子就够了</span></span><br><span class="line">        n = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>].<span class="title function_ invoke__">push</span>(<span class="number">0.0</span>);</span><br><span class="line">    f[<span class="number">1</span>].<span class="title function_ invoke__">push</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=n &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">pnow</span> = p;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">qnow</span> = q;</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>][i - <span class="number">1</span>] &gt; f[<span class="number">0</span>][i - <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="comment">// 如果上一颗石子不应当让自己取</span></span><br><span class="line">            <span class="comment">// 这里取不取等号无所谓</span></span><br><span class="line">            pnow = <span class="number">1.0</span> - p;</span><br><span class="line">            qnow = <span class="number">1.0</span> - q;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>].<span class="title function_ invoke__">push</span>(</span><br><span class="line">            (pnow * (<span class="number">1.0</span> - qnow) * f[<span class="number">0</span>][i - <span class="number">1</span>] + (<span class="number">1.0</span> - pnow) * f[<span class="number">1</span>][i - <span class="number">1</span>]) / (<span class="number">1.0</span> - pnow * qnow),</span><br><span class="line">        );</span><br><span class="line">        f[<span class="number">1</span>].<span class="title function_ invoke__">push</span>(</span><br><span class="line">            (qnow * (<span class="number">1.0</span> - pnow) * f[<span class="number">1</span>][i - <span class="number">1</span>] + (<span class="number">1.0</span> - qnow) * f[<span class="number">0</span>][i - <span class="number">1</span>]) / (<span class="number">1.0</span> - pnow * qnow),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f[<span class="number">0</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span>: <span class="type">i32</span> = s.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">while</span> t != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">solution</span>();</span><br><span class="line">        t -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;题意&lt;/h2&gt;
&lt;p&gt;给定一定数量的石子，两个人抛硬币，抛到正面则拿走一颗石子，否则什么都不做。拿走最后一颗石子的人胜利。&lt;br /&gt;
已知石子数量，假设双方都采用最优方案，两个人分别抛到自己想要的那一面的概率分别为
&lt;span class=&quot;mat</summary>
      
    
    
    <content src="https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg" type="image"/>
    
    
    <category term="题解" scheme="http://blog.tibrella.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="概率" scheme="http://blog.tibrella.top/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>概率杂题</title>
    <link href="http://blog.tibrella.top/post/probability-misc-questions/"/>
    <id>http://blog.tibrella.top/post/probability-misc-questions/</id>
    <published>2023-05-22T05:06:14.000Z</published>
    <updated>2023-05-23T01:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="p4562-jxoi2018游戏"><ahref="https://www.luogu.com.cn/problem/P4562">P4562[JXOI2018]游戏</a></h2><p>给定区间 <spanclass="math inline">\([l,r]\)</span>，每次选择一个未选择过的数，将这个数以及它的所有倍数标记，每一种方案全部标记所用次数记为<span class="math inline">\(t\)</span>，求所有可能 <spanclass="math inline">\(t\)</span> 的和。</p><p>首先想到每次将所有点标记的实质，就是将 <spanclass="math inline">\(\left[l,r\right]\)</span>中<strong>没有</strong>在<strong>此区间内</strong>的<strong>非自身的因数</strong>的数标记完。称这样的数为关键数，设关键数有<span class="math inline">\(k\)</span>个，则实际上标记次数就是<strong>最后一个关键数</strong>的位置。</p><p>最后一个关键数的位置...不沾头不沾尾，所以换个方向考虑——最后一个关键数的位置可以替换为<strong>它后面的非关键数的数量</strong>。</p><p>实际上，<span class="math inline">\(k\)</span>个关键数把整个区间分成了 <span class="math inline">\(k+1\)</span>份。设区间长度为 <spanclass="math inline">\(1\)</span>，则一个非关键数在最后一段区间上的期望就是<span class="math inline">\(\cfrac 1 {k+1}\)</span>（<spanclass="math inline">\(k+1\)</span>种情况，每种情况都在段区间上，只有一种情况在目标区间上），<spanclass="math inline">\(n-k\)</span> 个非关键点在最后一段区间上的期望就是<spanclass="math inline">\(\cfrac{n-k}{k+1}\)</span>。（注意这里概率到期望的转换，要想想为什么期望成了求解目标）</p><p>于是，最后一个点的位置的期望，即 <spanclass="math inline">\(t\)</span> 的期望为下式</p><p><span class="math display">\[\begin{aligned}&amp;\ \ \ \ \  n-\cfrac{n-k}{k+1} \newline&amp;= \cfrac{nk+n-n+k}{k+1} \newline&amp;= \cfrac{(n+1)k}{k+1}\end{aligned}\]</span></p><p>求所有可能的 <span class="math inline">\(t\)</span>的值的和，乘一个阶乘就好了。</p><p><span class="math display">\[\begin{aligned}&amp;\ \ \ \ \  \cfrac{(n+1)k}{k+1}n! \newline&amp;= \cfrac{k}{k+1}(n+1)!\end{aligned}\]</span></p><p>取模的话，求完阶乘 <span class="math inline">\(\times k\)</span>再乘个 <a href="/post/multi-inverse-element">逆元</a> 就行了。</p><h2 id="p4284-shoi2014-概率充电器"><ahref="https://www.luogu.com.cn/problem/P4284">P4284 [SHOI2014]概率充电器</a></h2><p>给定一棵树，每条边能导电的概率为 <spanclass="math inline">\(p_i\)</span>，每个点自己带电的概率为 <spanclass="math inline">\(q_i\)</span>，求带电点个数的期望。</p><p>根据期望的线性性，考虑求每个点有电的期望。因为只有 <spanclass="math inline">\(0,1\)</span> 两种情况，因此求概率就行了。</p><p>考虑单个点有电的情况：</p><ul><li>自己有电</li><li>儿子有电，和儿子连边导电</li><li>父亲有电，和父亲连边导电</li></ul><p>设 <span class="math inline">\(f_u\)</span> 为点 <spanclass="math inline">\(u\)</span> 带电的期望：</p><ul><li>第一种情况的概率就是 <spanclass="math inline">\(q_u\)</span>，所以直接 <spanclass="math inline">\(f_u = q_u\)</span> 就行。</li><li>第二种情况非常像树形 DP 的样子，容易想到从叶子节点向上推就行。<ul><li>考虑两个独立事件发生其中一件即可的概率： <spanclass="math inline">\(P(A+B)=P(A)+(1-P(A))P(B)\)</span>，即 <spanclass="math inline">\(A\)</span> 事件的概率 <spanclass="math inline">\(+\)</span> <span class="math inline">\((B\)</span>事件 <span class="math inline">\(+\)</span> <spanclass="math inline">\(A\)</span> 事件未发生 <spanclass="math inline">\()\)</span> 的概率。</li><li>进行 dfs，回溯的时候统计：<ul><li>设当前点为 <span class="math inline">\(u\)</span>，儿子为 <spanclass="math inline">\(v\)</span>，则有 <span class="math inline">\(f_u =f_u + (1-f_u)p_{u,v}f_v\)</span></li></ul></li></ul></li><li>第三种情况实际上也是树形 DP，只不过变成了正推，从 <spanclass="math inline">\(u\)</span> 计算对 <spanclass="math inline">\(v\)</span> 的贡献。<ul><li>假设当前到达 <span class="math inline">\(u\)</span>，且 <spanclass="math inline">\(f_u\)</span> 已经算好了，考虑如何把贡献传给 <spanclass="math inline">\(f_v\)</span>。</li><li>容易想到 <span class="math inline">\(u\)</span> 能贡献给 <spanclass="math inline">\(v\)</span> 电流的那部分概率，实际上是 <spanclass="math inline">\(f_u\)</span> 扔掉 <spanclass="math inline">\(v\)</span> 这棵子树的部分。</li><li>换句话说，贡献 <span class="math inline">\(=\)</span> <spanclass="math inline">\(u\)</span> 有电的概率 <spanclass="math inline">\(-\)</span> <span class="math inline">\(u\)</span>不考虑 <span class="math inline">\(v\)</span>的有电的概率，再乘边的概率之类的常数即可。</li><li>设 <span class="math inline">\(\langle u,v \rangle=e\)</span>，<spanclass="math inline">\(u\)</span> 不考虑 <spanclass="math inline">\(v\)</span> 的有电的概率为 <spanclass="math inline">\(g_u\)</span>，<spanclass="math inline">\(v\)</span> 只考虑下方来电有电的概率为 <spanclass="math inline">\(l_v\)</span>，有柿子： <spanclass="math display">\[\begin{aligned}f_u &amp;= g_u + l_vp_e(1-g_u) \newlinef_u &amp;= g_u + l_vp_e-l_vp_eg_u \newlinef_u - l_vp_e &amp;= g_u(1-l_vp_e) \newlineg_u &amp;= \cfrac {f_u-l_vp_e}{1-l_vp_e} \newlinef_u - g_u &amp;= f_u - \cfrac {f_u-l_vp_e}{1-l_vp_e}\end{aligned}\]</span></li><li>考虑完 <span class="math inline">\(u\)</span>有电的贡献，乘一下边的概率和 <span class="math inline">\(v\)</span>没电的概率就行了 <span class="math display">\[f_v = f_v + (1-f_v)\cdot p_e \cdot(f_u - \cfrac {f_u-l_vp_e}{1-l_vp_e})\]</span></li></ul></li></ul><p>柿子推完了，写两个 dfs 算答案即可。</p><h2 id="spoj-4060-kpgame">SPOJ 4060 KPGAME</h2><p><a href="https://www.spoj.com/problems/KPGAME/">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;p4562-jxoi2018游戏&quot;&gt;&lt;a
href=&quot;https://www.luogu.com.cn/problem/P4562&quot;&gt;P4562
[JXOI2018]游戏&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;给定区间 &lt;span
class=&quot;math inline&quot;</summary>
      
    
    
    <content src="https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg" type="image"/>
    
    
    <category term="题解" scheme="http://blog.tibrella.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="概率" scheme="http://blog.tibrella.top/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>最大流要点</title>
    <link href="http://blog.tibrella.top/post/ff-network-maxflow/"/>
    <id>http://blog.tibrella.top/post/ff-network-maxflow/</id>
    <published>2023-05-20T09:23:16.000Z</published>
    <updated>2023-08-16T14:09:01.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是最大流问题">什么是最大流问题</h2><p>总体是一张有向图，定一个源点，一个汇点。单位时间内源点能流出无限水，汇点能接受无限水。图中每条边相当于一个单位时间流量有限的管道。</p><p>最大流问题：单位时间内汇点最多能接收到多少水流？</p><h2 id="解法">解法</h2><p>考虑贪心去做：反复 dfs找到仍能流水的一条从源点到汇点的路径，路径中每个边的容量减去路径的最小容量（水管模型能流多少显然受最小容量限制吧...）。<br />但是好像不太对，有可能当前的一个流让它从另一个路径流出去更合适，借鉴反悔贪心的思想，我们可以给每条边加一条反向边。当一条边的容量被占据了<span class="math inline">\(f\)</span> 时，其容量减去 <spanclass="math inline">\(f\)</span>，然后给它的反向边加上 <spanclass="math inline">\(f\)</span>。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic.imgdb.cn/item/6496477d1ddac507cce1334e.jpg" fancybox="true"/></div></div><p>上面只是简单介绍了一下增广路的主要思想，下面是三种具体的求法。</p><p>OI 中网络流貌似不需要去管他的复杂度之类，尤其是最大流，卡 Dinic的题可能只有 HLPP 模板题那一道。</p><p>主要是感性理解，重点都在建模。</p><h3 id="ek">EK</h3><p>不会，上界 <spanclass="math inline">\(\operatorname{O}(nm^2)\)</span>，懒得学了</p><h3 id="dinic">Dinic</h3><p>推荐结合这个博客看：https://www.cnblogs.com/SYCstudio/p/7260613.html</p><p>继续上面的贪心想法</p><p>每一次 dfs 可能得遍历整张图，只找到 1 条增广路，感觉不太值。</p><p>考虑多路增广。</p><p>dfs 每次传入两个参数：当前点编号和流过来了多少流量</p><p>原来的 dfs 过程：</p><ol type="1"><li>判断当前是否到达汇点，如果到达汇点，返回当前流量。</li><li>否则枚举有流量的边，继续 dfs。</li><li>dfs 如果返回正数，说明找到一条增广路，返回。</li></ol><p>我们实际上可以在第 3 步找到增广路时不立即停止，而是将当前流量减去 dfs返回的流量，表示有这么多的水已经流出去了。然后继续枚举边，枚举完毕/当前流量减到0 则停止。</p><p>貌似会死循环，我们可以用 bfs 分层。每次 bfs从源点开始，只走有流量的边，一个点的深度为到源点的最短距离。如果图不连通，说明找不到增广路了。</p><p>如果图连通，则反复 dfs。向下一个点搜索的前提是下一个点的深度 -1等于当前点深度。</p><p>然后加一个当前弧优化：dfs可能反复到达同一个点，而这个点的某些边可能已经被增广过了。因此在第一次到达该点的过程中，可以把链式前向星的fir[nod]修改为当前增广过但是还可能继续增广的边——之前的边增广过，流量没跑完，说明走那条边已经找不到增广路了。</p><p>每次分层情况都不一样，所以开一个 cur 数组当 fir 数组用，每次分层将cur 数组的每个值都初始化成原 fir 数组的值。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    i64 u, v;</span><br><span class="line">    edge *nex, *opp;</span><br><span class="line">    i64 w;</span><br><span class="line">&#125; graph[M];</span><br><span class="line">edge* tot = graph;</span><br><span class="line">edge *fir[N], *cur[N];</span><br><span class="line">i64 depth[N];</span><br><span class="line">i64 n, m, s, t; <span class="comment">// 点数，边数，源点，汇点</span></span><br><span class="line">queue&lt;i64&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(i64 a, i64 b, i64 c)</span> </span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    tot-&gt;u = a;</span><br><span class="line">    tot-&gt;v = b;</span><br><span class="line">    tot-&gt;w = c;</span><br><span class="line">    tot-&gt;opp = tot + <span class="number">1</span>;</span><br><span class="line">    tot-&gt;nex = fir[a];</span><br><span class="line">    fir[a] = tot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向边</span></span><br><span class="line">    ++tot;</span><br><span class="line">    tot-&gt;u = b;</span><br><span class="line">    tot-&gt;v = a;</span><br><span class="line">    tot-&gt;w = <span class="number">0</span>;</span><br><span class="line">    tot-&gt;opp = tot - <span class="number">1</span>;</span><br><span class="line">    tot-&gt;nex = fir[b];</span><br><span class="line">    fir[b] = tot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// memset(depth, 0, sizeof depth);</span></span><br><span class="line">    cur[s] = fir[s];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        depth[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    depth[s] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        i64 idx = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (edge* e = fir[idx]; e; e = e-&gt;nex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;w &gt; <span class="number">0</span> &amp;&amp; !depth[e-&gt;v]) &#123;  <span class="comment">// 该边容量大于零且还没有被设置深度</span></span><br><span class="line">                depth[e-&gt;v] = depth[idx] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(e-&gt;v);</span><br><span class="line">                cur[e-&gt;v] = fir[e-&gt;v]; <span class="comment">// 当前弧优化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!depth[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">dfs</span><span class="params">(i64 nod, i64 val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nod == t) <span class="keyword">return</span> val;  <span class="comment">// 边界即到达汇点</span></span><br><span class="line"></span><br><span class="line">    i64 res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (edge* e = cur[nod]; e &amp;&amp; val; e = e-&gt;nex) &#123;</span><br><span class="line">        cur[nod] = e;</span><br><span class="line">        <span class="keyword">if</span> (depth[nod] + <span class="number">1</span> == depth[e-&gt;v] &amp;&amp; e-&gt;w) &#123;  <span class="comment">// 第一个条件判断分层图，第二个条件判断边的残量</span></span><br><span class="line">            i64 tmp = <span class="built_in">dfs</span>(e-&gt;v, <span class="built_in">min</span>(val, e-&gt;w));</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) &#123;  <span class="comment">// 找到增广路</span></span><br><span class="line">                e-&gt;w -= tmp;</span><br><span class="line">                e-&gt;opp-&gt;w += tmp;</span><br><span class="line">                res += tmp;</span><br><span class="line">                val -= tmp;</span><br><span class="line">                <span class="comment">// return res;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!tmp)</span><br><span class="line">                depth[e-&gt;v] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i64 res = <span class="number">0</span>;</span><br><span class="line">    i64 d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> () &#123;</span><br><span class="line">        <span class="keyword">while</span> (d = <span class="built_in">dfs</span>(s, (i64)LLONG_MAX)) &#123;</span><br><span class="line">            res += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isap">ISAP</h2><p>TODO<!-- Dinic 需要 bfs 和 dfs 好多次，有没有办法能够动态维护 dep 数组而不用再次 bfs 分层？ 回顾整个 dinic 过程，感性理解一下 dep 数组的变化，发现相当于除了源点以外的点在不断远离源点 --></p>]]></content>
    
    
    <summary type="html">增广路求最大流，但是拣重点写</summary>
    
    
    <content src="https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg" type="image"/>
    
    
    <category term="图论" scheme="http://blog.tibrella.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="网络流" scheme="http://blog.tibrella.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="http://blog.tibrella.top/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>配对堆基本介绍</title>
    <link href="http://blog.tibrella.top/post/pairing-heap/"/>
    <id>http://blog.tibrella.top/post/pairing-heap/</id>
    <published>2023-05-20T03:42:35.000Z</published>
    <updated>2023-08-19T03:38:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>飞快的可并堆</p><h2 id="时间复杂度">时间复杂度</h2><p>还没有完全严格的证明，但一般认为配对堆时间复杂度如下：<br />删除堆顶均摊 <span class="math inline">\(\operatorname{O}(\logn)\)</span><br />插入元素 <span class="math inline">\(\operatorname{O}(1)\)</span> 合并<span class="math inline">\(\operatorname{O}(1)\)</span></p><p>貌似这个可能比斐波那契堆快（</p><h2 id="节点存储">节点存储</h2><p>配对堆不是一个二叉树，一般采用“左儿子右兄弟”表示法，一个节点存储自己第一个儿子与右侧第一个兄弟。<br />有点抽象？实际上相当于每一个节点的儿子使用链表维护，然后该节点连着第一个子节点。<br /><div class="tag-plugin image"><div class="image-bg"><img src="https://pic1.imgdb.cn/item/64688453e03e90d874db5ef4.jpg" fancybox="true"/></div></div></p><p>代码就非常好写了<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">Node *child, *nex; <span class="comment">// 第一个儿子，下一个兄弟</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="合并两个堆">合并两个堆</h2><p>比较根节点大小，把根节点大的堆直接改成根节点小的堆根节点的儿子即可。<br />图示中还是使用树本身形态。</p><div class="tag-plugin image"><div class="image-bg"><img src="https://pic1.imgdb.cn/item/64688720e03e90d874def660.jpg" fancybox="true"/></div></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">meld</span><span class="params">(Node* x, Node* y)</span> </span>&#123;  <span class="comment">// 传入两个根节点</span></span><br><span class="line"><span class="keyword">if</span> (x == null) <span class="comment">// null 为空节点</span></span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y == null)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (x-&gt;val &lt; y-&gt;val) &#123; <span class="comment">// x 比 y 小，y 当 x 的儿子</span></span><br><span class="line">y-&gt;nex = x-&gt;child; <span class="comment">// 旧儿子是新儿子的兄弟</span></span><br><span class="line">x-&gt;child = y; <span class="comment">// 新儿子是第一个儿子</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x-&gt;nex = y-&gt;child;</span><br><span class="line">y-&gt;child = x;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点">插入新节点</h2><p>新建节点，然后当成两个堆合并即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">Node* y = <span class="built_in">new_node</span>(); <span class="comment">// 获取新节点</span></span><br><span class="line">y-&gt;val = x;</span><br><span class="line"><span class="keyword">if</span> (root == null) <span class="comment">// 当前堆为空的话，新节点为根</span></span><br><span class="line">root = y;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">root = <span class="built_in">meld</span>(root, y); <span class="comment">// 否则当成两个堆合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="弹出堆顶">弹出堆顶</h2><p>貌似要写完了，但是前面几个操作都没有对堆的性质进行维护，因此重头戏在这个部分...</p><p>删除根节点之后，遇到的是原来的子节点们组成的森林，想办法把它们合并到一起。<br />有了上面的合并操作，很容易想到将这些森林里的树一棵一棵合并的方法，但是这样时间复杂度就奔<span class="math inline">\(\operatorname{O}(n)\)</span>去了，因为每次删除根节点都只是单纯地把子节点比较一遍，非常缓慢。<br />于是说到了该数据结构名称的由来——“配对”。<br />我们把这个森林两两配对之后再合并成一个新堆，于是理想状态下，多次删除根结点，新根节点的子节点数量将为<span class="math inline">\(2\)</span>，均摊时间复杂度大约是 <spanclass="math inline">\(\operatorname{O}(\log n)\)</span> 的。</p><p>图示过程：<br /><div class="tag-plugin image"><div class="image-bg"><img src="https://pic1.imgdb.cn/item/64688db3e03e90d874e6d98a.jpg" fancybox="true"/></div></div></p><p>首先实现一个用于配对的函数。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">merges</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == null || x-&gt;nex == null) <span class="keyword">return</span> x;  <span class="comment">// x 为空或者 x 没有下一个兄弟节点</span></span><br><span class="line">Node* y = x-&gt;nex;                           <span class="comment">// y 是 x 的下一个兄弟</span></span><br><span class="line">Node* c = y-&gt;nex;                           <span class="comment">// c 是再下一个兄弟</span></span><br><span class="line">x-&gt;nex = y-&gt;nex = null;                     <span class="comment">// 拆散</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">meld</span>(<span class="built_in">merges</span>(c), <span class="built_in">meld</span>(x, y));         <span class="comment">// x 与 y 配对在一起，剩下的继续配对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后弹出堆顶的操作就很好写了。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* t = <span class="built_in">merges</span>(root-&gt;child);</span><br><span class="line"><span class="built_in">remove</span>(root);</span><br><span class="line">root = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模板">模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZ 2000006</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    i64 val;</span><br><span class="line">    Node *child, *nex;</span><br><span class="line">&#125; tree[__SIZ], *rubbish_bin[__SIZ]; <span class="comment">// 提早分配内存，new 太慢了</span></span><br><span class="line">Node *null = tree, *tot = tree;</span><br><span class="line">i64 bintop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pairing_heap</span> &#123;</span><br><span class="line">    Node* root;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* nod;</span><br><span class="line">        <span class="keyword">if</span> (bintop)</span><br><span class="line">            nod = rubbish_bin[bintop--]; <span class="comment">// 垃圾回收</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nod = ++tot;</span><br><span class="line">        nod-&gt;child = null;</span><br><span class="line">        nod-&gt;nex = null;</span><br><span class="line">        <span class="keyword">return</span> nod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        rubbish_bin[++bintop] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">meld</span><span class="params">(Node* x, Node* y)</span> </span>&#123;  <span class="comment">// 合并两个堆</span></span><br><span class="line">        <span class="keyword">if</span> (x == null)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y == null)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;val &lt; y-&gt;val) &#123;</span><br><span class="line">            y-&gt;nex = x-&gt;child;</span><br><span class="line">            x-&gt;child = y;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x-&gt;nex = y-&gt;child;</span><br><span class="line">            y-&gt;child = x;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">merges</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == null || x-&gt;nex == null) <span class="keyword">return</span> x;  <span class="comment">// x 为空或者 x 没有下一个兄弟节点</span></span><br><span class="line">        Node* y = x-&gt;nex;                           <span class="comment">// y 是 x 的下一个兄弟</span></span><br><span class="line">        Node* c = y-&gt;nex;                           <span class="comment">// c 是下一个兄弟</span></span><br><span class="line">        x-&gt;nex = y-&gt;nex = null;                     <span class="comment">// 拆散</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">meld</span>(<span class="built_in">merges</span>(c), <span class="built_in">meld</span>(x, y));         <span class="comment">// x 与 y 配对在一起，剩下的继续配对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pairing_heap</span>() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(i64 x)</span> </span>&#123;</span><br><span class="line">        Node* y = <span class="built_in">new_node</span>();</span><br><span class="line">        y-&gt;val = x;</span><br><span class="line">        <span class="keyword">if</span> (root == null)</span><br><span class="line">            root = y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = <span class="built_in">meld</span>(root, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* t = <span class="built_in">merges</span>(root-&gt;child);</span><br><span class="line">        <span class="built_in">remove</span>(root);</span><br><span class="line">        root = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">配对堆，一种基于均摊复杂度的飞快的可并堆，写于 5.20</summary>
    
    
    
    <category term="数据结构" scheme="http://blog.tibrella.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://blog.tibrella.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="堆" scheme="http://blog.tibrella.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>面向新手的 Arch Linux 作为第二系统的安装指南</title>
    <link href="http://blog.tibrella.top/post/archlinux-install-guide/"/>
    <id>http://blog.tibrella.top/post/archlinux-install-guide/</id>
    <published>2023-05-13T12:42:41.000Z</published>
    <updated>2023-08-18T14:31:41.850Z</updated>
    
    <content type="html"><![CDATA[<p>长期坑，一点点来吧...</p><h2 id="为什么要使用-arch-linux">为什么要使用 Arch Linux</h2><p>众所周知，Ubuntu 是目前使用基本上最广的 Linux 操作系统，同时国内UOS、优麒麟此类都是 Ubuntu 魔改，那为什么不用它呢？<br />实际上，用的人多不代表他多牛逼，Windows用的人也非常多，但是不可否认的是它很烂。Ubuntu/Debian 系的 Linux发行版实际上正在脱离 Linux大部分发行版的“包管理器”的独特优势，在向着复杂和难以维护发展，这使我在Linux 使用的初期碰了很多次壁。<br />那 RedHat 系呢？Fedora 不也很好吗？它确实很好，但是我认为 Arch Linux更加符合 "KISS"的哲学，它更加简单，更加容易理解，更加友好。虽然它需要相对繁琐的命令行安装，但是它的稳定性要比大多数滚动更新发行版好，也比大多数桌面发行版容易维护。<br />总之，如上，Arch Linux易于维护，稳定性好，扩展性强，生态好，社区非常完善（可以说是拥有最完善的社区和维基），我认为它是非常适合用于Linux 入门的发行版。</p><h2 id="安装前的准备">安装前的准备</h2><h3 id="确保有网">确保有网</h3><p>如果你用的有线网那基本上没啥问题，但是无线网络记得要改成英文名称，要不然会乱码。而且安装过程中你是不能输入中文的。</p><h3 id="制作安装盘">制作安装盘</h3><p>需要你手里有一个 U 盘。<br />不需要 U 盘的安装方法有点困难，如果你不是新手请换一篇博客看....</p><p>先<a href="https://archlinux.org/download/">下载ISO</a>，在这个页面中 Ctrl + F 搜索China，从给出的几个中国镜像站中选一个下载。</p><p>需要下载的文件是 archlinux-xxxx.xx.xx-x86_64.iso，前面的 xxxx.xx.xx是镜像更新的日期。</p><p>两种方式制作安装盘： - 直接写入 U 盘：使用 Rufus 写即可。 - 借助Ventoy 启动镜像，把刚才下载的文件扔到已经做好的 Ventoy盘的目录里即可。</p><h3 id="分区">分区</h3><p>我猜你会分区了。</p><p>如果你不会的话，百度一下就好了。</p><p>分区不需要太大，如果你只是装着玩玩，可能 2-5 G就足够了。但是如果你想装桌面环境和各种软件，还是得 40 G以上，看你具体需求了。</p><p>Linux 可以读写 Windows 的 NTFS分区，所以不要担心资料无法读取的问题。</p><p>有 bitlocker 加密的记得下载一份密钥。</p><h3 id="bios-相关设置">BIOS 相关设置</h3><p>百度一下你的笔记本品牌+BIOS 进入方法，一般来说是 F1/F2/F12/DEL键的其中一个。</p><p>你需要关掉安全启动（secure boot），启用 UEFI（新笔记本都是默认UEFI，BIOS 安装方法不在本教程阐述范围之内）。</p><p>然后你需要调整启动顺序，把你的 U 盘调到最前面，这样重启之后就会进入你U 盘中提前刻录的 Arch Linux LiveCD 了。</p><h3 id="重启">重启</h3><p>重启后直接回车进入第一个选项即可，这是你会看见一个可以输入命令的界面，这样就是成功进入LiveCD 了。</p>]]></content>
    
    
    <summary type="html">看到洛谷上有个质量较差的安装教程，忍不了，自己写一个</summary>
    
    
    <content src="https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg" type="image"/>
    
    
    <category term="Linux" scheme="http://blog.tibrella.top/categories/Linux/"/>
    
    
    <category term="ArchLinux" scheme="http://blog.tibrella.top/tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>线性代数</title>
    <link href="http://blog.tibrella.top/post/basic-linear-algebra/"/>
    <id>http://blog.tibrella.top/post/basic-linear-algebra/</id>
    <published>2023-05-01T16:00:00.000Z</published>
    <updated>2023-08-17T11:27:03.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向量">向量</h2><blockquote><p>类比一维数组 —— zzz</p></blockquote><p>分为行向量与列向量。<br />行向量形如 <span class="math inline">\(\left[ 1,2,3\right]\)</span><br />列向量形如 <span class="math inline">\(\left[ \begin{array}{l} 1\newline 2 \newline 3\newline 4 \end{array} \right]\)</span><br />实际上高中 whk 里面的向量是二维向量，OI中用的向量大部分为多维向量，数组中每一个元素就是一维的坐标。<br />运算的前提很容易想到：同维度，也就是“数组”长度得一样长。</p><p>加法：分量分别相加 <spanclass="math inline">\([a,b,c]+[a,b,c]=[2a,2b,2c]\)</span><br />减法：加法逆运算。<br />数乘：把系数乘到分量上 <spanclass="math inline">\(3[a,b,c]=[3a,3b,3c]\)</span><br />数量积（内积/点乘）：分量分别相乘并相加，顾名思义，得到一个数值 <spanclass="math inline">\([a,b] \cdot [c,d] = ac+bd\)</span><br />向量积（外积/叉乘）：实际上没卵用，<del>所以我不会</del></p><h2 id="线性基">线性基</h2><p>线性代数中的定义：<span class="math inline">\(\mathbf V\)</span>中的极小线性无关向量集合 <span class="math inline">\(\{\mathbf a,\mathbfb,\mathbf c\dots \}\)</span> 能够表示出 <spanclass="math inline">\(\mathbf V\)</span> 中所有向量。<br />在 OI 中使用的线性基与上面定义略有不同：</p><h3 id="异或线性基">异或线性基</h3><p>给定一数列 <span class="math inline">\(a\)</span>，其线性基 <spanclass="math inline">\(s\)</span> 是满足以下性质的数列：</p><ol type="1"><li><span class="math inline">\(a\)</span> 中任意一个数都可以用 <spanclass="math inline">\(s\)</span> 中的数异或得到</li><li><span class="math inline">\(s\)</span> 中任意一些数异或和不为 <spanclass="math inline">\(0\)</span></li><li><span class="math inline">\(s\)</span>里面的数个数一定，并且在满足性质 <span class="math inline">\(1\)</span>的条件下数最少</li></ol><p>如果还是不能理解，别忘了线性基<strong>不一定</strong>是原数列的子集。</p>]]></content>
    
    
    <summary type="html">向量，矩阵，线性基</summary>
    
    
    
    <category term="数学" scheme="http://blog.tibrella.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="向量" scheme="http://blog.tibrella.top/tags/%E5%90%91%E9%87%8F/"/>
    
    <category term="线性代数" scheme="http://blog.tibrella.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="矩阵" scheme="http://blog.tibrella.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="线性基" scheme="http://blog.tibrella.top/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>概率论基础</title>
    <link href="http://blog.tibrella.top/post/basic-probability/"/>
    <id>http://blog.tibrella.top/post/basic-probability/</id>
    <published>2023-04-30T15:51:12.000Z</published>
    <updated>2023-08-17T11:28:45.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>事件运算 <span class="math inline">\(A+B:=A\cup B\)</span>，相当于或运算<br /><span class="math inline">\(AB:=A\cap B\)</span> ，同时发生</p><h2 id="条件概率">条件概率</h2><ul><li><p>条件概率：<span class="math inline">\(A\)</span> 发生的前提下<span class="math inline">\(B\)</span> 发生的概率，表示为 <spanclass="math inline">\(P(B\mid A):=\cfrac{P(AB)}{P(A)}\)</span></p></li><li><p>全概率公式：<span class="math inline">\(B\)</span> 依赖于一堆事件<span class="math inline">\(A_1\dots A_n\)</span> 的其中一个，则 <spanclass="math inline">\(P(B)=\sum^n_{i=1} P(A_i)P(B\midA_i)\)</span></p></li><li><p>贝叶斯公式：<span class="math inline">\(P(A\mid B) =\cfrac{P(B\mid A)P(A)}{P(B)}\)</span> 实际上就是一个条件概率的推导 <spanclass="math display">\[\begin{aligned}\frac{P(B\mid A)P(A)}{P(B)} &amp;= \cfrac{\cfrac{P(AB)}{P(A)}P(A)}{P(B)} \newline&amp;= \frac{P(AB)}{P(B)} \newline&amp;= P(A\mid B)\end{aligned}\]</span></p></li><li><p>若 <span class="math inline">\(P(AB) = P(A)P(B)\)</span> 则 <spanclass="math inline">\(A,B\)</span> 互为独立事件，于是 <spanclass="math inline">\(P(B\mid A) = P(B)\)</span></p></li></ul><h2 id="随机变量">随机变量</h2><p>只介绍离散型随机变量。</p><p>离散型随机变量 <span class="math inline">\(X\)</span>，可以理解为<span class="math inline">\(X\)</span>有有限种取值，且每个取值都有一个概率。换句话说，<spanclass="math inline">\(X\)</span>的取值是一个有限的集合，集合里面每一个值都有一个概率，<spanclass="math inline">\(X\)</span> 按照概率取值。</p><p>随机变量独立性：对于两个独立变量 <span class="math inline">\(XY\)</span>，有 <span class="math inline">\(P(X=x_i, Y=y_i) =P(X=x_i)P(Y=y_i)\)</span> （<span class="math inline">\(,\)</span>表示<strong>且</strong>）<br />倒过来也是正确的。</p><h2 id="期望">期望</h2><p>一个随机变量取值对概率的加权平均数。<br /><span class="math inline">\(E(X) = \sum_i x_ip_i\)</span>，<spanclass="math inline">\(x_i\)</span> 代表可能的取值，<spanclass="math inline">\(p_i\)</span> 代表取值对应的概率。</p><p>期望的线性性：<spanclass="math inline">\(E(aX+b)=aE(X)+b\)</span><br />我们可以设 <span class="math inline">\(X\)</span>的意义为均匀骰子可能掷出的点数，于是上面的东西就可以轻松感性理解了~</p><p>随机独立变量的乘积：<spanclass="math inline">\(E(XY)=E(X)E(Y)\)</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;事件运算 &lt;span class=&quot;math inline&quot;&gt;&#92;(A+B:=A&#92;cup B&#92;)&lt;/span&gt;
，相当于或运算&lt;br /&gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(AB:=A&#92;cap B&#92;)</summary>
      
    
    
    
    <category term="数学" scheme="http://blog.tibrella.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="概率" scheme="http://blog.tibrella.top/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>组合数学基础</title>
    <link href="http://blog.tibrella.top/post/basic-combinatorics/"/>
    <id>http://blog.tibrella.top/post/basic-combinatorics/</id>
    <published>2023-04-30T10:29:32.000Z</published>
    <updated>2023-07-16T22:29:04.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础排列组合">基础排列组合</h2><p><del>实际上主要还是组合</del></p><h3 id="常用记号">常用记号</h3><ul><li><span class="math inline">\(n \in \mathbb N,n!:= 1\times 2\times3\times \dots \times (n-1) \times n\)</span> 称为非负整数 <spanclass="math inline">\(n\)</span> 的阶乘，特殊地，<spanclass="math inline">\(0! =1\)</span>。</li><li><span class="math inline">\(n,m\in \mathbb N,n\geqslant m,\binom{n}{m}=\frac{n!}{m!(n-m)!} \text{ a.k.a } C^m_n\)</span> 表示<span class="math inline">\(n\)</span> 个数中无序地选 <spanclass="math inline">\(m\)</span> 个数的方案数。</li><li><span class="math inline">\(n,m\in \mathbb N,n\geqslant m, {n \brackm} \text{ a.k.a } s(n,m),s_u(n,m)\)</span>称作第一类无符号斯特林数，表示 <span class="math inline">\(n\)</span>个数中排成 <span class="math inline">\(m\)</span>个圆排列的方案数<del>不知道什么是圆排列</del></li><li><span class="math inline">\(n,m\in \mathbb N,n\geqslant m, {n \bracem} \text{ a.k.a } S(n,m)\)</span> 称作第二类斯特林数，即 <spanclass="math inline">\(n\)</span> 个两两不同的数分成 <spanclass="math inline">\(m\)</span> 个互不区分的非空集合的方案数</li></ul><h3 id="预处理组合数">预处理组合数</h3><h4 id="递推法">递推法</h4><p>组合数递推：<span class="math inline">\(\tbinom{n}{m} =\tbinom{n-1}{m-1} + \tbinom{n-1}{m}\)</span><br />证明：对于还需要选 <span class="math inline">\(j\)</span> 个，还剩 <spanclass="math inline">\(i\)</span>个没选的情况，则对于一个苹果来说，不选它的方案数为 <spanclass="math inline">\(\tbinom{i-1}{j}\)</span>，选它的方案数为 <spanclass="math inline">\(\tbinom{i-1}{j-1}\)</span>。</p><h4 id="阶乘法">阶乘法</h4><p>问题：给定 <span class="math inline">\(p\)</span> 与多组 <spanclass="math inline">\(a,b\)</span> ，求 <spanclass="math inline">\(\tbinom{a}{b} \bmod p\)</span>。</p><p>设 <span class="math inline">\(fact_i = i! \bmod p,infact_i =fact_i^{-1}\pmod p\)</span>，根据<ahref="/post/multi-inverse-element">逆元</a>的性质可得</p><p><span class="math display">\[\begin{aligned}\binom{a}{b} &amp;= \frac{a!}{b!(a-b)!}\newline&amp;= \frac{form_a \cdot inform_b}{(a-b)!}\newline&amp;= form_a \cdot inform_b \cdot inform_{a-b}\end{aligned}\]</span></p><h2 id="二项式定理">二项式定理</h2><p>二项式就是只有两个项的多项式，如 <spanclass="math inline">\(a+b\)</span></p><p>二项式定理如下：</p><p><span class="math display">\[(x+y)^n = \sum^n_{k=0} \binom nk x^{n-k}y^k\]</span></p><p>可以利用组合方法证明：<br />假设有 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\((x+y)\)</span>相乘，由多项式乘法的法则可以知道，对于 <spanclass="math inline">\(x^ky^{n-k}\)</span> 这一项来说（容易想到 <spanclass="math inline">\(x,y\)</span> 的指数和为 <spanclass="math inline">\(n\)</span>），它来自于 <spanclass="math inline">\(n\)</span> 个括号中的 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(x\)</span> 与剩下 <spanclass="math inline">\(n-k\)</span> 个括号中的 <spanclass="math inline">\(n-k\)</span> 个 <spanclass="math inline">\(y\)</span>，也就是说“<spanclass="math inline">\(n\)</span> 个括号中选 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(x\)</span> 的方案数”就是该项的系数，即 <spanclass="math inline">\(\binom nk\)</span>。</p><h2 id="卢卡斯定理">卢卡斯定理</h2><p>下方 <span class="math inline">\(p\)</span> 均为质数</p><p><span class="math display">\[\binom nm \bmod p = \binom { \lfloor n/p \rfloor } {\lfloor m/p \rfloor}\binom {n\bmod p}{m \bmod p}\bmod p\]</span></p><h3 id="引理">引理</h3><p><span class="math display">\[(a+b)^p \equiv a^p+b^p \pmod p\]</span></p><p>证明：考虑 <span class="math inline">\(\tbinom pk\)</span>，易得到<span class="math inline">\(\binom pk =\frac{p!}{n!(p-n)!}\)</span>，这玩意 <span class="math inline">\(\bmodp\)</span> 基本上是 <span class="math inline">\(0\)</span>，于是我们开始把它扔到上面 <a href="#二项式定理">二项式定理</a>里面想。<br />分两种情况</p><ul><li><span class="math inline">\(n \neq p\)</span> 且 <spanclass="math inline">\(n\neq1\)</span> 此时 <spanclass="math inline">\(p\)</span>没法被分母任何一个因数整除，因此一定会在值中被保留下来，则该式被 <spanclass="math inline">\(p\)</span> 整除</li><li><span class="math inline">\(n=p\)</span> 或 <spanclass="math inline">\(n=1\)</span> 容易得到此时该式值为 <spanclass="math inline">\(1\)</span></li></ul><p>于是我们就把二项式定理中的所有项讨论完了。</p><p><span class="math display">\[(x+y)^p = \binom p 0 x^p + \binom p1 x^{p-1}y^1 + \dots + \binom{p}{p-1}x^{p-(p-1)}y^{p-1} + \binom pp y^p\]</span></p><p>根据上面的讨论，左右两边的两项系数为 <spanclass="math inline">\(1\)</span>，其余被 <spanclass="math inline">\(p\)</span>整除，也就是被模掉了，于是最后剩下：</p><p><span class="math display">\[(x+y)^p=x^p+y^p\]</span></p><h3 id="证明">证明</h3><p><a href="#引理">引理</a>推导的过程中没有任何限制，于是我们可以把它用在多项式身上</p><p>考虑一个二项式 <span class="math inline">\((1+x)^n \bmodp\)</span>，设 <span class="math inline">\(n = kp+r\)</span>，则在 <spanclass="math inline">\(\bmod p\)</span> 意义下有：</p><p><span class="math display">\[\begin{aligned}(1+x)^n &amp;= (1+x)^{kp}(1+x)^r \newline&amp;= (1+x^p)^k(1+x)^r \newline&amp;= (1+x^p)^{\lfloor n/p \rfloor}(1+x)^{n\bmod p}\end{aligned}\]</span></p><p>用二项式定理拆开的话，可以观察一下这个式子的内部结构</p><p><span class="math display">\[(1+x)^n = \binom n0 x^1 + \binom{n}{1}x^2+\dots+\binom n{n-1}x^{n-1} +\binom nn x^n\]</span></p><p>现在我们的目标是求 <span class="math inline">\(\binomnm\)</span>，实际上在上面的式子里就是 <spanclass="math inline">\(x^m\)</span> 的系数。<br />想办法从前面推导出来的东西表示 <span class="math inline">\(x^m\)</span>的系数，这里采用类似的办法，把 <span class="math inline">\(m\)</span>拆开为 <span class="math inline">\(\lfloor m/p \rfloor p + (m \bmodp)\)</span>，于是目标转化为<strong>如何在最上面的式子中找到 <spanclass="math inline">\(x\)</span> 相乘表示出左侧的次数</strong>。<br />分开考虑贡献，<span class="math inline">\(\lfloor m/p \rfloor p\)</span>只能从 <span class="math inline">\((1+x^p)^{\lfloor n/p\rfloor}\)</span> 处得到贡献，因为这玩意显然是个 <spanclass="math inline">\(p\)</span> 的倍数，而另外半边式子中 <spanclass="math inline">\(n \bmod p\)</span> 绝对小于 <spanclass="math inline">\(p\)</span>。<br />于是我们也就考虑到了 <span class="math inline">\(m\bmod p\)</span>的贡献应当从 <span class="math inline">\(n \bmod p\)</span> 中来，因为<span class="math inline">\(\lfloor n/p \rfloor &gt; p\)</span>。<br />这样就找到了对 <span class="math inline">\(\binom nm\)</span>的总贡献，从 <span class="math inline">\(n \bmod p\)</span> 中选 <spanclass="math inline">\(m \bmod p\)</span> 个，另外半边同理，则为</p><p><span class="math display">\[\binom nm \bmod p = \binom { \lfloor n/p \rfloor } {\lfloor m/p \rfloor}\binom {n\bmod p}{m \bmod p}\bmod p\]</span></p>]]></content>
    
    
    <summary type="html">很享受这种讲了一上午然后知识从脑子里流过的感觉，无能为力。</summary>
    
    
    <content src="https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg" type="image"/>
    
    
    <category term="数学" scheme="http://blog.tibrella.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="组合数学" scheme="http://blog.tibrella.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
