[{"title":"ST Link v2 刷 GNUK 记录","path":"/post/st-link-2-gnuk/","content":"## 前言\n\n看到了[这篇文章](https://ulyc.github.io/2021/01/13/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8A/) 想搞 PGP 智能卡玩，但是 yubikey 死贵 ~~还涉及到某些傻逼政治问题~~ 于是就想找找有无开源实现什么的。\n\n然后就看见了 [smartcard 的制作教程](https://www.liuyusong.cn/2023/04/05/diy-smartgpg/)，可惜能找到的便宜 javacard 都是需要读卡器的。\n\n本来死心了，但是看见 [ST-link v2 刷 GNUK 教程](https://techie-s.work/posts/2021/04/homemade-gnuk/) 突然就想折腾了。项目由 $\\stackrel{\\textsf{Free Software Initiative of Japan}}{\\textsf{FSIJ}}$ 维护。\n\n这玩意比 yubikey 牛逼，支持最新的 x448 椭圆曲线加密算法（但是已经弃用 RSA 了）\n\n## 材料准备\n\n一般 ST-Link v2 及其仿品都只提供 SWDIO SWCLK 而无 RXD TXD 这种直接串口就能刷的口，所以最好再买个 ST-Link v2 当烧录器（买别的也行，主要是这个便宜），我买的是 PowerWriter Lite 2。~~本来想刷这个的，结果外壳都拆不开~~\n\n所以：\n\n- 一个烧录器（ST-Link v2）\n- 待烧录的 ST-Link v2（确保主控是 STM32F103C8T6 或 STM32F103CBT6，GD32F103 一般不会在仿品里出现，网上有[关于这款主控的刷写教程](https://blog.indexyz.me/diy-gnuk-token/)），购买踩坑这里有[^2]。\n- 四根杜邦线，有一端是公头用于连接待烧录的 ST-Link，另一端连接烧录器，公母视情况而定\n- 一台电脑\n\n我采用了 Arch Linux，其他系统编译固件的教程在这里有[^1]\n\n## 为啥主控要求是这两个版本\n\n首先 GNUK 支持 STM32F103 系列。\n\n然后 GNUK 需要 128KB 闪存容量。\n\n最后 STM32F103C8T6 和 STM32F103CBT6 用了一套东西，后者官方给定容量 128KB，前者虽然标了 64KB 但是实际上有 128KB 的空间可用。恰好，ST-Link 2 官方使用的主控就是前者。仿品中可能出现后者。\n\nGD32F103 能 pin2pin 替换 STM32F103 自然也能用。但是需要换烧录方式。\n\n## 编译固件\n\n### 安装依赖\n\n```shell\npacman -S arm-none-eabi-gcc\n```\n\n官网：In 2.5, we added GD32VF103 support. Please note that default libc is now picolibc (instead of newlib).\n\n老教程会教你安装 newlib，但是现在需要安装 picolibc。但是这个东西不仅只在 aur 里，而且过期了。实测直接更改 pkgver 也可以正常构建[新版本](https://github.com/picolibc/picolibc/releases)。\n\n所以：\n\n```shell\ngit clone https://aur.archlinux.org/arm-none-eabi-picolibc.git\ncd arm-none-eabi-picolibc.git\nvim PKGBUILD # 将 pkgver 改成最新版本号，可以在上面 picolibc 项目 release 页面看\nmakepkg -sif\n```\n\n### 编译固件\n\n```shell\ngit clone --recursive https://salsa.debian.org/gnuk-team/gnuk/gnuk.git gnuk\ncd gnuk/src\n./configure --vidpid=234b:0000 --target=ST_DONGLE\nmake build/gnuk-vidpid.bin\n```\n\n然后 `build/gnuk-vidpid.bin` 就是待烧录的固件文件，我们把它单独取出来待用。\n\n## 烧写\n\n### 安装软件\n\n```shell\npacman -S openocd inetutils\n```\n\n`inetutils` 用来提供 `telnet` 支持。`putty` 用不了，不知道是不是不兼容 XWayland 的问题。\n\n### 连接设备\n\nST-Link v2 连接系统板教程挺多的，直接搜就行。这个里面也有[^1]。\n\nPW Lite 2 的话[官方文档](https://docs.powerwriter.com/docs/faq/powerwriter/base/connection/#2131%E8%AE%BE%E5%A4%87%E4%B8%BApwlink2%E6%88%96%E8%80%85pwlink2-lite)有接线教程。\n\n我的是这样\n\n![](https://pic.imgdb.cn/item/654b44b5c458853aef5f7a34.webp)\n\n如果像[^1]里面这样是非常好的，直接插进去随便固定一下就行。但是我不是这种情况。我买的 ST-Link 只提供了四个焊盘！！！\n\n![](https://pic.imgdb.cn/item/654b44afc458853aef5f6c93.webp)\n\n这意味着你需要用调试排针凑合连接一下，连接刷写过程中需要用手按住！调试排针...就是四根杜邦线粘成一排 😋\n\n![](https://pic.imgdb.cn/item/654b44a5c458853aef5f56c7.webp)\n\n![](https://pic.imgdb.cn/item/654b44bac458853aef5f8470.webp)\n\n连接失败了好几次，刷写完了之后杜邦线的头都让我按歪了！\n\n![](https://pic.imgdb.cn/item/654b44aac458853aef5f60e5.webp)\n\n### 配置 openocd\n\n随便新建一个 `xxx.cfg`，内容：\n\n```\ntelnet_port 4444\nsource [find interface/stlink-v2.cfg]\nsource [find target/stm32f1x.cfg]\nset WORKAREASIZE 0x10000\n```\n\nSTM32F103C8T6 需要这句 `set WORKAREASIZE 0x10000`，这句使得程序可以刷写到额外的 64KB 空间中。如果存储足够 128KB 就不用这句。\n\n如果你像我一样用 PWLink 2，需要把 `source [find interface/stlink-v2.cfg]` 换成 `source [find interface/cmsis-dap.cfg]`（在一个求助帖看见的，地址找不到了）\n\n连接好设备后 `openocd -f ./xxx.cfg`，如果跑起来之后没报错没退出就说明你搞对了。\n\n### 刷写固件\n\n```shell\ntelnet 127.0.0.1:4444\n```\n\n然后输入以下指令\n\n```\nstm32f1x unlock 0\nreset halt\nflash write_bank 0 ./src/build/gnuk-vidpid.bin 0\nstm32f1x lock 0\nreset halt\n```\n\n`./src/build/gnuk-vidpid.bin` 这个是你刚才编译出来的固件\n\n然后就没了，退出 telnet 和 openocd，断开设备连接就行。\n\n## 测试\n\n插入你刷好的 GNUK 智能卡，输入\n\n```shell\ngpg --card-status\n```\n\n此时应该输出你的智能卡的详细信息。\n\n![image](https://pic.imgdb.cn/item/654b4e1cc458853aef7d4c1f.webp)\n\n## 刷坏了/想重刷\n\n看[^1]\n\n----\n\n以下文章我或多或少参考了一些，推荐阅读 [^1][^2][^3][^4]\n\n[这篇文章](https://blog.misaka4e21.science/gnuk-stm32f103-minimum-system/) 讲述了 64KB 主控如何刷支持 64KB 的旧版 GNUK\n\n[^1]: https://nx3d.org/gnuk-st-link-v2/\n[^2]: https://blog.dylanwu.space/2020/01/24/stm32-gnuk.html\n[^3]: https://kgame.tw/gnupg/stm32-gnuk/\n[^4]: https://techie-s.work/posts/2021/04/homemade-gnuk/","tags":["OpenPGP"],"categories":["电子"]},{"title":"春节十二响 题解","path":"/post/spring-12-biu/","content":"## 题意\n\n给定 $n$ 个程序，每个程序所需内存空间为 $m_i$。\n\n这些程序的调用关系形成一棵以 $1$ 为根的树。\n\n内存可以分为若干个段，每个段存放若干个程序，这些程序在调用关系树上不能为祖先-后代关系，每个段的大小为存放的程序所需空间的最大值。\n\n$n\\leq 2\\times 10^5$\n\n## 题解\n\n做这种题要先从部分分入手。\n\n它给了一个特殊性质：调用关系为一条链。我们把一个位置的段记到一个集合里，然后分类讨论：\n\n-   只有一个儿子：有依赖关系显然没法扔到一个段里面，所以把 $m_i$ 扔到集合里面。\n-   两个儿子：一个容易想到的贪心策略，即把两个儿子的段集合里面最大的几个拿出来合并到一个段里面（即取 $\\max$）。  \n    我们用堆来维护这个集合，如果是两个儿子的情况，就取两个儿子的堆顶的 $\\max$ 放到当前节点的堆中，然后分别弹堆顶，重复这个过程直到一个儿子的堆为空，再把另一个儿子剩下的东西扔到父节点堆里面去就好了。\n\n然后我们发现可以用这个方法直接在树上合并，然后就成了一般情况。对于多个儿子的节点，我们将它们按照第二条规则两两合并，然后扔到父节点的集合里面。\n\n（令 $dep_i$ 表示 $i$ 子树内最深的点的深度。）\n\n发现每次都需要让 $\\max_{(u,v)} dep_v$ 个程序从一个堆进入到另一个堆里面，一个链带点叶子的结构就会卡到 $\\Theta(n^2 \\log n)$。\n\n然后我们发现，用到堆的**根节点**最大的特性的地方，仅有**两个儿子堆顶取最大值**的地方，除此以外增加复杂度的地方是“把另一个儿子剩下的东西扔到父节点堆里面去”的过程。\n\n后面这个东西相当于合并两个堆，所以如果你已经用了配对堆/斐波那契堆这类 $\\Theta(1)$ 合并的可并堆那你就可以先走了。\n\n其实我们可以在**两个儿子堆顶取最大值**后扔到一个缓冲区里面，一个堆空了之后直接把缓冲区里面的东西全都扔到另一个非空堆中，这样就省去了合并的过程。这样的话一次合并的复杂度是 $\\min(dep_x,dep_y)$ 的。\n\n分析总时间复杂度，发现每一次取 $\\max$ 实际上就是扔掉一个元素，然后每个元素只能被扔掉一次，总共被扔了 $\\Theta(n)$ 次，加上堆的影响就成了 $\\Theta(n\\log n)$ 次。","tags":["启发式合并","贪心"],"categories":["题解"]},{"title":"Tauri 使用 WebviewWindow 新建窗口","path":"/post/tauri-react-jsx-dynamic-new-window/","content":"我使用的是 create-tauri-app 里面自带的 Vite + React 配置。\n\n按照[官网说明](https://tauri.app/zh-cn/v1/guides/features/multiwindow#%E5%9C%A8-javascript-%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3)，你可能这样写了：\n\n```jsx\nimport { WebviewWindow } from \"@tauri-apps/api/window\";\nfunction App() {\n    let open = () => {\n        const webview = new WebviewWindow(\"my-label\", {\n            url: \"https://www.tibrella.space/\",\n        });\n        webview.once(\"tauri://created\", function () {\n            console.log(\"Failed\");\n        });\n        webview.once(\"tauri://error\", function (e) {\n            console.log(\"Failed\");\n        });\n    };\n    return <button onClick={open}></button>;\n}\n```\n\n但是你又发现，咋运行都跑不起来，然后控制台里面只有你自己设置好的 `console.log(\"Failed\");`，其他报错一概没有。\n\n然后搜了好久，我找到了[一篇 Tauri 教程](https://ithelp.ithome.com.tw/m/articles/10304587)，里面提到了需要更改 `/src-tauri/tauri.conf.json`，但是官网文档完全没有提到这件事情......\n\n最终解决方案：`/src-tauri/tauri.conf.json` 中 `\"allowlist\"` 字段添加 `\"window\": { \"create\": true }` 即可。\n\n```diff\n{\n    \"build\": {\n        \"beforeDevCommand\": \"pnpm dev\",\n        \"beforeBuildCommand\": \"pnpm build\",\n        \"devPath\": \"http://localhost:1420\",\n        \"distDir\": \"../dist\",\n        \"withGlobalTauri\": false\n    },\n    \"package\": {\n        \"productName\": \"name\",\n        \"version\": \"0.0.0\"\n    },\n    \"tauri\": {\n        \"allowlist\": {\n            \"all\": false,\n            \"shell\": {\n                \"all\": false,\n                \"open\": true\n-            }\n+            },\n+            \"window\": {\n+                \"create\": true\n+            }\n        },\n        \"bundle\": {\n            \"active\": true,\n            \"targets\": \"all\",\n            \"identifier\": \"com.tauri.dev\",\n            \"icon\": [\n                \"icons/32x32.png\",\n                \"icons/128x128.png\",\n                \"icons/128x128@2x.png\",\n                \"icons/icon.icns\",\n                \"icons/icon.ico\"\n            ]\n        },\n        \"security\": {\n            \"csp\": null\n        },\n        \"windows\": [\n            {\n                \"fullscreen\": false,\n                \"resizable\": true,\n                \"title\": \"name\",\n                \"width\": 800,\n                \"height\": 600\n            }\n        ]\n    }\n}\n```\n\n修改之后就可以按照最开始提到的方法动态创建新窗口了。","categories":["Tauri"]},{"title":"如何在使用 Linux 环境的比赛现场配置一个好用的 Visual Studio Code？","path":"/post/noi-vscode/","content":"本文的 vscode 配置无需任何扩展，可以直接在纯 vscode/code-oss/vscodium 端使用。视频采用了 AV1 编码 + webm 容器封装，如果观看不了请使用最新版 chromium/firefox，或者下载后观看。指令有经过修改，请以下文给出的为准。  ~~懒得重新录视频了~~配置演示视频，包含快捷键演示你会写 JSON 吗？不会写的话你只需要知道这玩意需要一大堆大括号就行了。直接给你一套配置文件：位置：`.vscode/tasks.json`，项目根目录下。```json{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"My Task\", \"type\": \"shell\", \"command\": \"dirname ${file}/.. && g++ ${file} -o out.exe -O2 && ./out.exe && rm ./out.exe\", \"problemMatcher\": [] } ]}```程序配置文件目录下 `keybindings.json`：  ```json[ { \"key\": \"F4\", \"command\": \"workbench.action.tasks.runTask\", \"args\": \"My Task\" }]````dirname + 文件路径` 可以提取出这个文件路径的文件夹位置。然后 bash 有个特性就是输入文件夹名称相当于 `cd` + 这个文件夹名称。作用是进入 C++ 源文件目录。`${file}` 是文件名变量，`&&` 是关系运算符。`args` 和 `label` 是任务的名称，随便取一个就行。这里采用了默认的 \"My Task\"。`command` 部分为了兼容 Windows 而加上了 `.exe` 扩展名，对 Linux 没有影响。`problemMatcher` 行可以去掉，这行是 VSCode 默认配置带上的。`F4` 可以改成任意其他键，具体看视频，添加键绑定时按照要求按下想要设置的快捷键组合即可。非常短，大部分有自动补全。","categories":["杂文"]},{"title":"2023.9.2 闲话","path":"/post/diary-2023-09-02/","content":"模拟赛连续爆两天蛋了。\n\n不是，CF 不设置部分分那我怎么拿部分分。然后就睡觉写博客呗。\n\n联赛退役赶紧回去学文化课吧。\n\n---\n\nBaoshuo 配的 s2oj docker-compose 是残废啊...折腾了好久，还得手动进去启动 apache2 然后设置 mysql 账户密码。\n\n启动一个 S2OJ 性能提升计划：\n\n- [ ] 服务端由 Apache 更换到 OpenLiteSpeed\n- [ ] OpenLiteSpeed 启用 HTTP3/QUIC 传输\n- [ ] 服务端 Docker 基础镜像由 Ubuntu 更换为 Debian sid/Alpine\n- [ ] C/C++ 部分使用 Clang 编译，并添加指令集优化（S2OJ 机子是支持 avx2 的）\n\n前提是联系上 Baoshuo 并向他要一份配置文件（\n\n---\n\n推歌：『また月夜に』 - めらみぽっぷ\n\n凋叶棕新专辑的收音比上一张强了点，能体现出来梅拉米完美无瑕的声音了。\n\n但是歌好少，只有四首，其他都是念白，nayuta 只在最后的念白里面出现了，好可惜，想听 nayuta 唱歌。\n\n这一首感觉算挺容易中毒的一首，Vocal 声线也很强大。\n\n---\n\nCF585E\n\n待补。\n\n计数杂题更新了两道模拟赛题。","tags":["闲话"],"categories":["闲话"]},{"title":"2023.8.28 闲话","path":"/post/diary-2023-08-28/","content":"不知道为啥用的 ZXGU 的极限精简系统会导致 steam 出现傻逼问题，开了干净启动才能玩上 CSGO。\n\n---\n\n没万用表，没三极管，没线，没钱，啥都没有，然后数码管现在完全搞不明白怎么用。\n\n改天先把驱动 LED 的教程写了吧。\n\n---\n\n推歌\n\n忘却の雨 —— あさな，专辑为 IOSYS《ROCKIN'ON TOUHOU VOL.1》\n\n连下两天雨，第一个想到的就是这首歌。\n\n厄，算我听过的第一首寿命论歌曲，讲的是蕾米再也喝不到咲夜泡的红茶了。\n\n啊啊，还真是心痛呢。\n\n人总是这样一个接一个地离去，谁也不知道明天迎接的是死亡还是生存。\n\n唯一要做的是像已经离去的伟大的人一样，为后世留下自己能留下的东西，活下去的目的就是传递这样抽象的脆弱而强大的所谓希望。\n\n---\n\n值域巨他妈大的简单计算题求解可以利用哈希的思想，扔一堆模数分别计算。\n\n比如一元高次方程，它本身的解在模一个数的意义下一定也是这个方程的解。\n\n---\n\n小米能不能死啊，ax3000 开 ssh 太费劲了，懒得搞。\n\n---\n\nCEC IDE 是本年度最佳笑话。","tags":["闲话"],"categories":["闲话"]},{"title":"手把手带你实现跳表","path":"/post/skip-list/","content":"引入跳表（跳跃表）能够维护一个数的集合（作用类似普通平衡树），查找时间复杂度为 $\\Theta(\\log n)$，与平衡树一样基于链表结构。由于不需要平衡树那么多旋转什么的，所以效率比较高，一般认为性能能打红黑树。除此以外，链表的特性使它能够以线性时间遍历某个子段。Redis 的有序集合就是用跳表实现的。更简单来说，跳表是一个支持 $\\Theta(\\log n)$ 时间随机访问的链表。定义上面这个东西叫链表。我们知道，链表只支持线性时间访问，所以不能二分。我们如果想维护一个有序序列的话，虽然插入删除很快，但是找到一个值对应的位置很慢。我们又知道，链表的访问形式实际上是一个一个遍历，而它有 $n$ 个元素，这是它 $\\Theta(n)$ 复杂度随机访问的根源所在。那我们是不是可以给链表精简一下呢？比如说，我给链表多加几层，每层减少一半的元素，像这样：（蓝色方框括起来的是一个节点，实现的时候我们不需要把上面几层显式地建出来，只需要创建对应层的指针即可。）这样的话，我就能像上图这样找到 $78$ 这个节点了。橙色路径是原有路径，走了 $4$ 次。而上面的绿色路径只走了 $\\log_2 4 = 2$ 个次。好好好，那我这样建的话，我就能在链表上二分了！  实际上这个东西叫完美跳表。跳表分两种，一种是上面的完美跳表（暂且这样叫）。这个东西最大的特点就是过于理想化了。如果加上插入删除的话，维护对应层的指针就太难了，每次都得更新。另一种是基于随机化的跳表。  要随机化的东西叫做 $level$。一个跳表节点的 $level$，代表着这个节点同时存在于 $1 \\sim level$ 层的链表中。比如说，上图的值为 $1$ 的节点 $level = 3$，值为 $23$ 的节点 $level = 1$。  取 $level$ 的方式类似于抛硬币，计算 $level$ 时，如果硬币正面朝上，就 $+1$ 并继续抛；如果反面朝上，则停止。通过这样定下节点 $level$ 的跳表就是我们今天要实现的跳表。基本实现为了方便演示，这里就不再封装跳表了，其实跟着教程一边走一边封装也是可行的。一些变量`int level` 记录跳表的最高 level。`Node head` 为了防止过多的边界的分类讨论，建立一个空结点当头节点。节点动态分配内存太慢了，如果用动态分配的，我还不如直接 STL。所以开好数组作为预分配的空间，然后我们可以开一个指针记录分配到了哪一个位置。需要创建新节点的时候直接返回一个 `++tot` 即可。```cppstruct Node { int key, level; Node* nxt[MAX_LEVEL];} space[N], *tot = space;```此处 `level` 的含义是：该节点存在于 0 到 `level`-1 层的链表中，与前文定义 1 到 `level` 不同。垃圾回收可以自己实现，待会的整体演示里面会放。分配一个新节点空间，返回新节点的指针：```cpp#define new_node() (++tot)```创建一个值为 `key` 高度为 `level` 的节点：```cppNode* create_node(int level, int key) { Node* res = new_node(); res->level = level; res->key = key; return res;}```随机生成 level前面说了，是抛硬币。所以我们可以直接借用一些随机数生成器[^1]。然后我们肯定不能让层数无限大啊，所以需要设置一个 `MAX_LEVEL` 作为最大层数。```cpp#define MAX_LEVEL 12std::random_device seed;std::minstd_rand rng(seed());int random_level() { int res = 1; while (res < MAX_LEVEL && (rng() & 1)) { ++res; } return res;}```插入节点声明：```cppvoid insert(int key);```三步走：找到需要插入的位置，插入节点，更新对应 level 的链表。首先我们直接从高 level 开始跳，跳不了了就跳低一级的 level 即可找到需要插入的位置。  同时记录每一个 level 的当前位置之前的节点。（即可能需要更新后向指针的节点）。```cppNode *cur = head;  // currentfor (int lev = level - 1; lev != -1; --lev) { while (cur->nxt[lev] && cur->nxt[lev]->key < key) cur = cur->nxt[lev];  // 存在满足要求的点就跳 update[lev] = cur;}```细节：可能当前 level 还没有到跳表可能达到的最高 level，但是当前这个节点随机到的 level 值在这两个数中间，所以需要将 `level` 到 `MAX_LEVEL` 这段补全为 `head`：```cppint lev = random_level(); // 当前节点的 level 值if (lev > level) { for (int i = level; i < lev; ++i) update[i] = head; level = lev;}```创建节点：```cppcur = create_node(lev, key);```执行插入操作，即对于每一层链表，更新前一个节点的指针，并让当前节点的后向指针指向后一个节点。```cppfor (int i = lev - 1; i > -1; --i) {  // 普通链表插入操作 cur->nxt[i] = update[i]->nxt[i]; update[i]->nxt[i] = cur;}```删除节点和插入类似。```cppvoid erase(int key) { nodePointer cur = head;  // current for (int lev = level - 1; lev != -1; --lev) { while (cur->nxt[lev] && cur->nxt[lev]->key < key) cur = cur->nxt[lev];  // 存在满足要求的点就跳 update[lev] = cur; } cur = cur->nxt[0]; for (int i = 0; i < level; ++i) if (update[i]->nxt[i] == cur) update[i]->nxt[i] = cur->nxt[i]; else break; while (level > 1 && !head->nxt[level - 1])  // 更新当前最大层数 --level;}```额外要注意的是，可能跳表的最高层就这一个节点，删了就没了，所以要判断并更新最大层数。查找结点实际上上面两个函数的第一部分就相当于查找。```cppbool find(int key) { Node* cur; for (int lev = level - 1; lev > -1; --lev) while (cur->nxt[lev] && cur->nxt[lev]->key < key) cur = cur->nxt[lev];  // 存在满足要求的点就跳 return cur->nxt[0] ? cur->nxt[0]->key == key : false;}```查找前驱后继的方法也差不多，前驱就是查找后直接返回 `cur` 而不是 `cur->nxt[0]`，后继可以跳到 `cur->nxt[lev]->key <= key` 的位置之后返回 `cur->nxt[0]->key`。最后的代码中有体现。随机访问上面其实已经实现了跳表的基本功能了，但是显然，目前实现的功能都可以用平衡树替代，而且平衡树还能够按照数的排名查询。由于维护的是有序序列，所以按照数的排名查询相当于随机访问。接下来我们来实现跳表的随机访问。具体方法：维护每个后向指针的“跨度”（span），即它跳了几个节点。设指针 $ptr$ 从第 $a$ 个节点指向第 $b$ 个节点，则 $ptr$ 的跨度为 $b-a$除此以外，我们还需要维护一个长度 `length`，在每次 `erase` 和 `insert` 的时候加减一下就好了。重写智能指针~~啥是智能指针？不太清楚，但是我感觉维护一个 span 的指针实在太智能了！~~我们需要给指针记录一个“跨度”，那就维护一个结构体作为指针，存原来的裸指针和跨度。总的来说，需要构造函数并重载一个运算符，一个类型转换。```cppstruct nodePointer { int span; Node* pointer; nodePointer() { this->pointer = nullptr; // 构造函数，将指针初始化为空 } nodePointer(Node* node) { this->pointer = node;  // 如果提供了指针就用提供的 } Node* operator->() { return pointer; // 指针原有的箭头运算符，访问 nodePointer->x 相当于访问 pointer->x } operator Node*() const { return pointer; // 智能指针转换为裸指针，直接返回 pointer 就好了 }};```不要在所有地方都使用 `nodePointer`，我们只在需要维护跨度的地方使用就好了。  编写代码时一定要注意类型的使用，比如说 `unsigned` `long` 不应乱用之类的。如果错误地更新 `span`，而你滥用了 `nodePointer`，可能就没那么容易找到问题了。博主因为滥用 `unsigned`，跳表调了两天多。需要维护跨度的地方只有跳转用的指针，即 `nxt[]`。child:codeblock open:false color:cyan 更改后的代码```cppstruct Node { int key, level; struct nodePointer { int span; Node* pointer; nodePointer() { this->pointer = nullptr; // 构造函数，将指针初始化为空 } nodePointer(Node* node) { this->pointer = node;  // 如果提供了指针就用提供的 } Node* operator->() { return pointer; // 指针原有的箭头运算符，访问 nodePointer->x 相当于访问 pointer->x } operator Node*() const { return pointer; // 智能指针转换为裸指针，直接返回 pointer 就好了 } }; nodePointer nxt[MAX_LEVEL];} space[N];using nodePointer = typename Node::nodePointer; // 为了方便书写，缩一下```重写插入函数开一个数组记录每一层“上一个节点”的位置（利用跨度）。```cppint lst_pos[MAX_LEVEL];```然后在函数开头找位置的时候顺便把它处理出来：```cppfor (int lev = level - 1; lev > -1; --lev) { // 更新 lst_pos if (lev == level - 1) lst_pos[lev] = 0; // 默认得是 0 else lst_pos[lev] = lst_pos[lev + 1]; // 否则从上一层继承 while (cur->nxt[lev] && cur->nxt[lev]->key < key) { lst_pos[lev] += cur->nxt[lev].span; // 更新 cur = cur->nxt[lev];  // 存在满足要求的点就跳 } update[lev] = cur;}```插入的时候计算一下就好了。如图：然后 `level` 大于这个节点的指针跨度要加一。结合代码理解。```cppfor (int i = 0; i < lev; ++i) {  // 普通链表插入操作 cur->nxt[i] = update[i]->nxt[i]; update[i]->nxt[i].pointer = cur; // 这里不要直接让 nxt[i] = cur，因为后面还要用到 nxt[i].span cur->nxt[i].span = update[i]->nxt[i].span - (lst_pos[0] - lst_pos[i]); // lst_pos[0] 实际上就是上一个节点的位置 update[i]->nxt[i].span = lst_pos[0] - lst_pos[i] + 1;}for (int i = lev; i < level; ++i) ++update[i]->nxt[i].span; // 维护高于新节点的指针的跨度```别忘了 `++length`。重写删除函数把要删掉的指针的 `span` 加起来赋值给新指针就好了。和 `insert` 一样，别忘记比当前节点高的指针跨度要 `-1`。```cppfor (int i = 0; i < level; ++i) if (update[i]->nxt[i] == cur) update[i]->nxt[i].pointer = cur->nxt[i], update[i]->nxt[i].span += cur->nxt[i].span - 1;  // 跨度直接扔给前面那个指针就行了 else --update[i]->nxt[i].span;```随机访问（按照排名查询）```cppint findrk(int k) { assert(k <= length && k); // k 不满足要求就异常 Node* cur = head; for (int lev = level - 1; lev > -1 ; --lev) while (cur->nxt[lev] && k - cur->nxt[lev].span > 0) { k -= cur->nxt[lev].span; cur = cur->nxt[lev];  // 存在满足要求的点就跳 } return cur->nxt[0]->key;}```微调我们可以对 `MAX_LEVEL` 和选取 `level` 的概率进行微调。比如说下面的普通平衡树代码，把选取层数的 $p$ 改成了 $\\frac 14$，即 `(rng() & 1) && (rng() & 1)`，`MAX_LEVEL` 设为了 $7$，经测试这样比较快，在无快读不开 O2 的情况下吊打 Splay/FHQ/Treap，加了快读 O2 之后不知道为啥跑不过我之前写的指针 FHQ 了。另外数组 Treap 始终被吊打。~~这就是指针带给我的自信~~后记实际上跳表最大的优点是能够顺序访问，这点是很多平衡树做不到的，FHQ Treap 分裂区间之后中序遍历是可以的，但是常数太大。**等我把跳表模板题搞出来，他们都得死！**完整代码含类型泛化和封装成类。另外实现了一些输入输出操作，自己看应该能看懂了。child:codeblock open:false color:cyan 代码```cpp#include <iostream>#include <random>#include <cassert>#include <cstdlib>using std::cin;using std::cout;std::random_device seed;std::minstd_rand rng(seed());#define N 106#define MAX_LEVEL 32using i32 = signed int;template <typename T>class skiplist {private: i32 level; struct Node { T key; i32 level; // 千万的别用 unsigned struct nodePointer { i32 span; // 这个也千万他妈的别用 unsigned Node* pointer; nodePointer() { this->pointer = nullptr; // 构造函数，将指针初始化为空 } nodePointer(Node* node) { this->pointer = node;  // 如果提供了指针就用提供的 } Node* operator->() { return pointer; // 指针原有的箭头运算符，访问 nodePointer->x 相当于访问 pointer->x } operator Node*() const { return pointer; // 智能指针转换为裸指针，直接返回 pointer 就好了 } }; nodePointer nxt[MAX_LEVEL]; } space[N]; i32 bintop; using nodePointer = typename Node::nodePointer; Node *head, *tail, *tot, *rubbin[N / 4 * 3];#define new_node() (bintop ? rubbin[bintop--] : ++tot)#define del_node(x) (rubbin[++bintop] = (x)) Node* create_node(const i32& level, const T& key) { Node* res = new_node(); res->level = level; res->key = key; return res; } i32 random_level() { i32 res = 1; while (res < MAX_LEVEL && (rng() & 1)) { ++res; } return res; } Node* update[MAX_LEVEL]; i32 lst_pos[MAX_LEVEL + 1];  // 每个 level 遍历到的最后一个元素的位置public: skiplist() { tail = nullptr; level = 0; head = tot = space; bintop = 0; length = 0; lst_pos[MAX_LEVEL] = 0; for (i32 i = 0; i < MAX_LEVEL; ++i) head->nxt[i] = nullptr, head->nxt[i].span = 0; } void insert(const T& key) { Node* cur = head;  // current for (i32 lev = level - 1; lev > -1; --lev) { // 更新 lst_pos，这里由于已经把 lst_pos[MAX_LEVEL] 设为 0 了，所以不需要像上文一样特判 lst_pos[lev] = lst_pos[lev + 1]; while (cur->nxt[lev] && cur->nxt[lev]->key < key) { lst_pos[lev] += cur->nxt[lev].span; cur = cur->nxt[lev];  // 存在满足要求的点就跳 } update[lev] = cur; } i32 lev = random_level(); if (lev > level) { for (i32 i = level; i < lev; ++i) { update[i] = head; update[i]->nxt[i].span = length;  // 这层都还没有节点，直接从 head 指向尾部（nullptr），跨度为 length } level = lev; } cur = create_node(lev, key); for (i32 i = 0; i < lev; ++i) {  // 普通链表插入操作 cur->nxt[i] = update[i]->nxt[i]; update[i]->nxt[i].pointer = cur; // 这里不要直接让 nxt[i] = cur，因为后面还要用到 nxt[i].span cur->nxt[i].span = update[i]->nxt[i].span - (lst_pos[0] - lst_pos[i]); // lst_pos[0] 实际上就是上一个节点的位置 update[i]->nxt[i].span = lst_pos[0] - lst_pos[i] + 1; } for (i32 i = lev; i < level; ++i) ++update[i]->nxt[i].span; ++length; } void erase(const T& key) { Node* cur = head;  // current for (i32 lev = level - 1; lev != -1; --lev) { while (cur->nxt[lev] && cur->nxt[lev]->key < key) cur = cur->nxt[lev];  // 存在满足要求的点就跳 update[lev] = cur; } cur = cur->nxt[0]; for (i32 i = 0; i < level; ++i) if (update[i]->nxt[i] == cur) update[i]->nxt[i].pointer = cur->nxt[i].pointer, update[i]->nxt[i].span += cur->nxt[i].span - 1;  // 跨度直接扔给前面那个指针就行了 else --update[i]->nxt[i].span; while (level > 1 && !head->nxt[level - 1])  // 更新当前最大层数 --level; del_node(cur); --length; } bool find(const T& key) { Node* cur = head; for (i32 lev = level - 1; lev > -1; --lev) while (cur->nxt[lev] && cur->nxt[lev]->key < key) cur = cur->nxt[lev];  // 存在满足要求的点就跳 return cur->nxt[0] ? cur->nxt[0]->key == key : false; } T findrk(i32 k) { assert(k <= length && k); // k 不满足要求就异常 Node* cur = head; for (i32 lev = level - 1; lev > -1 ; --lev) while (cur->nxt[lev] && k - cur->nxt[lev].span > 0) { k -= cur->nxt[lev].span; cur = cur->nxt[lev];  // 存在满足要求的点就跳 } return cur->nxt[0]->key; } i32 length;};skiplist<i32> list;#include <string>int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); i32 n, tx; cin >> n; for (i32 i = 1; i <= n; ++i) { cin >> tx; list.insert(tx); } std::string s; while (cin >> s) { switch (s[0]) { case ('l'): cout << list.length << std::endl; break; case ('i'): case ('a'): cin >> tx; list.insert(tx); break; case ('d'): case ('r'): { cin >> tx; if (list.find(tx)) list.erase(tx); else cout << \"该值不存在\" << std::endl; break; } case ('f'): cin >> tx; cout << (list.find(tx) ? \"存在\" : \"不存在\") << std::endl; break; case ('g'): cin >> tx; cout << list.findrk(tx) << std::endl; break; default: cout << \"未知命令\" << std::endl; } } return 0;}```child:codeblock open:false color:cyan 普通平衡树```cpp#include <iostream>#include <random>using std::cin;using std::cout;using i32 = int;using i64 = long long;std::random_device seed;std::minstd_rand rng(seed());const i32 MAX_LEVEL = 7;#define N 100005struct Node { i32 level; i64 key; struct ptr { Node* pointer; i32 span; ptr() { pointer = nullptr; span = 0; } ptr(Node* x) { pointer = x; span = 0; } operator Node*() const& { return pointer; } Node* operator->() const& { return pointer; } } nxt[MAX_LEVEL];} space[N], *rubbin[N];Node* tot = space;Node* head = space;i32 bintop;#define new_node() (bintop ? rubbin[bintop--] : ++tot)#define del_node(x) (rubbin[++bintop] = (x))i32 level;  // global max level nowi32 length;i32 random_level() { i32 res = 1; while (res < MAX_LEVEL && (rng() & 1) && (rng() & 1)) ++res; return res;}Node* create_node(const i32& level, const i64& key) { Node* res = new_node(); res->key = key; res->level = level; return res;}void insert(const i64& key) { Node* cur = head; Node::ptr update[MAX_LEVEL]; i32 lst_pos[MAX_LEVEL + 1]; lst_pos[level] = 0; for (i32 l = level - 1; l > -1; --l) { lst_pos[l] = lst_pos[l + 1]; while (cur->nxt[l] && cur->nxt[l]->key < key) { lst_pos[l] += cur->nxt[l].span; cur = cur->nxt[l]; } update[l] = cur; } i32 lev = random_level(); if (lev > level) { for (i32 i = level; i < lev; ++i) { update[i] = head; update[i]->nxt[i].span = length; lst_pos[i] = 0; } level = lev; } cur = create_node(lev, key); for (i32 i = 0; i < lev; ++i) { cur->nxt[i] = update[i]->nxt[i]; cur->nxt[i].span = update[i]->nxt[i].span - (lst_pos[0] - lst_pos[i]); update[i]->nxt[i].pointer = cur; update[i]->nxt[i].span = lst_pos[0] - lst_pos[i] + 1; } for (i32 i = lev; i < level; ++i) ++update[i]->nxt[i].span; ++length;}void erase(const i64& key) { Node* cur = head; Node::ptr update[MAX_LEVEL]; for (i32 l = level - 1; l > -1; --l) { while (cur->nxt[l] && cur->nxt[l]->key < key) cur = cur->nxt[l]; update[l] = cur; } cur = cur->nxt[0]; for (i32 i = 0; i < level; ++i) if (update[i]->nxt[i] == cur) update[i]->nxt[i].span += cur->nxt[i].span - 1, update[i]->nxt[i].pointer = cur->nxt[i].pointer; else --update[i]->nxt[i].span; while (level > 1 && !head->nxt[level - 1]) --level; del_node(cur); --length;}i32 get_rk(const i64& key) { Node* cur = head; i32 res = 0; for (i32 l = level - 1; l > -1; --l) { while (cur->nxt[l] && cur->nxt[l]->key < key) { res += cur->nxt[l].span; cur = cur->nxt[l]; } } return res + 1;}i64 find_by_rk(i32 k) { Node* cur = head; for (i32 l = level - 1; l > -1; --l) { while (cur->nxt[l] && k - cur->nxt[l].span > 0) { k -= cur->nxt[l].span; cur = cur->nxt[l]; } } return cur->nxt[0]->key;}Node* prev(const i64& key) { Node* cur = head; for (i32 l = level - 1; l > -1; --l) { while (cur->nxt[l] && cur->nxt[l]->key < key) cur = cur->nxt[l]; } return cur;}Node* next(const i64& key) { Node* cur = head; for (i32 l = level - 1; l > -1; --l) { while (cur->nxt[l] && cur->nxt[l]->key <= key) cur = cur->nxt[l]; } return cur->nxt[0];}int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); i32 n; i32 op, x; cin >> n; while (n--) { cin >> op >> x; switch (op) { case (1): insert(x); break; case (2): erase(x); break; case (3): cout << get_rk(x) << '\\n'; break; case (4): cout << find_by_rk(x) << '\\n'; break; case (5): cout << prev(x)->key << '\\n'; break; case (6): cout << next(x)->key << '\\n'; break; } // cout.flush(); } return 0;}```复杂度分析空间复杂度设定了最高 `level`，所以空间复杂度只能是 $\\Theta(n)$ 的。时间复杂度见 OI Wiki参考文献《跳跃表数据结构与算法分析》 纪卓志 George《跳表》 OI Wiki推荐阅读《关于 skip list 的一些扩展想法》[^1]: 有的朋友可能会有疑问啊，为什么能够直接取随机数的某一位呢？这不会分布地不够均匀吗？为什么用线性同余而不用统计意义更好的 `mt19937` 呢？我想用 `std::bernoulli_distribution` 可以吗？ 本人做了测试，在随机种子 + 1000 次取值的测试下，梅森缠绕和线性同余两种算法通过 `& 1` 求出来的平均值基本上就是 $0.5\\pm 0.03$，而且线性同余性能远比梅森缠绕高。然后用 PCG 算法测试了一下，发现 PCG 官方给的 C++ 实现能够做到 $0.5\\pm 0.02$，性能接近线性同余，但是这玩意考场上得自己实现，所以还是用线性同余吧。 至于 `std::bernoulli_distribution`，这东西是取 `std::uniform_real_distribution` 和设定概率比较做出来的，而 `std::uniform_real_distribution` 是取随机数之后做一堆浮点运算，效率太低了，而且最后得出来的结果并没有比直接 `& 1` 强到哪去。","tags":["跳表","随机化"],"categories":["数据结构"]},{"title":"2023.8.19 闲话","path":"/post/diary-2023-08-19/","content":"首先是破事。\n\n晚上睡的好晚，第二天早上起来没精神折腾单片机了。\n\nUpdated on 8.21: 东西删了，该怎么着就怎么着吧。为了吃瓜而来的可以关网页走了。\n\n---\n\n破事还是少点好。\n\n打了场 ABC，C 题吃了 5 发罚时，结果是一个非常傻逼的少更新一个数组的错误。（赛时没调出来）  \n非常完美的跳题策略，成功跳过 D 题并直接拿下 E 题，但是 F 题太急了当贪心做了。\n\n---\n\n推歌\n\n《ヒカリ》—— めらみぽっぷ，专辑 凋叶棕《綴》\n\n梅拉米唱歌一直很有感染力，我认为这首是她感染力最强的一首。\n\n第一次见这首歌是在 2023 东方新春宴的一个静止系 mad，差点看哭了。\n\n讲的是神琦创作一个人偶爱丽丝，逐渐将其认可成为自己女儿的事。\n\n没啥说的，梅拉米牛逼，这首歌从人声和伴奏上都很有感染力，对神琦的塑造非常形象。\n\n---\n\nabc315 e 题\n\n实际上就是找出 1 这个任务依赖的所有任务。\n\n于是建反图，从 1 开始 dfs，输出 dfs 的出栈序列（逆后序）即可。由于栈顶一定没有依赖，所以相当于做了拓扑排序，是正确的。\n\n---\n\n要退役了，我要学跳表。","tags":["闲话"],"categories":["闲话"]},{"title":"2023.8.18 闲话","path":"/post/diary-2023-08-18/","content":"好好好，闲话日更了。\n\n---\n\n上午搜到了一个用 sdcc 支持的语法写的 [LED 控制程序](https://www.jianshu.com/p/bf313788b37b)，还有完整的注释，于是就用了。现在单片机能够控制 LED 灯亮灭了。就是用杜邦线串起来的两个 6 厘米多长的电阻看起来有点傻逼 😅。然后还得串一个 LED 进去。\n\n8051 这块貌似被商业工具链占据大部分市场了，个人认为这是很恐怖的事情，所以迅速使用 sdcc 报平安。Keil 再对个人免费你也没法确定什么时候割韭菜，对商业公司人也肯定得收费。\n\nARM 和 RISC-V 之类架构的板子，LLVM 应该够用了，在这基础之上你还能写 Rust 之类支持 LLVM 后端的语言。\n\n买的 RGB 灯环好傻逼，不能用杜邦线接，口太细还焊不了，买的时候应该看看接口型号的 😅。\n\n下一步就是折腾数码管了，打算搞一个 IO 口用来校准时间，然后用塑料定一个包装送给谢特以报答他从他们学校小卖部给我买的东方明信片。\n\n会发博客的，这方面教程还是太少了。\n\n---\n\n推歌。\n\nまりおさんに贈るナイト・オブ・ナイツ2018 —— marasy，专辑是 COOL&CREATE 的骑士之夜。\n\n听到的第一首来自触手猴的东方组曲，这首曲子在音色（收音），编曲，节奏上都无可挑剔，感觉是非常养耳朵的一首歌，它的收音要比很多猴子专辑中的曲子好的。\n\n实际上就是在骑士之夜里串了好几首曲子（笑）\n\n\n但是多少有点中耳炎，这段时间不太能听歌了。\n\n---\n\n题目分享继续见[计数杂题](/post/count-misc-questions)。\n\n--- \n\n[飞扬的小鸟本纪](https://www.luogu.com.cn/blog/tibrella/fei-yang-di-xiao-niao-ben-ji)\n\n---\n\n篮球基本不会打了，现在干什么都跟半身不遂一样不协调。\n\n---\n\n博客的 MathJax 终于让咱给修好了，改了一下目录结构，把 MathJax 相关的文件扔到了和评论同级的 `plugins` 目录下，然后仿照一刀斩给 waline/valine 写的加载脚本给 MathJax 贺了一份。\n\n现在可能出现的问题是打开某一个页面是白色的，原因未知，刷新就好了。\n\n对了，我编写的 MathJax 加载脚本是使用原配置文件中的 cdn 选项的，所以不用担心选项失效什么的问题。本站现在使用最新的 MathJax 4.0.0-beta.3 版本。","tags":["闲话"],"categories":["闲话"]},{"title":"2023.8.17 闲话","path":"/post/diary-2023-08-17/","content":"首先一个喜报，两天时间把博客迁移到 Hexo 上了，更好的是，很多东西都有国内 CDN 支持，所以你访问本博客不会太慢。\n\n~~不太好的是，由于 InstantClick 的一些东西没搞明白，对 JSX 还不够熟悉，导致你从本站某一个页面转到另一个页面的时候会导致数学失效。同时首页摘要上的 $\\LaTeX$ 可能会炸。~~ 修好了。\n\n这个主题实在太强了，很多自定义标签，还有时间轴和项目文档支持，刚刚给 linux-tikogasa 写了个介绍，可以点击页面底部的文档字样进入。时间轴进入方法同理。\n\n---\n\n再来一个喜报，经过 2 天的等待，我买的晶振到了。然后经过一中午和晚上一小时的折腾，成功让电脑检测到了单片机的信息。不得不说，这方面教程还是太少了，过两天写一个基础安装的文档。\n\n下一步是用 sdcc 编写程序，但是为什么这个 RGB 灯环没有文档啊，可恶。\n\n---\n\n推歌。\n\n《亡霊》 —— あよ，专辑《ダイナマイト》。\n\n非常好的慵懒感，可能是因为长时间缺乏睡眠精神紧张导致喜欢这种感觉的吧（笑）。\n\n---\n\n题目分享可以看[计数杂题](/post/count-misc-questions)","tags":["闲话"],"categories":["闲话"]},{"title":"计数杂题","path":"/post/count-misc-questions/","content":"部分题目来自这个题单。Luogu P6075 [JSOI 2015] 子集选取首先，发现可以把元素单独拎出来考虑，假设对于一个元素来说有 $x$ 种放置方案，则答案为 $x^n$。继续转化题意。对于 $A_{i,j}$，它必须是它左边集合的子集，也得是上边集合的子集。  也就是说，如果 $A_{i,j}$ 包含元素 $x$，则在它正上方、左上方、左侧的所有集合都包含 $x$。（形式化来说，即 $A_{a,b},1\\leqslant a \\leqslant i,1\\leqslant b \\leqslant j$ 均包含 $x$）然后想象一种合法方案，容易发现每种方案就相当于把整个三角形分成两半，左上一半右下一半。每两种方案不同当且仅当左上右下的分界线不同。于是我们就能很轻松地求方案数了，即一个分界线从左下走到右上的方案。每一步可以向左或者向右走，即 $2^k$。快速幂即可。Luogu P6146 [USACO 20 FEB] Help Yourself G 首先为了划分未求解和已求解的部分，我们需要把线段按照左端点排序。给一个不排序会遇到错误的例子：```plaintext---- 1  ------3 --------- 2```用下面的做法做的话，先算 $1,3$ 和先算 $1,2$ 是不一样的，可以自己体会一下。然后设 $f_i$ 为前 $i$ 个线段的答案。为什么只有一维？因为容易发现子集这个东西很难用来划分阶段。另外前面的排序已经使得这种状态划分是唯一的了。考虑如何推出 $f_i$。$f_i$ 的答案由两部分组成：- 前 $i-1$ 个线段的答案 $f_{i-1}$- 前面所有子集加上第 $i$ 条线段的答案。发现后者实际上也是分两部分的：- 新增的连通块（复杂度）- 除去新增，也就是原有的复杂度 $f_{i-1}$好了，那么新增的连通块怎么算？实际上就是与第 $i$ 条线段不相交的前 $i-1$ 条线段的子集的数量。为啥呢？  那我们可以把前 $i-1$ 条线段的子集分两类：与 $i$ 相交与不相交。显然相交的子集不会贡献答案，不相交的子集会且仅会贡献 $1$ 的答案。然后问题就转化为：对前 $i-1$ 条线段与线段 $i$ 不相交的子集计数。  容易发现就是与线段 $i$ 不相交的所有线段集合 $\\mathbb X$ 的子集数量，计数就是 $2^{\\lvert \\mathbb X \\rvert}$得到递推式：$$f_i = 2f_{i-1}+2^{\\lvert \\mathbb X \\rvert}$$$\\mathbb X$ 的大小我们可以预处理出来：统计每一个右端点出现的次数 $s_i$，然后做一个前缀和，最后 $s_{i-1}$ 就是不覆盖点 $i$ 的线段数量。用快速幂优化，复杂度 $\\operatorname{O}(n\\log n+n\\log n)$，如果用光速幂可以干到 $\\operatorname{O}(n\\log n+n+\\sqrt n)$。P6008 [USACO 20 JAN] Cave Paintings P 首先发现答案就是把每个连通块的方案数乘起来。那对于一个连通块怎么算答案？一个比较蛋疼的事实是，即使是同一个连通块，我们也不能保证它每个部分的水位是一样的，比如下面这个例子：```######## #### ## ## # ```显然左右侧在分割开的时候可以水位高度不同。那我们能不能对分割开的两块分别算呢？答案是不行，因为连通器原理。```######### ## ## ## # ```初中物理可知，左右两侧水位必须一样高。所以我们需要动态维护这个关系，用啥呢？并查集。初始化每个格子答案为 1，然后对于每个连通块从下往上涨水，过程如下：- 把这一行相邻的能放水的位置连在一起，表示他们必须是一个水位的。- 遍历该行每一个空位，如果这个位置下面也是空位且二者目前没有相连，那么当前位置方案数 `*=` 正下方一格方案数，同时把两个格子相连，表示两个连通块接在一起了。- 遍历该行每一个空位，每遇到一个连通块（`find(x) == x`）就把该格方案数加一。 最后用前面提到过的判断连通块的方式把答案乘起来就好了。Luogu P1350 车的放置 同样是蓝题，但是比上一道水多了。每一行每一列都只能放一个棋子，那直接从上往下遍历行，同时枚举放几颗棋子递推计数即可。具体来说，设 $f_{i,j}$ 为前 $i$ 行放了 $j$ 个棋子的方案数量，则转移方程如下：$$f_{i,j} = f_{i-1,j} + f_{i-1,j-1} (len-j+1)$$其中 $len$ 是行长度。记得把 $f_{0\\sim b+d, 0}$ 设为 $1$。Luogu P3223 [HNOI 2012] 排队 基本上是纯数学题。大概计数题可以分两种大方向思考：正推、容斥。而容斥也大概分两种：手动容斥和套式子反演。想直接拆分算，感觉是一个非常恶心难想的分类讨论。递推，设 $f_{n,m}$ 为 $n$ 男生 $m$ 女生的方案数，发现推不了。那就手动容斥。  容易发现把老师的限制扔掉之后是可以轻松算出来答案的：$A^m_m A^{n+2}_{n+2} \\binom{n+3}m$，即把老师当成男生随便放置，然后在他们中间的空隙中选出来 $m$ 个用来放女生。然后不合法方案，即两个老师靠在一起的方案，把两个老师绑在一起当一个男生求出来所有合法方案即可。别忘了两个老师顺序可以变，所以加一个 $A^2_2$。最终答案：$A^m_m A^{n+2}_{n+2} \\binom{n+3}m - A^m_m A^{n+1}_{n+1}\\binom {n+2}m A^2_2$为啥说基本上是纯数学题而不是完全的数学题？因为这题需要打高精。然后我用 python 写的，python 整数除法返回浮点值，所以要强制整除，即使用 `//`。举个例子，算 $\\binom nm$：```pythonimport mathdef binom(n, m) -> int: if n < m: return 0 else: return math.factorial(n)//math.factorial(m)//math.factorial(n-m)```[CSP-S 2019] Emiya 家今天的饭挺难的题。首先我们可以把选菜看成从方阵里面选数，每行只能选一个，每列最多选 $\\lfloor \\frac k2 \\rfloor$ 个。如果我们分列来考虑，发现合法的列有很多，但是不合法的列只会出现一个。（显然选的数超过总数一半的列只会有一个吧）  换句话说，如果我们正着算，记录合法方案总数，是一件非常困难的事情，因为每一列的合法情况我们都要记录。但是相对的，对于不合法方案计数，我们可以枚举不合法的列进行递推。当我们保证这一列不合法时，其他列一定合法，这样我们就不用记太多状态了。枚举到第 $col$ 行，设 $f(col)_{i,j,k}$ 为第 $col$ 列为不合法列，前 $i$ 行，第 $col$ 行选了 $j$ 个数，其他行选了 $k$ 个数的方案数量，$s_{i}$ 为第 $i$ 行 $a$ 的总和，则有转移方程：$$f_{i,j,k} = f_{i-1,j,k}+f_{i-1,j-1,k}\\cdot a_{i,col}+f_{i-1,j,k-1}\\cdot (s_i-a_{i,col})$$然后不合法方案数即 $\\sum_{j>k} f(col)_{n,j,k}$复杂度 $\\Theta(mn^3)$，想办法减少状态。根据刚才不合法方案数的计算，我们发现，一个方案不合法，当且仅当有一列选的数大于其他列选的数之和。换句话说，刚才对不合法方案数的统计，基于 $j>k$ 这个条件，那我们是不是可以只记录 $j-k$ 这个东西呢？设 $f(col)_{i,j}$ 为第 $col$ 列为不合法列，前 $i$ 行，当前行选的数比别的行多 $j$ 个的总方案数，转移方程和上面的差不多：$$f_{i,j} = f_{i-1,j} + f_{i,j-1}\\cdot a_{i,col} + f_{i,j+1}\\cdot(s_i-a_{i,col})$$不合法方案数：$\\sum_{j>0} f(col)_{n,j}$容易发现这个东西可能是负数，所以实现的时候要给 $j$ 这一维加一个 $n$。然后是计算总方案数，设 $g_{i,j}$ 为前 $i$ 行选了 $j$ 个数的方案数，转移方程：$$g_{i,j} = g_{i-1,j} + g_{i-1,j-1} \\cdot s_i$$最终答案：$\\sum_{i=1}^n g_{n,i} - \\sum_{col=1}^m\\sum_{j>0}^n  f(col)_{n,j}$Luogu P3214 [HNOI 2011] 卡农题意要求选取子集有三条限制：  - 非空- 选出的子集两两不同- 所有元素的出现次数为偶数转化 1：将“子集”转化为“二进制数”，然后选取子集变成从 $0,1\\dots 2^n-1$ 个数里面选出 $m$ 个，然后限制就变成了：  - 这些数不等于 $0$- 这些数异或和为 $0$- 这些数两两不同转化 2：答案是“无序”的方案数，我们发现这个 $m$ 个数无序的方案数乘一个排列 $A_m^m$ 就是有序的方案数，显然后者比较容易划分阶段，所以我们可以算出有序的方案数再除以 $A_m^m$。然后我们发现这上面几条限制挺难同时记录并递推的，那我们可以考虑一下排除不合法方案。设 $f_i$ 为选 $i$ 个数的方案数，先考虑第二条限制。在这条限制下，当 $1\\sim i-1$ 这些数选完之后，第 $i$ 个数是确定的。换句话说，满足第二条限制的方案数，即为前 $i-1$ 个数随意选择的方案数（非空）：$A_{2^n-1}^{i-1}$。然后考虑第一条限制，发现第 $i$ 个集合为空且总异或和为 $0$，把第 $i$ 个数（空）去掉依然合法。不满足第一条限制的方案数即 $f_{i-1}$。最后考虑第三条性质：假设第 $i$ 个数与前面第 $j$ 个数相同了，那么这个第 $i$ 个数有 $2^n-1-(i-2)$ 种取值，这个第 $j$ 个数的位置有 $i-1$ 种可能性。除此以外的地方合法（前面已经保证异或和为 $0$ 了，现在再异或两个相同的数结果不变）且长度为 $i-2$。因此不满足这个要求的方案数有 $f_{i-2}(2^n-1-(i-2))(i-1)$然后就可以递推求解了，$f_i = A_{2^n-1}^{i-1} - f_{i-1} - f_{i-2}(2^n-1-(i-2))(i-1)$，答案是 $f_m$。$A_{2^n-1}^{i-1}$ 可以预处理，$A_{2^n-1}^1 = 2^n-1$，剩下的挨个乘就好了。预处理到 $m$ 即可。CF 932 E~~模拟赛写不动题了过来写这玩意挺合理的吧~~原题意是给定 $\\lvert \\mathbb S\\rvert,k$，求 $\\sum_{\\mathbb T\\subseteq \\mathbb S} \\lvert \\mathbb T \\rvert ^ k$。然后我们发现这个东西只与 $\\mathbb {S,T}$ 的大小有关，所以改为枚举大小，u设 $n = \\mathbb S$，原式化为：$$\\sum_{i=1}^n \\binom ni i^k$$把 $i^k$ 用组合意义干掉。发现这玩意就是 $k$ 个不同小球放进 $i$ 个不同盒子的方案数。继续组合意义分析，上面那个式子相当于是：从 $n$ 个盒子里选出 $i$ 个盒子，然后把 $k$ 个小球放在这 $i$ 个盒子里面的方案数。~~继续发现~~发现这 $k$ 个小球最多只能放满 $k$ 个盒子，所以我们转头去枚举“哪些盒子有小球”。设 $f_{i,j}$ 为从 $n$ 个盒子选出 $j$ 个，$i$ 个小球放入这 $j$ 个盒子，盒子非空的方案数，然后我们要求的东西就变成了：$$\\sum_{i=1}^k f_{k,i} 2^{n-i}$$（确定 $j$ 个盒子要放入小球之后，剩下 $n-j$ 个小球可能会被选入最初选的 $i$ 个盒子中也有可能不被选入，所以有一个 $2^{n-i}$）。$k \\leqslant 5\\times 10^3$，$\\Theta(k^2)$ 能过。$i$ 个小球放入 $j$ 个盒子，盒子非空的方案数，相当于 $i$ 个元素被划分成 $j$ 个非空子集的方案数，联想到第二类斯特林数。又因为选出来的 $j$ 个盒子不一定是哪几个，而且两两不同，我们还得乘进去一个排列。即 $f_{k,i} = {k \\brace i}A_n^i$，最终答案即为：$$\\sum_{i=1}^k {k \\brace i} A_n^i 2^{n-i}$$第二类斯特林数可以 $\\Theta(k^2)$ 预处理，递推式为 ${i \\brace j} = {i-1 \\brace j-1}+j{i-1 \\brace j}$。$A_n^i$ 实际上就是 $n$ 的下降幂，这玩意也是直接预处理到 $A_n^k$ 就好。后面的 $2^{n-i}$ 可以用快速幂或者光速幂。光速幂没啥太大必要，毕竟复杂度瓶颈不在这。CF 1850 G感觉这题没啥必要放，毕竟 CF 1500，但是我写的 $\\Theta(n \\log n)$ 大概算是常数比较小的版本吧。发现满足要求的两个点只有四种可能：- 横坐标相等- 纵坐标相等- 横纵坐标和相等- 横纵坐标差相等所以我们把所有点按照上面四个元素作为关键字排序四次，每次分别统计相等的个数 $x$，让答案加上 $x(x-1)$ 就好了。感觉比他们写的 `std::map` 做法常数要小。CF 1485 F简化题意给定数组 $b$，对合法的 $a$ 计数。  合法的 $a$ 即 $\\forall i \\in [1,n],b_i = a_i$ 或 $b_i = \\sum_{j=1}^i a_j$ 我们一个一个数填，发现对于每一个 $a_i$，有两种可能：- $a_i = b_i$- $a_i = b_i - \\sum_{j=1}^{i-1}a_i$然后设 $f_s$ 为当前和等于 $s$ 的方案数。然后上面两个可能就变成了：- $f_{x+b_i} = f_{x}$- $f_{b_i} = \\sum_{j\\in \\mathbb Z} f_j$发现，第一个操作就是把整个数组向右移动了 $b_i$，所以我们只需要记录一下偏移量每次加一个 $b_i$ 就完成了 $\\Theta(1)$ 转移。  第二个实际上等于一个位置前面所有元素的和，$f_x$ 变成了 $ans$，然后原来的 $f_x$ 没了，于是 $ans = ans - f_x + ans$。值域很大，所以要用 `std::map` 或者 `std::unordered_map`，后者需要重写哈希函数。示例代码 child:codeblock```cppcin >> n;for (i32 i = 1; i <= n; ++ i) cin >> b[i];f.clear();i32 ans = f[0] = 1, delta = 0;for (i32 i = 1; i <= n; ++ i) { delta += b[i]; i32 add = (ans - f[b[i] - delta] + mod) % mod; f[b[i] - delta] = ans; ans = (ans + add) % mod;}cout << ans << '\\n';```CF 449 D简化题意给定数组 $a$，从 $a$ 选出非空子集使其按位与和结果为 $0$。求方案数设 $f_s$ 为与和为 $s$ 的方案数，$g_s$ 为与和是 $s$ 的超集的方案数。显然 $f$ 做高维后缀和就得到了 $g$。但是发现这个 $f$ 和 $g$ 都不好直接求，然后发现如果设 $h_s$ 为数列中 $s$ 的超集的数量，那么 $g_s = 2^{h_s} - 1$（从这些超集里面随便几个取并集，显然结果一定仍然是 $s$ 的超集）。然后继续发现，$h_s$ 可以对 $s$ 计数之后直接高位后缀和得到。总体流程：先对 $s$ 用桶计数，然后高维后缀和，然后 $g_s = 2^{h_s} - 1$，然后对 $g$ 反着（加法变减法）做一遍高维后缀和就好了。示例代码 child:codeblock```cppi32 f[N];i32 n;constexpr i32 mod = 1e9+7;constexpr i32 s = (1 << 20) - 1;void sos(const i64& x) { for (i32 i = 0; i < 20; ++ i) for (i32 j = s; j >= 0; -- j) if((j & (1 << i)) == 0) f[j] = (f[j] + f[j  (1 << i)] * x % mod + mod) % mod; // SOS DP}int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); i32 x; cin >> n; for (i32 i = 1; i <= n; ++ i) { cin >> x; ++f[x]; } sos(1); for (i32 i = 0; i <= s; ++ i) f[i] = binpow(f[i]) - 1; sos(-1); cout << f[0]; return 0;}```","tags":["组合数学","计数"],"categories":["题解"]},{"title":"莫比乌斯反演","path":"/post/mobius/","content":"请先去[初等数论](/post/elementary-number-theory)学习一些常用记号。\n\n## 莫比乌斯函数\n\n$\\mu(n)$\n\n- $\\mu(1)=1$\n- 对 $n$ 进行质因数分解：\n  - 分解后有相同的质因数：$\\mu(n) = 0$\n  - 分解后无相同的质因数，有 $k$ 个不同的质因数：$\\mu(n)=(-1)^k$ \n\n### 性质\n\n- $n\\in\\mathbb{N^*},\\sum_{d\\mid n}\\mu(d) = [n=1]$\n\n## 莫比乌斯反演\n\n若有 $g(n) = \\sum_{d\\mid n} f(d)$，则有 $f(n) = \\sum_{d\\mid n} f(d)\\mu(\\frac nd)$\n\n显然是狄利克雷卷积形式啊，所以可以简化一下。\n\n$$\ng(n) = \\sum_{d\\mid n} f(d) \\to f = g * \\mu\n$$\n\n### 证明\n\n我们知道，莫比乌斯函数有一个性质：$n\\in\\mathbb{N^*},\\sum_{d\\mid n}\\mu(d) = [n=1]$，换成狄利克雷卷积的形式即是 $\\mu * I = \\epsilon$。\n\n然后开始证明：\n\n已知：\n\n$$\ng(n) = \\sum _{d\\mid n}f(d)\n$$\n\n换成狄利克雷卷积形式，再在两边同时卷一个 $\\mu$\n\n$$\n\\begin{aligned}\ng &= f * I \\newline\ng * \\mu &= f * I * \\mu\n\\end{aligned}\n$$\n\n利用结合律和上面的性质就可以证明完成了。\n\n$$\n\\begin{aligned}\ng * \\mu &= f * (I * \\mu) \\newline\ng * \\mu &= f * \\epsilon \\newline\ng * \\mu &= f\n\\end{aligned}\n$$","tags":["数论","莫比乌斯反演"],"categories":["数学"]},{"title":"2023.8.10 闲话","path":"/post/diary-2023-08-10/","content":"在四机房尝试了一下双显示器（笔记本+机房显示器）\n\n机房屏幕是真大，但是 dpi 太低了。将近 1.5 倍的尺寸于我的笔记本，但是 dpi 我的笔记本是机房显示器的 1.25 倍，实际观感要差的很多。\n\n所以说啊，拯救字体渲染的最好方式还是换高 dpi 显示屏。\n\n但是我觉得微软雅黑真是一坨大便。\n\n---\n\n学习 [jijidawang](https://www.cnblogs.com/CDOI-24374) 和 [crimson000](www.cnblogs.com/crimsonawa) 进行一个推歌。\n\nMY Heart Rate —— あよ，专辑：森羅万象《シンクロ2》\n\nayo 牛逼，没得说。\n\n这首歌总能带来一些轻松的感觉呢，想必是编曲的时候考虑到灵梦日常的无聊心情吧（笑）\n\n另外，Heart Rate 用比较 Japanglish 的口音读的话，应该能发现这是 はくれい（Hakurei）的谐音。\n\n---\n\n改天需要把 dotfile 分享一下了，还有安装指南的坑没填\n\npacman 实在是太好用了\n\n---\n\n改了 T2，因为这题能体现出来长时间摆烂让我的思维脱离了“OI”。\n\n[题面](https://www.luogu.com.cn/problem/P7165)\n\n首先看到题目要求断两条边，应当能够立刻想到暴力：$n^2$ 枚举两条边。\n\n但是我他妈没想到，我直接找的重心，导致这题就算不绑包我也就过了一个点。\n\n枚举应当是最基本的东西，但是我没想到，说明我状态还没回来。  \n希望能尽快吧。\n\n然后走向玄学乱搞。\n\n这题显然不是让你找到一个点然后乱搞出分割方案的，因为要断两条边，所以找一个点的方式应当排除。\n\n考虑枚举一条边，另一条边用根号或者 $\\log$ 的时间复杂度搞出来。\n\n考虑当你枚举断掉一条边的时候，也就是拎出来了一棵子树，树的剩下的部分怎么选比较合适？显然是把它们切成一半。\n\n于是大体思路形成：dfs，到每个节点的时候将这棵树从当前节点的父边断开，然后形成了两棵树，形如 Archlabs 的 logo。\n\n![](https://pic.imgdb.cn/item/64d4f0d01ddac507cc618df0)\n\n开两个 `std::multiset<int>` 维护 dfs 过程中遍历过的所有子树的大小。\n\n为啥是两个呢，对于 $u$ 的父节点，其 $siz$ 是包含 $siz_u$ 的，所以对于 $u$ 的祖先节点的 $siz$ 需要单独维护一个集合。\n\n然后对于这两种子树，分别利用 `std::multiset<int>::lower_bound` 找到最接近该树一半大小的子树，然后比大小更新答案。大于小于不知道哪个更接近的话，两个都判一下就完事了。\n\n---\n\ntho 和 thu，一个都去不了，这就是独属于我的悲伤吧。\n\n--- \n\n闲话不够多，以后改进。","tags":["闲话"],"categories":["闲话"]},{"title":"（转载）什么是 P 问题、NP 问题和 NPC 问题","path":"/post/p-np-npc/","content":"[原文传送门](https://www.matrix67.com/blog/archives/7084)，本人对其进行了格式上的改动。\n\n这或许是众多 OIer 最大的误区之一。\n你会经常看到网上出现“这怎么做，这不是 NP 问题吗”、“这个只有搜了，这已经被证明是 NP 问题了”之类的话。你要知道，大多数人此时所说的 NP 问题其实都是指的 NPC 问题。他们没有搞清楚 NP 问题和 NPC 问题的概念。NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是 P 问题，什么是 NP 问题，什么是 NPC 问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把 NP 问题当成是 NPC 问题是一个多大的错误。\n\n还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有 $\\Theta(1)$ 的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是 $\\Theta(n)$，比如找 $n$ 个数中的最大值；而像冒泡排序、插入排序等，数据扩大 $2$ 倍，时间变慢 $4$ 倍的，属于 $\\Theta(n^2)$ 的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是 $\\Theta(a^n)$ 的指数级复杂度，甚至 $\\Theta(n!)$ 的阶乘级复杂度。不会存在 $\\Theta(2n^2)$ 的复杂度，因为前面的那个“$2$”是系数，根本不会影响到整个程序的时间增长。同样地，$\\Theta(n^3+n^2)$ 的复杂度也就是 $\\Theta(n^3)$ 的复杂度。因此，我们会说，一个 $\\Theta(0.01n^3)$ 的程序的效率比 $\\Theta(100n^2)$ 的效率低，尽管在 $n$ 很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 $\\Theta(n^3)$ 的复杂度将远远超过 $\\Theta(n^2)$。我们也说，$\\Theta(n^{100})$ 的复杂度小于 $\\Theta(1.01^n)$ 的复杂度。  \n容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是 $\\Theta(1),\\Theta(\\log n),\\Theta(n^a)$ 等，我们把它叫做多项式级的复杂度，因为它的规模 $n$ 出现在底数的位置；另一种是 $\\Theta(a^n)$ 和 $\\Theta(n!)$ 型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。\n\n自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”（Undecidable Decision Problem）。The Halting Problem 就是一个著名的不可解问题，在我的 Blog 上有过专门的介绍和证明[^1]。再比如，输出从 $1$ 到 $n$ 这 $n$ 个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton 回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做 Hamilton 回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的 NPC 问题。\n\n下面引入 P 类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题。P 是英文单词多项式的第一个字母。哪些问题是 P 类问题呢？通常 NOI 和 NOIP 不会出不属于 P 类问题的题目。我们常见到的一些信息奥赛的题目都是 P 问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。  \n接下来引入 NP 问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP 问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题。NP 问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我 RP 很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于 $100$ 个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我 RP 很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度 $98$，比 $100$ 小。于是答案出来了，存在比 $100$ 小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比 $100$ 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要 $\\Theta(n)$ 的时间复杂度，也就是说我可以花 $\\Theta(n)$ 的时间把我猜的路径的长度加出来。那么，只要我 RP 好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是 NP 问题。当然有不是 NP 问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的 Hamilton 回路是 NP 问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在 Hamilton 回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有 Hamilton 回路”。  \n之所以要定义 NP 问题，是因为通常只有 NP 问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP 问题”，实际上是在探讨 NP 问题与 P 类问题的关系。\n\n很显然，所有的 P 类问题都是 NP 问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的 NP 问题都是 P 类问题。我们可以再用集合的观点来说明。如果把所有 P 类问题归为一个集合 $\\mathbb P$ 中，把所有 NP 问题划进另一个集合 $\\mathbb {NP}$ 中，那么，显然有 $\\mathbb P \\in \\mathbb {NP}$。现在，所有对 NP 问题的研究都集中在一个问题上，即究竟是否有 $P=NP$？通常所谓的“NP 问题”，其实就一句话：证明或推翻 $P=NP$。  \nNP 问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。  \n目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，$P=NP$ 不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的 NP 问题。人们如此坚信 $P\\neq NP$ 是有原因的，就是在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也即所谓的 NPC 问题。C 是英文单词“完全”的第一个字母。正是 NPC 问题的存在，使人们相信 $P\\neq NP$。下文将花大量篇幅介绍 NPC 问题，你从中可以体会到 NPC 问题使 $P=NP$ 变得多么不可思议。\n\n为了说明 NPC 问题，我们先引入一个概念——约化（Reducibility，有的资料上叫“归约”）。  \n简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A，或者说，问题 A 可以“变成”问题 B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为 $0$。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton 回路可以约化为 TSP 问题（Travelling Salesman Problem，旅行商问题）：在 Hamilton 回路问题中，两点相连即这两点距离为 $0$，两点不直接相连则令其距离为 $1$，于是问题转化为在 TSP 问题中，是否存在一条长为 $0$ 的路径。Hamilton 回路存在当且仅当 TSP 问题中存在长为 $0$ 的回路。  \n“问题 A 可约化为问题 B”有一个重要的直观意义：B 的时间复杂度高于或者等于 A 的时间复杂度。也就是说，问题 A 不比问题 B 难。这很容易理解。既然问题 A 能用问题 B 来解决，倘若 B 的时间复杂度比 A 的时间复杂度还低了，那 A 的算法就可以改进为 B 的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。  \n很显然，约化具有一项重要的性质：约化具有传递性。如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C。这个道理非常简单，就不必阐述了。\n现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序 A 的输入，都能按这个法则变换成程序 B 的输入，使两程序的输出相同，那么我们说，问题 A 可约化为问题 B。  \n当然，我们所说的“可约化”是指的可“多项式地”约化（Polynomial-time Reducible），即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。\n\n好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的 P 和 NP 问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小 NP 问题的一个稍复杂的大 NP 问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP 问题的这样一个超级 NP 问题？答案居然是肯定的。也就是说，存在这样一个 NP 问题，所有的 NP 问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的 NP 问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的 NPC 问题，也就是 NP-完全问题。NPC 问题的出现使整个 NP 问题的研究得到了飞跃式的发展。我们有理由相信，NPC 问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于 NPC 问题”。此时，我的目的终于达到了，我已经把 NP 问题和 NPC 问题区别开了。到此为止，本文已经写了近 5000 字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。\n\nNPC 问题的定义非常简单。同时满足下面两个条件的问题就是 NPC 问题。首先，它得是一个 NP 问题；然后，所有的 NP 问题都可以约化到它。证明一个问题是 NPC 问题也很简单。先证明它至少是一个 NP 问题，再证明其中一个已知的 NPC 问题能约化到它（由约化的传递性，则 NPC 问题定义的第二条也得以满足；至于第一个 NPC 问题是怎么来的，下文将介绍），这样就可以说它是 NPC 问题了。  \n既然所有的 NP 问题都能约化成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了。因此，给 NPC 找一个多项式算法太不可思议了。因此，前文才说，“正是 NPC 问题的存在，使人们相信 $P\\neq NP$”。我们可以就此直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。\n\n顺便讲一下 NP-Hard 问题。NP-Hard 问题是这样一种问题，它满足 NPC 问题定义的第二条但不一定要满足第一条（就是说，NP-Hard 问题要比 NPC 问题的范围广）。NP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法。事实上，由于 NP-Hard 放宽了限定条件，它将有可能比所有的 NPC 问题的时间复杂度更高从而更难以解决。\n\n不要以为 NPC 问题是一纸空谈。NPC 问题是存在的。确实有这么一个非常具体的问题属于 NPC 问题。下文即将介绍它。  \n下文即将介绍逻辑电路问题。这是第一个 NPC 问题。其它的 NPC 问题都是由这个问题约化而来的。因此，逻辑电路问题是 NPC 类问题的“鼻祖”。  \n逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为 True。  \n什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。\n\n```\n┌────┐\n│IN 1├──┐  ┌────┐\n└────┘  └─→┤    │\n           │ or ├→───┐\n┌────┐  ┌─→┤    │    │  ┌────┐\n│IN 2├──┘  └────┘    └─→┤    │\n└────┘                  │ AND├──→OUT\n                  ┌────→┤    │\n┌────┐  ┌────┐    │     └────┘\n│IN 3├─→┤NOT ├─→──┘\n└────┘  └────┘\n```\n\n这是个较简单的逻辑电路，当输入 1、输入 2、输入 3 分别为 True、True、False 或 False、True、False 时，输出为 True。\n有输出无论如何都不可能为 True 的逻辑电路吗？有。下面就是一个简单的例子。\n\n```\n┌────┐\n│IN 1├→─┐  ┌────┐\n└────┘  └─→┤    │\n           │AND ├─→┐\n        ┌─→┤    │  │\n        │  └────┘  │ ┌────┐\n        │          └→┤    │\n┌────┐  │            │AND ├─→OUT\n│IN 2├→─┤ ┌────┐   ┌→┤    │\n└────┘  └→┤NOT ├→──┘ └────┘\n          └────┘\n```\n\n上面这个逻辑电路中，无论输入是什么，输出都是 False。我们就说，这个逻辑电路不存在使输出为 True 的一组输入。\n回到上文，给定一个逻辑电路，问是否存在一种输入使输出为 True，这即逻辑电路问题。\n逻辑电路问题属于 NPC 问题。这是有严格证明的。它显然属于 NP 问题，并且可以直接证明所有的 NP 问题都可以约化到它（不要以为 NP 问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个 NP 问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0 和 1 的运算），因此对于一个 NP 问题来说，问题转化为了求出满足结果为 True 的一个输入（即一个可行解）。\n\n有了第一个 NPC 问题后，一大堆 NPC 问题就出现了，因为再证明一个新的 NPC 问题只需要将一个已知的 NPC 问题约化到它就行了。后来，Hamilton 回路成了 NPC 问题，TSP 问题也成了 NPC 问题。现在被证明是 NPC 问题的有很多，任何一个找到了多项式算法的话所有的 NP 问题都可以完美解决了。因此说，正是因为 NPC 问题的存在，$P=NP$ 变得难以置信。$P=NP$ 问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。\n\n[^1]: 编者注：即停机问题。大体来说就是判断一个程序是否是死循环。本文原作者博客的证明：[传送门](https://www.matrix67.com/blog/archives/55)","categories":["杂文"]},{"title":"2023.8.5 闲话","path":"/post/diary-2023-08-05/","content":">Dear all,\n>\n>It is with a heavy heart that we have to inform you that Bram Moolenaar passed away on 3 August 2023.\n我们不得不怀着沉重的心情通知您，布拉姆·穆伦纳尔于 2023 年 8 月 3 日去世。\n>\n>Bram was suffering from a medical condition that progressed quickly over the last few weeks.\n布拉姆患有一种疾病，在过去几周里病情迅速加深。\n>\n>Bram dedicated a large part of his life to VIM and he was very proud of the VIM community that you are all part of.\nBram 将他生命中的大部分时间奉献给了 VIM，他为你们所在的 VIM 社区感到非常自豪。\n>\n>We as family are now arranging the funeral service of Bram which will take place in The Netherlands and will be held in the Dutch lanuage. The extact date, time and place are still to be determined.\n作为家人，我们现在正在安排布拉姆的葬礼。该葬礼将在荷兰以荷兰语举行。具体日期、时间和地点待定。\n>\n>Should you wish to attend his funeral then please send a message to funer...@gmail.com. This email address can also be used to get in contact with the family regarding other matters, bearing in the mind the situation we are in right now as family.\n如果您想参加他的葬礼，请给 （一个登录才能看到的邮箱地址） 发送邮件。考虑到我们现在作为家人的处境，这个电子邮件地址也可以用来与家人就其他事项取得联系。\n>\n>With kind regards,\nThe family of Bram Moolenaar\n\nVim 之父于 2023.8.3 去世。\n\n总有这样的一天的，Vim 能够挺过它多个曾经的主要开发者的离世，实际上说明了 Vim 本身的优秀性。\n\n但是，当 Linus 脱离了 Linux 的开发呢？疫情时看见 Linus 爆喷内核邮件列表里的疫苗阴谋论者，其他时候也总能看见他对待不规范不合适的 patch 坚决的态度，这确实让 Linux Kernel 仓库足够的健康。但是人总归要离开的。\n\n人世太无常了。感觉和 [Arch Linux 社区一位贡献者的去世](https://archlinux.org/news/in-memory-of-jonathon-fernyhough/)还没有多久啊...\n\n看一眼新闻，就在去年的 2 月份，Bram Moolenaar 的好友，Vim 的重要开发者&宣传者之一 Sven Guckes 因脑瘤去世，当时 Bram Moolenaar 还说要用 Vim 9 来纪念他。\n\n想成为他们那样的人，尽力地在世界上留下一些东西。于是退役前的我突然努力写博客一样。\n\n剩下的时间...多陪陪家人朋友吧。\n\n----\n\n**AGC013D**\n\n首先发现，一个取球的序列实际上就是一个合法的操作方案。\n\n能不能直接操作方案计数？发现不能。为什么？\n\n什么时候取球序列不同？仅当**每次拿出的球**不同。\n\n什么时候操作方案不同？即使取球序列是相同的，如果最初黑白球数量不同，也算不同的操作方案。\n\n设白球数量为 $n$。\n\n对于一个取球序列，它对应哪些东西呢？\n\n把操作过程中白球数量的变化画出折线图：\n![](https://cdn.luogu.com.cn/upload/image_hosting/ox2813ev.png)\n\n显然一个操作方案对应一条折线。\n\n那么让初始的 $n$ 变化一下，就相当于让这个折线上下移动。\n\n向上移动到头就是折线触碰了 $n$，向下移动到头就是折线触碰了 $0$。\n\n发现一个取球序列对应且仅对应一个折线触底的操作方案。\n\n于是可以直接统计触底方案数。\n\n具体：设 $f_{i,j,0/1}$ 为第 $i$ 次取球，箱子里有 $j$ 个白球，是/否触过底的方案数。\n\n初始化直接\n\n```cpp\nfor (i32 i = 0; i <= n; ++i)\n    f[0][i][i == 0] = 1;\n```\n就行。\n\n转移看兔队博客吧。\n\n[代码](https://www.luogu.com.cn/record/119213073)","tags":["闲话"],"categories":["闲话"]},{"title":"KMP 详解","path":"/post/KMP/","content":"今天是 8 月 4 日喵，距离退役还有 3 个月左右喵。  写字符串的时候感觉突然悟了，于是来写笔记。前缀函数实际上看了 OI Wiki 才知道有这个名词……但是也应该有，因为 KMP 只是一个匹配算法。定义约定：为了方便表示，此处字符串下标从 $1$ 开始；对于串 $X$，$X(i,j)$ 表示截取 $X$ 的 $[i,j]$ 段。对于串 $S$，其前缀函数 $P$ 为一个数组，$P_i$ 表示 $S(1,i)$ 这段前缀字符串的最长 border（不包含 $S(1,i)$ 本身）。呃，什么是 border？简单来说，串 $X$ 的一个 border 就是 $X$ 的一对相等的前缀后缀。举个例子，设 $X = \\texttt{abcssfabc}$，则 $\\texttt{abc}$ 是 $X$ 的一个 border。同样的，对于 $\\texttt{abbabba}$ 来说，存在三个 border，即 $\\texttt{a},\\texttt{abba},\\texttt{abbabba}$[^1]。好了，现在我们设 $S=\\texttt{abcabc}$，尝试一下求 $S$ 的前缀函数？如果上面的概念你还没有理解，可以直接参考下图。于是，$S$ 的前缀函数则为 $\\left[0,0,0,1,2,3\\right]$性质遇到 border 相关要对“跳 border”敏感一些。啥叫跳 border 呢？拿 $\\texttt{abbabba}$ 来举例子，假设其前缀函数为 $P$，容易求得 $P=[0,0,0,1,2,3,4]$。  末尾的 $P_7 = 4$，代表的是 $\\texttt{abba}$ 这个 border。然后就出现了一个神奇的事情：如果把该串所有合法的 border 按照长度排序，则 $\\texttt{abba}$ 的上一个 border 就是 $\\text a$。那这个 $\\texttt a$ 是什么呢？就是 $P_{P_7}$ 代表的 border 喵。换句话说，如果 $X$ 的前缀函数 $P$ 已知，则：令 $m\\gets X.length$，反复让 $m \\gets P_m$，则能够按长度从大到小遍历完原串所有的合法 border。这就是所谓“跳 border”。线性递推求前缀函数实际上如果前面的东西你都明白了，这个部分是可以轻松想出来的。以防万一，我还是写一份思考过程。假设目前位置是 $i$，$i-1$ 以及之前的 $P$ 都已知，再令 $j\\gets P_{i-1}$，想办法递推求出 $P_i$。如果红色部分是 $S(1,i)$ 的合法 border 且长度不为 $1$，则蓝色部分必然是 $S(1,i-1)$ 的合法 border。因此，我们可以枚举 $S(1,i-1)$ 的所有合法 border，看看能不能接上 $S_i$ 这个字母形成 $S(1,i)$ 的 border。遍历 border 可以采用上面说过的跳 border 实现。由于这个过程是从长到短遍历，因此找到的合法 border 必然是最长的合法 border。于是可以反复使 $j \\gets P_j$ 直到 $S(1,j+1)$ 成为 $S(1,i)$ 的合法 border。细节见代码实现。代码实现中认为下标从 $0$ 开始，`nxt` 数组即为 $P$。```cppvoid get_nxt(string& str) { for (int i = 1, j = 0; i < str.size(); ++i) { while (j && str[i - 1] != str[j]) j = nxt[j];  // 如果 border 不合法就跳，直到没 border 为止 if (str[i - 1] == str[j]) ++j;  /* 实际上上面循环完之后的 j 可能是合法 border 的结尾也有可能是无解（0），同时如果 border 合 法，需要 +1（因为跳 border 的时候跳的是之前的 border）*/ nxt[i] = j; }}```color:cyan 证明口胡一个。每次 $j$ 指针最多右移 $1$，除此以外 $j$ 指针只会左移。  容易发现右移最多 $\\Theta(n)$ 次，则左移也不会超过 $\\Theta(n)$ 次。  计算前缀函数的过程只涉及 $j$ 指针的左移右移，所以复杂度 $\\Theta(n)$。KMP 字符串匹配算法总的来说：借助前缀函数实现时空复杂度均为 $\\operatorname{O}(n+m)$ 的字符串匹配。过程和上面递推前缀函数差不多。具体来讲，为什么要借助前缀函数呢？假设我们有一个文本串 $S$，一个模式串 $T$，接下来需要找出 $S$ 中 $T$ 出现的所有位置。一旦到 $T$ 的 $i$ 这个位置匹配失败，我们难道一定就要返回 $T_1$ 从头匹配吗？并不是，我们可以利用 $T(1,i)$ 的 border 来减少匹配次数。border 的定义是“相等的前缀和后缀”，那 $T(1,i)$ 的这个后缀匹配成功，其对应的前缀也一定能匹配成功，只需要从这个前缀结束的位置继续匹配即可。做了个动画：代码：```cppfor (int i = 0, j = 0; i < s.size(); ++i) { while (j && s[i] != t[j]) j = nxt[j]; if (s[i] == t[j]) ++j; if (j == t.size()) // 匹配成功 cout << i - (int)t.size() + 2 << '\\n'; // 答案要求}```[^1]: border 在能不能包含原串这方面没有权威定义，实际上 border 这个概念就只是有一部分人在用，仅用于理解。","tags":["KMP","exKMP"],"categories":["字符串"]},{"title":"二项式反演","path":"/post/binomial-inversion/","content":"## 定义\n\n直接给出式子：\n\n$$\ng_i=\\sum_{k\\geqslant i}\\binom ki f_k \\rightarrow f_i=\\sum_{k\\geqslant i}\\binom ki (-1)^{k-i}g_k\n$$\n\n看起来不知道咋用？待会再说，我们先证明。\n\n## 证明\n\n### 前置知识\n\n[组合数学常用记号](/post/basic-combinatorics#常用记号)\n\n[二项式定理](/post/basic-combinatorics#二项式定理)\n\n### 正文\n\n已知：$g_i=\\sum_{k\\geqslant i}\\binom ki f_k$  \n求证：$f_i=\\sum_{k\\geqslant i}\\binom ki (-1)^{k-i}g_k$\n\n把求证右边那个式子单独拿出来，想办法把它导成 $f_i$。\n\n$$\n\\begin{aligned}\n&\\sum_{k\\geqslant i}\\binom ki (-1)^{k-i}g_k \\newline\n=&\\sum_{k\\geqslant i}\\binom ki (-1)^{k-i} \\sum_{j\\geqslant k}\\binom jk f_j\n\\end{aligned}\n$$\n\n把第二个求和号以及 $f_j$ 挪动一下，感性理解一下，发现最后每一项出现的次数还是不变的，所以正确。\n\n$$\n\\begin{aligned}\n&\\sum_{k\\geqslant i}\\binom ki (-1)^{k-i} \\sum_{j\\geqslant k}\\binom jk f_j \\newline\n=&\\sum_{j\\geqslant i}f_j \\sum_{j\\geqslant k \\geqslant i}\\binom jk \\binom ki (-1)^{k-i} \\newline\n=&\\sum_{j\\geqslant i}f_j \\sum_{j\\geqslant k \\geqslant i}\\frac{j!k!}{k!(j-k)!i!(k-i)!} (-1)^{k-i} \\newline\n=&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!}\\sum_{j\\geqslant k \\geqslant i}\\frac 1{(j-k)!(k-i)!} (-1)^{k-i}\n\\end{aligned}\n$$\n\n展开之后不知道怎么往下算了，想办法把那个大分式化成点什么，比如二项式（组合数）。\n\n上下同乘 $(j-i)!$，然后 $(j-k)=[(j-i)-(k-i)]$，然后就可以轻松化成组合数形式继续往下导公式了。\n\n$$\n\\begin{aligned}\n&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\sum_{j\\geqslant k \\geqslant i}\\frac 1{(j-k)!(k-i)!} (-1)^{k-i} \\newline\n=&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\sum_{j\\geqslant k \\geqslant i}\\frac {(j-i)!}{[(j-i)-(k-i)]!(k-i)!(j-i)!} (-1)^{k-i} \\newline\n=&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\sum_{j\\geqslant k \\geqslant i}\\frac {\\binom{j-i}{k-i}}{(j-i)!} (-1)^{k-i} \\newline\n\\end{aligned}\n$$\n\n换个形式\n\n$$\n\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\cdot \\frac{\\sum_{j\\geqslant k \\geqslant i } \\binom{j-i}{k-i} (-1)^{k-i}}{(j-i)!}\n$$\n\n大分式上面的分母可以用 [二项式定理](/post/basic-combinatorics#二项式定理) 处理掉。想不出来可以直接看下面式子。\n\n$$\n\\begin{aligned}\n&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\cdot \\frac{\\sum_{j\\geqslant k \\geqslant i } \\binom{j-i}{k-i} (-1)^{k-i}}{(j-i)!} \\newline\n=&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\cdot \\frac{(1-1)^{j-i}}{(j-i)!}\n\\end{aligned}\n$$\n\n右下方的分母和左侧分数扔一起是一个非常典型的组合数。\n\n$$\n\\begin{aligned}\n&\\sum_{j\\geqslant i}f_j\\frac{j!}{i!} \\cdot \\frac{(1-1)^{j-i}}{(j-i)!} \\newline\n=&\\sum_{j\\geqslant i}f_j\\binom ji 0^{j-i}\n\\end{aligned}\n$$\n\n注意，在组合数学中，$0^0=1$。  \n于是很容易地发现，求和号右边的式子值非零，当且仅当 $i=j$。\n\n于是就出来了：\n\n$$\n\\begin{aligned}\n&\\sum_{j\\geqslant i}f_j\\binom ji 0^{j-i}\\newline\n=&f_i\\binom ii 0^0 \\newline\n=&f_i\n\\end{aligned}\n$$\n\n证毕。\n\n## 例题\n\n### 分特产\n\n[题目链接](https://www.luogu.com.cn/problem/P5505)\n\n#### 题意\n\n$m$ 种特产，$n$ 个人，每种特产 $s_i$ 个。\n\n人有标号，两个特产相同当且仅当其种类相同。\n\n求让每个人都拿到至少一份特产的分配方案总数，答案对 $10^9+7$ 取模。\n\n#### 题解\n\n首先，记住开头给你的式子。\n\n然后把下面的东西看一遍，这应该是二项式反演的基本套路。\n\n大体上设两个东西，$g_i$ 和 $f_i$。这里设 $g_i$ 为**钦定** $i$ 个人不满足要求（即没有特产），其他人随意分配（可能也没有）的方案数，然后 $f_i$ 为**恰好** $i$ 个人没有特产，其他人都有特产的方案总数。\n\n然后模仿条件式，用 $f_i$ 表示 $g_i$。\n\n容易发现：\n\n1. 对于 $g_i$，每一个 $f_j,j\\in [i,n]$ 都一定被包含在里面。\n2. 对于每一个包含在里面的 $f_j$，被钦定的集合会不同，一共有 $\\binom ji$ 个，所以每个 $f_j$ 被算了 $\\binom ji$ 次。\n\n综上，$g_i = \\sum_{j=i}^n \\binom ji f_j$。\n\n二项式反演的常见入手点就是设 $g,f$。其中 $g_i$ 表示钦定集合中 $i$ 个元素满足/不满足要求，其他不管；$f_i$ 表示集合中恰好 $i$ 个元素满足/不满足要求（是否满足与 $g$ 一致）。在此之后用 $f_i$ 表示 $g_i$，二项式反演之后问题就变化成了求 $g$。\n\n然后大力二项式反演，套一下式子就能得出来：\n\n$$\nf_i = \\sum_{j=i}^n \\binom ji g_j (-1)^{j-i}\n$$\n\n答案就是恰好没有不合法元素的方案总数，于是：\n\n$$\n\\begin{aligned}\nans &= f_0 \\newline\n&= \\sum_{j=0}^n \\binom j0 g_j (-1)^{j-0} \\newline\n&= \\sum_{j=0}^n g_j (-1)^j\n\\end{aligned}\n$$\n\n问题被转化成了求 $g$。\n\n假设目前正在求 $g_i$，显然只需要有 $n-i$ 个人需要考虑。由于剩下 $i-1$ 是钦定不合法的，我们不用考虑；但是非常魔法的事情来了：由于这 $n-i$ 个人是随便排列的，我们只需要把特产随意分发就行。\n\n怎么个随意分发法？对于每一种特产 $x$，可以转化为：有 $s_x$ 个无标号小球，装进 $n-i$ 个有标号盒子里的方案数。直接插板法解决就好啦！显然有 $s_x-1$ 个空，除此以外，盒子可以为空，所以就是 $s_x-1$ 加 $n-i$ 个空，插 $n-i-1$ 个板的方案数，即 $\\binom{s_x-1+n-i}{n-i-1}$。\n\n每一种特产的分配方案数互不影响，所以乘起来；同时 $n$ 个人里面选出来 $i$ 个钦定不合法，再乘一个 $\\binom ni$，即：\n\n$$\ng_i = \\binom ni \\prod_{j=1}^m \\binom{s_x-1+n-i}{n-i-1}\n$$\n\n然后代入上面计算答案的式子算就完了。\n\n#### 代码\n\n```cpp\n#include <iostream>\n\nusing std::cin;\nusing std::cout;\n\nnamespace tkgs {\n    using i32 = int;\n    using i64 = long long;\n    const i64 mod = 1e9 + 7;\n\n#define N 1005\n#define NUM 2005\n    namespace mat {\n        i64 x, y, tmp;\n        void exgcd(const i64& a, const i64& b) {\n            if (!b) {\n                x = 1, y = 0;\n            } else {\n                exgcd(b, a % b);\n                tmp = x;\n                x = y;\n                y = tmp - a / b * y;\n            }\n        }\n\n        i64 inv(const i64& a, const i64& b) {\n            exgcd(a, b);\n            return x;\n        }\n\n        i64 fact[NUM], ifact[NUM];\n\n        void init() {\n            const i32 n = 2000;\n            fact[0] = ifact[0] = 1;\n            for (i32 i = 1; i <= n; ++i)\n                fact[i] = fact[i - 1] * i % mod;\n            ifact[n] = inv(fact[n], mod);\n            for (i32 i = n - 1; i; --i)\n                ifact[i] = ifact[i + 1] * (i + 1) % mod;\n        }\n\n        i64 getC(i32 a, i32 b) {\n            if (a < b)\n                return 0;\n            else\n                return fact[a] * ifact[b] % mod * ifact[a - b] % mod;\n        }\n    }  // namespace mat 实现了初始化阶乘与阶乘逆元，求组合数\n\n    i32 s[N], n, m;\n\n    i64 g(i64 i) {\n        i64 res = 1;\n        for (i32 j = 1; j <= m; ++j)\n            res = res * mat::getC(s[j] + n - i - 1, n - i - 1) % mod;\n        res = res * mat::getC(n, i) % mod;\n        return res;\n    }\n\n    void main() {\n        cin >> n >> m;\n        for (i32 i = 1; i <= m; ++i)\n            cin >> s[i];\n        mat::init();\n        i64 ans = 0;\n        for (i32 j = 0; j < n; ++j)\n            (ans += g(j) * ((j & 1) ? -1 : 1)) %= mod;\n        cout << (ans % mod + mod) % mod;\n    }\n}  // namespace tkgs\n\nint main() {\n    tkgs::main();\n    return 0;\n}\n```\n\n### [ABC309G](/post/abc309g-solution)","tags":["组合数学","容斥","二项式反演"],"categories":["数学"]},{"title":"ABC309G Ban Permutation 题解","path":"/post/abc309g-solution/","content":"## 前置知识\n\n- 二项式反演（以后会补上笔记的！）\n- 状压 DP\n\n## 符号约定\n\n$\\lor$ 为逻辑或，相当于 C++ 中的 `|` 运算符。\n\n## 题意简化\n\n求 $n$ 的排列 $P$ 的方案数，要求 $\\lvert P_i - i \\rvert \\geqslant X$。\n\n## 分析\n\n排列问题有点抽象，于是有套路：把一个排列看成 $n\\times n$ 的棋盘上放车的方案——数字 $p_i$ 在 $i$ 的位置上，相当于棋盘的 $(i,p_i)$ 位置放了一个车。显然 $i,p_i$ 都不会重复，所以正确。\n\n然后发现是个计数题，给出了**不合法**的条件，而且条件与位置相关，往二项式反演方向思考。\n\n按照套路，设 $g_i$ 为钦定 $i$ 个数不合法，其他随便排的方案数，$f_i$ 为恰好 $i$ 个数不合法的方案数。发现每个 $g_i$ 包含 $f_j,j\\in[i,n]$，然后每次选择不同的 $i$ 个数进行钦定，所以一个 $f_j$ 要算 $\\binom ji$ 次。于是有：\n\n$$\ng_i=\\sum_{j=i}^n f_i \\binom ji\n$$\n\n脸上都写上二项式反演这五个字了，套一下式子，有：\n\n$$\nf_i = \\sum_{j=i}^n(-1)^{j-i}\\binom ji g_j\n$$\n\n答案即为：\n\n$$\n\\begin{aligned}\nans &= f_0 \\newline\n    &= \\sum_{j=0}^n(-1)^{j-0}\\binom j0 g_j \\newline\n    &= \\sum_{j=0}^n(-1)^j g_j\n\\end{aligned}\n$$\n\n考虑怎么求 $g_i$。\n\n回过头来看不合法的条件：$\\lvert P_i - i \\rvert < X$，转化为 $P_i$ 这个棋子不能放在 $[i-X+1,i+X-1]$ 这些横行上。\n\n发现 $X\\leqslant 5$，非常小，也许可以状压？结合上面的转化，如果要状压的话，状态可以直接表示 $[i-X+1,i+X-1]$ 中不合法棋子的集合。\n\n然后 DP 状态设计就有了（这里我们开出来一个新的 $f$ 数组）：$f_{i,j,s}$ 表示棋盘前 $i$ 行，放了 $j$ 个不合法棋子，状态为 $s$ 的方案数量。\n\n怎么转移？假设当前是 $f_{i,j,s}$，然后分类讨论：\n\n- 不放新的不合法棋子。\n  发现这种情况下转移到 $i+1$ 时，新状态就是 $s$ 右移一位，即 $2^{-1}s$。\n  为了方便，我们设这个状态为 $ns$，表示什么都不放时转移到 $i+1$ 时的状态。\n  转移方程也就简单了：$f_{i,j,ns} \\gets (f_{i,j,ns}+f_{i,j,s})$\n- 放新的不合法棋子。\n  可以枚举一下这个不合法棋子能放到的位置（就是 $[i-X+1,i+X-1]$ 区间的空位），直接转移即可。但是注意，当前要做的是向后转移，所以应当枚举的是 $ns$ 这个状态的空位。假设 $p$ 是一个空位，则有转移方程：$f_{i,j,(ns\\lor 2^p)} \\gets (f_{i,j,(ns\\lor 2^p)}+f_{i,j,s})$。\n\n对于 $g_i$，由于是钦定了 $i$ 个位置不合法，其他位置随便排，所以我们对 $f_{n,i,s}$ 枚举 $s$ 求和之后，还要乘一个 $(n-i)!$ 满足“剩下位置随便排列”的要求。\n\n按照前面 $ans$ 的式子求和即可。\n\n时间复杂度 $\\operatorname\\Theta(4^Xn^2)$。\n\nCode:\n\n```rust\nuse std::io;\n\nfn valid(pos: usize, i: usize, n: usize, x: usize) -> bool {\n    ((i + pos + 1 - x) <= n && (i + pos + 1 - x) > 0) as bool\n}\n\nfn main() {\n    const MD: usize = 998244353;\n    const N: usize = 205;\n    const ST: usize = 600;\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut s = input.trim().split(' ');\n\n    let n: usize = s.next().unwrap().parse().unwrap();\n    let x: usize = s.next().unwrap().parse().unwrap();\n\n    let mut f = [[[0; ST]; N]; N];\n\n    let mxst: usize = (1 << ((x << 1) - 2 + 1)) - 1; // 区间长度本来是 (x << 1) - 2，但是还要包含 i 本身，所以 + 1\n\n    f[0][0][0] = 1;\n    for i in 1..=n {\n        for j in 0..=i - 1 {\n            for s in 0..=mxst {\n                let ns: usize = s >> 1;\n                f[i][j][ns] = (f[i][j][ns] + f[i - 1][j][s]) % MD;\n                for p in 0..=(x << 1) - 2 {\n                    if ((1 << p) & ns) == 0 && valid(p, i, n, x) {\n                        f[i][j + 1][ns | (1 << p)] =\n                            (f[i][j + 1][ns | (1 << p)] + f[i - 1][j][s]) % MD\n                    }\n                }\n            }\n        }\n    }\n\n    let mut fact = [0; N];\n    fact[0] = 1;\n    for i in 1..=n {\n        fact[i] = fact[i - 1] * i % MD;\n    }\n\n    let mut ans: i64 = 0;\n    for i in 0..=n {\n        for s in 0..=mxst {\n            if i & 1 == 1 {\n                ans -= (f[n][i][s] * fact[n - i] % MD) as i64;\n            } else {\n                ans += (f[n][i][s] * fact[n - i] % MD) as i64;\n            }\n            ans %= MD as i64;\n        }\n    }\n    ans = (ans % MD as i64 + MD as i64) % MD as i64;\n    println!(\"{}\", ans);\n}\n```","tags":["组合数学","容斥","二项式反演"],"categories":["题解"]},{"title":"AMD P-STATE 折腾历程","path":"/post/amd-p-state-honor/","content":"## 介绍\n\n> `amd-pstate` 是 AMD CPU 性能扩展驱动程序，它在 Linux 内核的现代 AMD APU 和 CPU 系列上引入了新的 CPU 频率控制机制。新机制基于协作处理器性能控制 (CPPC)，它提供比传统 ACPI 硬件 P-States 更精细的频率管理。当前的 AMD CPU/APU 平台使用 ACPI P-states 驱动程序来管理 CPU 频率和时钟，仅在 3 个 P-states 中切换。 CPPC 取代了 ACPI P-states 控件，并允许 Linux 内核使用灵活、低延迟的接口直接将性能提示传达给硬件 （摘自 [Kernel Docs](https://www.kernel.org/doc/html/latest/admin-guide/pm/amd-pstate.html#:~:text=amd-pstate%20is%20the%20AMD%20CPU%20performance%20scaling%20driver,grain%20frequency%20management%20than%20legacy%20ACPI%20hardware%20P-States.)）\n\n## 折腾\n\n这玩意支持 AMD ZEN 2 和更新版本，我的荣耀本使用 R7-4800H，理论上可以跑，于是按照 [Aya 的博客](https://note.ay1.us/#/15-amd-cpufreq) 添加了内核参数\n\n```SHELL\n$ zfs set org.zfsbootmenu:commandline=\"rw amd_pstate=passive\" zroot/ROOT\n```\n\n然后就没管了。\n\n有一天忘记从哪里又看见了 AMD P-State，然后发现一个验证方法，跑了一下：\n\n```bash\n$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver\n\nacpi-cpufreq\n```\n\n我去，这我可忍不了。于是我先检查内核 module 有没有 AMD P-State 存在，结果是没有。但是检查内核 config\n\n```bash\n$ zcat /proc/config.gz | grep PSTATE\n\nCONFIG_X86_AMD_PSTATE=y\n```\n\n那得了，这玩意都 built-in 了咋可能不存在？于是检查日志：\n\n```bash\n$ journalctl -b 0 | grep pstate\n```\n\n~~经过群友提醒，我使用翻译发现第一次设置的 passive 可能出了些幽灵字符导致无法识别，再设置一次才出现了根本问题~~\n\n得到\n\n```log\n_CPC object is not present in SBIOS\n```\n\n哈哈荣耀操你妈的，这问题不就一眼顶针了？傻逼厂商的傻逼主板又没有把 CPPC 的选项留给我自己设置捏。\n\ntg 群里：  \n我：好像是硬件的问题，傻逼荣耀。  \n群友：试试 [Smokeless_UMAF](https://github.com/DavidS95/Smokeless_UMAF)？discussion 里有 CPPC 相关的东西。\n\n随后我想起来当时用 Smokeless_UMAF 把傻逼荣耀设置的 512M 显存干到 4G 的过程，心想这玩意也能设置？事实上，是的。\n\n我手上有一个现成的 ventoy 盘，于是直接拿来使用，扔进去 [为 ventoy 提前制作好的 img 镜像](https://github.com/mio-19/UniversalAMDFormBrowser-Ventoy) 就能启动了。\n\n另外提醒一句，UMAF 基于一个漏洞，这个漏洞貌似联想在去年三月份就修复了，所以不一定能正常启动。蛤蛤，但是傻逼荣耀已经三年没更新过任何驱动了，所以我怕个吊，直接开干。  \n同时，这玩意不开源，恶意代码存在可能性待议，但是利用漏洞 Hack 主板设置肯定有变砖的风险存在。因此 USE AT YOUR OWN RISK。有条件的建议备份一下 BIOS（有刷写工具的情况下），或者直接买~~六七个~~ BIOS 芯片，坏了直接换上。\n\n但是我电脑太冷门了，没有卖的，手上还没有刷写工具，但是保修期内，大不了送回去修，我还有机房电脑可以用。\n\n按照 [discussion #29](https://github.com/DavidS95/Smokeless_UMAF/discussions/29#discussioncomment-6143331) 的做法，进入 Device Manager - AMD CBS - NBIO - SMU page，启用 CPPC，直接一路 esc 出来，它会提醒你选择是否保存，保存后会直接重启。\n\n再次\n\n```bash\n$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver\n\namd-pstate\n```\n\n就这样，没了，感谢阅读。","tags":["内核"],"categories":["Linux"]},{"title":"AC 自动机","path":"/post/ac-automaton/","content":"真的比 KMP 简单！（指好理解）\n\n## 前置知识\n\ntrie 树（必会）  \nKMP（知道一点思想就行，不用详细学习）\n\n## 用途\n\n我们知道 KMP 能够 $\\operatorname{O}(|T|+|S|)$ 匹配单个文本串 $T$ 与模式串 $S$。但是如果有 $n \\leq 10^5$ 个模式串（小串）匹配一个文本串（大串）呢？AC 自动机能够在 $\\operatorname{O}(|T|+\\sum |S|)$ 的复杂度内求出每一个模式串的出现次数。\n\n核心思想和 KMP 相似，除去多余的匹配，即在当前匹配状态的基础上转移着匹配。（我也不知道我说了啥）\n\n## 基本结构\n\n多个模式串，先去重前缀，建立前缀树（即 trie 树）。\n假设我们当前有四个模式串：$\\texttt{abc,ac,bc,bd}$\n\n![](https://pic.imgdb.cn/item/64813e2a1ddac507cc19c8df)\n\n对每个模式串终止字符记录其出现的次数作为其在 trie 树上对应节点的权值，然后遍历文本串的每一个字符，在 trie 树上向下走，$ans$ 加上当前点的权值，如果走不了了就把文本串的当前指针回跳到上一个有多个子节点的节点，从 trie 树根节点继续匹配。（当然这个不重要，理解不理解无所谓）（理解不了就自己匹配一下试试）\n\n合并了一些模式串的前缀，于是有了一定优化，但是优化还不够，考虑对后缀优化。\n\n## fail 边\n\n### 含义\n\nAC 自动机的核心就是 fail 边。\n\nfail 边的含义：如果 $u$ 点的 fail 边指向 $v$，则 $v$ 点所代表的字符串[^1]是 $u$ 点所代表的字符串的后缀，且前者是除后者自身以外满足要求的最长字符串。\n\n先不管怎样建 fail 边，按照要求人脑建立一下，如下图：\n\n![](https://pic.imgdb.cn/item/648140721ddac507cc1d77e5)\n\n然后假设有文本串 $\\texttt{abc}$，进行匹配。\n\n为什么上一次匹配的时候，我们需要把文本串的指针回跳？因为没有办法除去后缀的影响——一个模式串是另一个模式串的后缀，或前者的一部分是后者的后缀。意味着：后者匹配失败不代表前者也会匹配失败。于是我们可以记录一下合法后缀，如果匹配失败就跳到自己最长后缀所在节点上（没有的话就跳根节点），容易发现这样一直跳下去，能把最开始的串的合法后缀全部跳完！说明后缀的影响已经排除掉了。\n\n为了方便，我们把没有合法后缀的节点的 fail 边指向根节点。\n\n![](https://pic.imgdb.cn/item/6481466b1ddac507cc291a6d)\n\n实际上此时的 fail 边的含义：无法向下一个子节点匹配（没有子节点或匹配失败）时要走的边。\n\n动画演示：\n\n![](https://pic.imgdb.cn/item/64814ec31ddac507cc38599e)\n\n### 建立\n\nBFS 的过程。\n\n1. 第一层（根节点为第零层）的 fail 全部指向根节点[^2]，压入队列。\n\n2. 取出队头，遍历子节点，如果子节点存在，假设这个子节点代表字符 $c$，当前节点 fail 指针指向 $lf$，$lf$ 的子节点集合为 $son$，则将其 fail 指针指向 $son_c$。\n\n没了。\n\n## 优化\n\n我们一般把 trie 树的一个节点的儿子用长度为 26 的数组存下，导致遍历子节点的时候会遍历到傻逼空节点。\n\n对于当前节点的空子节点指针，可以直接指向当前 fail 指针指向的节点的子节点集合中，对应的子节点。\n\n参考代码：\n\n```cpp\nvoid build() {\n    std::queue<i32> q;\n    for (i32 i = 0; i < 26; ++i)\n        if (trie[0].son[i]) q.push(trie[0].son[i]);\n    while (!q.empty()) {\n        i32 nod = q.front(), lfail = trie[q.front()].fail; // 当前节点和当前节点的 fail 节点\n        q.pop();\n        for (i32 i = 0; i < 26; ++i) {\n            i32& to = trie[nod].son[i];\n            if (to) {\n                trie[to].fail = trie[lfail].son[i];\n                q.push(to);\n            } else\n                to = trie[lfail].son[i]; // 节点为空\n        }\n    }\n}\n```\n\n[^1]: 字典树上除根节点外的每一个节点到根的路径都代表一个字符串。\n[^2]: 模拟一下会发现：如果 fail 还按照正常情况定义来建的话会死循环。","tags":["AC 自动机"],"categories":["字符串"]},{"title":"SPOJ 4060 题解","path":"/post/spoj-4060-solution/","content":"## 题意\n\n给定一定数量的石子，两个人抛硬币，抛到正面则拿走一颗石子，否则什么都不做。拿走最后一颗石子的人胜利。  \n已知石子数量，假设双方都采用最优方案，两个人分别抛到自己想要的那一面的概率分别为 $0.5 \\leqslant q,p < 1$ ~~这不唯物~~，求先手的获胜概率。\n\n## 题解\n\n要点：对概率的熟悉程度，对 DP 的熟练程度，奇怪的缩小数据范围的方法\n\n首先考虑直接硬算，发现希望掷得的面会变化，没法直接算，考虑 DP。\n\n### 设计状态\n\n- 表示出当前到达第几颗石子\n- 表示出当前谁拿石子\n\n于是得到状态：$f_{i,0/1}$ 表示 $i$ 个石子，第 $1$ 或第 $2$ 个人获胜的概率\n\n显然 $f_{0,0}$ 和 $f_{0,1}$ 是两种确定结果，则概率分别为 $1,0$。于是考虑倒推。\n\n看概率的取值，说明只要我们希望抛到一个面，抛到这个面概率就会更大。  \n由于很容易判断出当前状态下应该希望取得/不取得石子（通过前一个状态的概率大小），所以不用单独表示出希望取得/不取得石子。\n\n状态是否可行？根据 lzp 大佬的教诲，我们需要判断该状态：\n\n- 是否能表示单独状态：显然可以，上面解释过了。\n- 是否可递推：直觉是可以递推，但是需要列柿子看一下\n\n### 转移方程\n\n开始写柿子：  \n希望取得这颗石子（正面）：\n\n$$\n\\begin{aligned}\nf_{i,0} &= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p)\n\\newline\nf_{i,1} &= f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q)\n\\end {aligned}\n$$\n\n发现这玩意没法递推，但是发现可以运用初中二元一次方程的思路，代入消元。\n\n$$\n\\begin{aligned}\nf_{i,0} &= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p) \\newline\nf_{i,0} &= f_{i-1,1} \\cdot p + (f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q))(1-p) \\newline\nf_{i,0} &= f_{i-1,1} \\cdot p + f_{i-1,0}\\cdot (1-p)q + f_{i,0} \\cdot (1-q)(1-p) \\newline\n(1-(1-q)(1-p))f_{i,0} &= f_{i-1,1} \\cdot p + f_{i-1,0}\\cdot (1-p)q \\newline\nf_{i,0} &= \\frac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,0}}{1-(1-q)(1-p)}\n\\end{aligned}\n$$\n\n发现这玩意就可以递推了，再依照同样的方式能够列出 $f_{i,1}$ 的转移方程和不希望取得这颗石子的两个转移方程。不再赘述过程（基本上和上面完全一样），给出柿子\n希望取得：\n\n$$\n\\begin{aligned}\nf_{i,0} &= \\frac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,0}}{1-(1-q)(1-p)} \\newline\nf_{i,1} &= \\frac {q\\cdot f_{i-1,0} + (1-q)p\\cdot f_{i-1,1}}{1-(1-p)(1-q)}\n\\end {aligned}\n$$\n\n不希望取得：\n\n$$\n\\begin{aligned}\nf_{i,0} = \\frac{p(1-q)\\cdot f_{i-1,0} + (1-p)\\cdot f_{i-1,1}}{1-qp} \\newline\nf_{i,1} = \\frac{q(1-p)\\cdot f_{i-1,1} + (1-q)\\cdot f_{i-1,0}}{1-qp}\n\\end{aligned}\n$$\n\n对比一下容易发现：希望取得与不希望取得的转移方程中，区别仅仅是 $p,(1-p)$ 和 $q,(1-q)$。于是，当取石子比不取石子优的时候，把 $p,q$ 把 $1$ 减一下就行了。\n\n于是 DP 部分解决，复杂度 $\\operatorname{O}(n)$\n\n### 优化\n\n但是题目中 $n$ 的范围比较申必，$n \\leqslant 10^9-1$，还有多测，显然过不了。怎么办？开始考虑减少递推次数\n\n- “自身简化专业玄 —— lzp” 矩阵快速幂之类的优化...不好评价，转移方程貌似有点巨大；单调队列或者斜率？已经线性了，这种方法貌似没啥用。\n- 概率还可以考虑是否会出现**趋于稳定**的情况。可以打表测一下~~（或者提交试一下）~~，~~试一下发现确实可以~~  \n  $n = \\min(n,100)$ 即可。\n\n### 易错提示\n\n1. 要确定好自己选择的是正推还是逆推。（从这个状态推到下一个状态还是从上一个状态推到当前状态），换句话说，注意 $i-1,i,i+1$ 的区别。\n2. 要确定好自己递推使用的是哪一个柿子，不要写反（谁因为这个调了半天我不说\n\n## 示例代码\n\n不得不说 rust 某些方面比 C++ 严格，读入也比较麻烦，但是从另一方面来说非常人性化...\n\n```rust\nuse std::io;\n\nfn solution() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut lis = input.trim().split(' ');\n\n    let mut n: usize = lis.next().unwrap().parse().unwrap();\n    let p: f64 = lis.next().unwrap().parse().unwrap();\n    let q: f64 = lis.next().unwrap().parse().unwrap();\n\n    let mut f: [Vec<f64>; 2] = [Vec::new(), Vec::new()];\n\n    if n > 100 {\n        // 推到第 100 个石子就够了\n        n = 100;\n    }\n\n    f[0].push(0.0);\n    f[1].push(1.0);\n\n    for i in 1..=n {\n        let mut pnow = p;\n        let mut qnow = q;\n        if f[1][i - 1] > f[0][i - 1] {\n            // 如果上一颗石子不应当让自己取\n            // 这里取不取等号无所谓\n            pnow = 1.0 - p;\n            qnow = 1.0 - q;\n        }\n        f[0].push(\n            (pnow * (1.0 - qnow) * f[0][i - 1] + (1.0 - pnow) * f[1][i - 1]) / (1.0 - pnow * qnow),\n        );\n        f[1].push(\n            (qnow * (1.0 - pnow) * f[1][i - 1] + (1.0 - qnow) * f[0][i - 1]) / (1.0 - pnow * qnow),\n        );\n    }\n\n    println!(\"{}\", f[0][n]);\n}\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut s = input.trim().split(' ');\n    let mut t: i32 = s.next().unwrap().parse().unwrap();\n    while t != 0 {\n        solution();\n        t -= 1;\n    }\n}\n```","tags":["概率"],"categories":["题解"]},{"title":"概率杂题","path":"/post/probability-misc-questions/","content":"## [P4562 [JXOI2018]游戏](https://www.luogu.com.cn/problem/P4562)\n\n给定区间 $[l,r]$，每次选择一个未选择过的数，将这个数以及它的所有倍数标记，每一种方案全部标记所用次数记为 $t$，求所有可能 $t$ 的和。\n\n首先想到每次将所有点标记的实质，就是将 $\\left[l,r\\right]$ 中**没有**在**此区间内**的**非自身的因数**的数标记完。称这样的数为关键数，设关键数有 $k$ 个，则实际上标记次数就是**最后一个关键数**的位置。\n\n最后一个关键数的位置...不沾头不沾尾，所以换个方向考虑——最后一个关键数的位置可以替换为**它后面的非关键数的数量**。\n\n实际上，$k$ 个关键数把整个区间分成了 $k+1$ 份。设区间长度为 $1$，则一个非关键数在最后一段区间上的期望就是 $\\cfrac 1 {k+1}$（$k+1$ 种情况，每种情况都在段区间上，只有一种情况在目标区间上），$n-k$ 个非关键点在最后一段区间上的期望就是 $\\cfrac{n-k}{k+1}$。（注意这里概率到期望的转换，要想想为什么期望成了求解目标）\n\n于是，最后一个点的位置的期望，即 $t$ 的期望为下式\n\n$$\n\\begin{aligned}\n&\\ \\ \\ \\ \\  n-\\cfrac{n-k}{k+1} \\newline\n&= \\cfrac{nk+n-n+k}{k+1} \\newline\n&= \\cfrac{(n+1)k}{k+1}\n\\end{aligned}\n$$\n\n求所有可能的 $t$ 的值的和，乘一个阶乘就好了。\n\n$$\n\\begin{aligned}\n&\\ \\ \\ \\ \\  \\cfrac{(n+1)k}{k+1}n! \\newline\n&= \\cfrac{k}{k+1}(n+1)!\n\\end{aligned}\n$$\n\n取模的话，求完阶乘 $\\times k$ 再乘个 [逆元](/post/multi-inverse-element) 就行了。\n\n## [P4284 [SHOI2014] 概率充电器](https://www.luogu.com.cn/problem/P4284)\n\n给定一棵树，每条边能导电的概率为 $p_i$，每个点自己带电的概率为 $q_i$，求带电点个数的期望。\n\n根据期望的线性性，考虑求每个点有电的期望。因为只有 $0,1$ 两种情况，因此求概率就行了。\n\n考虑单个点有电的情况：\n\n- 自己有电\n- 儿子有电，和儿子连边导电\n- 父亲有电，和父亲连边导电\n\n设 $f_u$ 为点 $u$ 带电的期望：\n\n- 第一种情况的概率就是 $q_u$，所以直接 $f_u = q_u$ 就行。\n- 第二种情况非常像树形 DP 的样子，容易想到从叶子节点向上推就行。\n  - 考虑两个独立事件发生其中一件即可的概率： $P(A+B)=P(A)+(1-P(A))P(B)$，即 $A$ 事件的概率 $+$ $(B$ 事件 $+$ $A$ 事件未发生 $)$ 的概率。\n  - 进行 dfs，回溯的时候统计：\n    - 设当前点为 $u$，儿子为 $v$，则有 $f_u = f_u + (1-f_u)p_{u,v}f_v$\n- 第三种情况实际上也是树形 DP，只不过变成了正推，从 $u$ 计算对 $v$ 的贡献。\n  - 假设当前到达 $u$，且 $f_u$ 已经算好了，考虑如何把贡献传给 $f_v$。\n  - 容易想到 $u$ 能贡献给 $v$ 电流的那部分概率，实际上是 $f_u$ 扔掉 $v$ 这棵子树的部分。\n  - 换句话说，贡献 $=$ $u$ 有电的概率 $-$ $u$ 不考虑 $v$ 的有电的概率，再乘边的概率之类的常数即可。\n  - 设 $\\langle u,v \\rangle=e$，$u$ 不考虑 $v$ 的有电的概率为 $g_u$，$v$ 只考虑下方来电有电的概率为 $l_v$，有柿子：\n    $$\n    \\begin{aligned}\n    f_u &= g_u + l_vp_e(1-g_u) \\newline\n    f_u &= g_u + l_vp_e-l_vp_eg_u \\newline\n    f_u - l_vp_e &= g_u(1-l_vp_e) \\newline\n    g_u &= \\cfrac {f_u-l_vp_e}{1-l_vp_e} \\newline\n    f_u - g_u &= f_u - \\cfrac {f_u-l_vp_e}{1-l_vp_e}\n    \\end{aligned}\n    $$\n  - 考虑完 $u$ 有电的贡献，乘一下边的概率和 $v$ 没电的概率就行了\n    $$\n    f_v = f_v + (1-f_v)\\cdot p_e \\cdot(f_u - \\cfrac {f_u-l_vp_e}{1-l_vp_e})\n    $$\n\n柿子推完了，写两个 dfs 算答案即可。\n\n## SPOJ 4060 KPGAME\n\n[传送门](/post/spoj-4060-solution)\n\n## CF 1316 F\n\n又是一个重量级题目。\n\n首先我们发现他这个数列是假的，因为求权值的时候是“排序”后再求，子序列也不需要连续，所以我们直接把它当一个数的集合做，不需要维护他们在原数列中的顺序。下面所说的下标都是排序后的下标。\n\n好，接下来考虑一个点对对期望的贡献。  \n假设有点对 $a_i,a_j,i<j$，显然权值的贡献是 $a_ia_j$。  \n然后来看概率，由于是相邻的，所以能随便挑选的只有 $i$ 左边，$j$ 右边的点，总共有 $(i-1)+(m-j)$ 个，满足两个点相邻的子序列数量即为 $2^{(i-1)+(m-j)}$，而子序列的总数有 $2^n$ 个。因此，这两个点相邻的概率为：\n\n$$\n\\frac {2^{(i-1)+(m-j)}}{2^n} = \\frac {1}{2^{n-i+1-j-n}} = \\frac 1{2^{j-i+1}}\n$$\n\n于是得出点对 $a_i,a_j,i<j$ 对期望的贡献：$\\frac {a_ia_j}{2^{j-i+1}}$。\n\n然后给定一个数列，其权值的期望直接枚举点对计算就是答案：$\\sum_{i=1}^n \\sum_{j=i+1}^n \\frac {a_ia_j}{2^{j-i+1}}$。\n\n但是这玩意带单点修改，直接用这个式子的话就是一个非常优秀的 $\\Theta(qn^2)$ 的做法。\n\n单点修改。考虑分治。\n\n把一个序列分成两段：$[1,m],[m+1,n]$，那它的贡献可以分成三部分：\n\n- $[1,m]$ 的贡献\n- $[m+1,n]$ 的贡献\n- 跨越两个区间的点对的贡献\n\n前两个可以分治解决，问题在于第三个东西。  \n首先这个东西的式子是很好写的：$\\sum_{i=1}^m \\sum_{j=m+1}^n \\frac {a_ia_j}{2^{j-i+1}}$  \n为了分治，我们得把这个式子拆成左右两半。欸，这 $1\\sim m$ 和 $m+1\\sim n$ 根本就没交集，那就直接拆开就好了！\n\n$$\n\\begin{aligned}\n&\\ \\ \\ \\ \\ \\sum_{i=1}^m \\sum_{j=m+1}^n \\frac {a_ia_j}{2^{j-i+1}} \\newline\n&= \\sum_{i=1}^m \\sum_{j=m+1}^n \\frac {a_ia_j}{2^{j-m+m-i+1}} \\newline\n&= (\\sum_{i=1}^m \\frac {a_i}{2^{m-i+1}})(\\sum_{j=m+1}^n \\frac {a_j}{2^{j-m}})\n\\end{aligned}\n$$\n\n然后我们就可以直接分治解决了。\n\n设一个区间的答案为 $f$，上面拆成的两个部分一个是 $ls$ 一个是 $rs$，$len(x,y) = y-x+1$ 表示一个区间的长度。\n\n对于一个区间 $[l,r]$，有如下一堆东西：\n\n$$\n\\begin{cases}\nf(i,i) = 0 \\newline\nls(i,i) = rs(i,i) = 1 \\newline\nf(l,r) = f(l,m) + f(m+1,r) + ls(l,m)rs(m+1,r)\\newline\nls(l,r) = ls(l,m) + \\frac {rs(m+1,r)}{2^{len(l,m)}} \\newline\nrs(l,r) = rs(m+1,r) + \\frac {rs(l,m)}{2^{len(m+1,r)}}\n\\end{cases}\n$$\n\n最终答案是 $f(1,n)$。\n\n这样的分治，最终复杂度是 $\\Theta(qn)$ 的，还是不够。\n\n这个分治实际上很容易用线段树维护，但是修改权值怎么办？答案是使用权值线段树。\n\n我们将询问离线下来，把原数列和询问中的数字全部离散化，然后存到权值线段树里面,**这样显然就把排序的部分做完了**。  \n然后对于每个线段树节点，维护当前区间里面的**有效点个数**，以及上面那一堆东西，但是 $len$ 就可以替换成刚才提到的点数了。\n\n`push_up` 就用上面的式子就好。\n\n这样的做法时间复杂度为 $\\Theta(n+q\\log n)$，非常能过。\n\n但是另一个细节的点来了：离散化。由于两个相同的数作为点对也会产生贡献，所以在离散化的时候给他们分配不同的编号。","tags":["概率"],"categories":["题解"]},{"title":"最大流要点","path":"/post/ff-network-maxflow/","content":"## 什么是最大流问题\n\n总体是一张有向图，定一个源点，一个汇点。单位时间内源点能流出无限水，汇点能接受无限水。图中每条边相当于一个单位时间流量有限的管道。\n\n最大流问题：单位时间内汇点最多能接收到多少水流？\n\n## 解法\n\n考虑贪心去做：反复 dfs 找到仍能流水的一条从源点到汇点的路径，路径中每个边的容量减去路径的最小容量（水管模型能流多少显然受最小容量限制吧...）。  \n但是好像不太对，有可能当前的一个流让它从另一个路径流出去更合适，借鉴反悔贪心的思想，我们可以给每条边加一条反向边。当一条边的容量被占据了 $f$ 时，其容量减去 $f$，然后给它的反向边加上 $f$。\n\n![](https://pic.imgdb.cn/item/6496477d1ddac507cce1334e.jpg)\n\n上面只是简单介绍了一下增广路的主要思想，下面是三种具体的求法。\n\n\nOI 中网络流貌似不需要去管他的复杂度之类，尤其是最大流，卡 Dinic 的题可能只有 HLPP 模板题那一道。\n\n主要是感性理解，重点都在建模。\n\n\n### EK\n\n不会，上界 $\\operatorname{O}(nm^2)$，懒得学了\n\n\n### Dinic\n\n推荐结合这个博客看：https://www.cnblogs.com/SYCstudio/p/7260613.html\n\n继续上面的贪心想法\n\n每一次 dfs 可能得遍历整张图，只找到 1 条增广路，感觉不太值。\n\n考虑多路增广。\n\ndfs 每次传入两个参数：当前点编号和流过来了多少流量\n\n原来的 dfs 过程：\n\n1. 判断当前是否到达汇点，如果到达汇点，返回当前流量。\n2. 否则枚举有流量的边，继续 dfs。\n3. dfs 如果返回正数，说明找到一条增广路，返回。\n\n我们实际上可以在第 3 步找到增广路时不立即停止，而是将当前流量减去 dfs 返回的流量，表示有这么多的水已经流出去了。然后继续枚举边，枚举完毕/当前流量减到 0 则停止。\n\n貌似会死循环，我们可以用 bfs 分层。每次 bfs 从源点开始，只走有流量的边，一个点的深度为到源点的最短距离。如果图不连通，说明找不到增广路了。\n\n如果图连通，则反复 dfs。向下一个点搜索的前提是下一个点的深度 -1 等于当前点深度。\n\n然后加一个当前弧优化：dfs 可能反复到达同一个点，而这个点的某些边可能已经被增广过了。因此在第一次到达该点的过程中，可以把链式前向星的 fir[nod] 修改为当前增广过但是还可能继续增广的边——之前的边增广过，流量没跑完，说明走那条边已经找不到增广路了。\n\n每次分层情况都不一样，所以开一个 cur 数组当 fir 数组用，每次分层将 cur 数组的每个值都初始化成原 fir 数组的值。\n\n示例代码：\n\n```cpp\nstruct edge {\n    i64 u, v;\n    edge *nex, *opp;\n    i64 w;\n} graph[M];\nedge* tot = graph;\nedge *fir[N], *cur[N];\ni64 depth[N];\ni64 n, m, s, t; // 点数，边数，源点，汇点\nqueue<i64> q;\nvoid add(i64 a, i64 b, i64 c) {\n    ++tot;\n    tot->u = a;\n    tot->v = b;\n    tot->w = c;\n    tot->opp = tot + 1;\n    tot->nex = fir[a];\n    fir[a] = tot;\n\n    // 反向边\n    ++tot;\n    tot->u = b;\n    tot->v = a;\n    tot->w = 0;\n    tot->opp = tot - 1;\n    tot->nex = fir[b];\n    fir[b] = tot;\n};\n\nbool bfs() {\n    while (q.size())\n        q.pop();\n    // memset(depth, 0, sizeof depth);\n    cur[s] = fir[s];\n    for (int i = 1; i <= n; ++i)\n        depth[i] = 0;\n\n    depth[s] = 1;\n    q.push(s);\n    while (q.size()) {\n        i64 idx = q.front();\n        q.pop();\n        for (edge* e = fir[idx]; e; e = e->nex) {\n            if (e->w > 0 && !depth[e->v]) {  // 该边容量大于零且还没有被设置深度\n                depth[e->v] = depth[idx] + 1;\n                q.push(e->v);\n                cur[e->v] = fir[e->v]; // 当前弧优化\n            }\n        }\n    }\n\n    if (!depth[t]) return false;\n    return true;\n}\n\ni64 dfs(i64 nod, i64 val) {\n    if (nod == t) return val;  // 边界即到达汇点\n\n    i64 res = 0;\n    for (edge* e = cur[nod]; e && val; e = e->nex) {\n        cur[nod] = e;\n        if (depth[nod] + 1 == depth[e->v] && e->w) {  // 第一个条件判断分层图，第二个条件判断边的残量\n            i64 tmp = dfs(e->v, min(val, e->w));\n            if (tmp > 0) {  // 找到增广路\n                e->w -= tmp;\n                e->opp->w += tmp;\n                res += tmp;\n                val -= tmp;\n                // return res;\n            } else if (!tmp)\n                depth[e->v] = -1;\n        }\n    }\n    return res;\n}\n\ni64 dinic() {\n    i64 res = 0;\n    i64 d = 0;\n    while () {\n        while (d = dfs(s, (i64)LLONG_MAX)) {\n            res += d;\n        }\n    }\n    return res;\n}\n```\n\n## ISAP\n\nTODO\n<!-- Dinic 需要 bfs 和 dfs 好多次，有没有办法能够动态维护 dep 数组而不用再次 bfs 分层？ \n\n回顾整个 dinic 过程，感性理解一下 dep 数组的变化，发现相当于除了源点以外的点在不断远离源点 -->","tags":["网络流","最大流"],"categories":["图论"]},{"title":"配对堆基本介绍","path":"/post/pairing-heap/","content":"飞快的可并堆\n\n## 时间复杂度\n\n还没有完全严格的证明，但一般认为配对堆时间复杂度如下：  \n删除堆顶均摊 $\\operatorname{O}(\\log n)$  \n插入元素 $\\operatorname{O}(1)$ \n合并 $\\operatorname{O}(1)$  \n\n貌似这个可能比斐波那契堆快（\n\n## 节点存储\n\n配对堆不是一个二叉树，一般采用“左儿子右兄弟”表示法，一个节点存储自己第一个儿子与右侧第一个兄弟。  \n有点抽象？实际上相当于每一个节点的儿子使用链表维护，然后该节点连着第一个子节点。  \n![存储](https://pic1.imgdb.cn/item/64688453e03e90d874db5ef4.jpg)\n\n代码就非常好写了  \n```cpp\nstruct Node {\n\tint val;\n\tNode *child, *nex; // 第一个儿子，下一个兄弟\n};\n```\n\n## 合并两个堆\n\n比较根节点大小，把根节点大的堆直接改成根节点小的堆根节点的儿子即可。  \n图示中还是使用树本身形态。\n\n![合并](https://pic1.imgdb.cn/item/64688720e03e90d874def660.jpg)\n\n```cpp\nNode* meld(Node* x, Node* y) {  // 传入两个根节点\n\tif (x == null) // null 为空节点\n\t\treturn y;\n\telse if (y == null)\n\t\treturn x;\n\tif (x->val < y->val) { // x 比 y 小，y 当 x 的儿子\n\t\ty->nex = x->child; // 旧儿子是新儿子的兄弟\n\t\tx->child = y; // 新儿子是第一个儿子\n\t\treturn x;\n\t} else {\n\t\tx->nex = y->child;\n\t\ty->child = x;\n\t\treturn y;\n\t}\n}\n```\n\n## 插入新节点\n\n新建节点，然后当成两个堆合并即可。\n```cpp\nvoid push(int x) {\n\tNode* y = new_node(); // 获取新节点\n\ty->val = x;\n\tif (root == null) // 当前堆为空的话，新节点为根\n\t\troot = y;\n\telse\n\t\troot = meld(root, y); // 否则当成两个堆合并\n}\n```\n\n## 弹出堆顶\n\n貌似要写完了，但是前面几个操作都没有对堆的性质进行维护，因此重头戏在这个部分...  \n\n删除根节点之后，遇到的是原来的子节点们组成的森林，想办法把它们合并到一起。  \n有了上面的合并操作，很容易想到将这些森林里的树一棵一棵合并的方法，但是这样时间复杂度就奔 $\\operatorname{O}(n)$ 去了，因为每次删除根节点都只是单纯地把子节点比较一遍，非常缓慢。  \n于是说到了该数据结构名称的由来——“配对”。  \n我们把这个森林两两配对之后再合并成一个新堆，于是理想状态下，多次删除根结点，新根节点的子节点数量将为 $2$，均摊时间复杂度大约是 $\\operatorname{O}(\\log n)$ 的。\n\n图示过程：  \n![弹出堆顶](https://pic1.imgdb.cn/item/64688db3e03e90d874e6d98a.jpg)\n\n首先实现一个用于配对的函数。  \n```cpp\nNode* merges(Node* x) {\n\tif (x == null || x->nex == null) return x;  // x 为空或者 x 没有下一个兄弟节点\n\tNode* y = x->nex;                           // y 是 x 的下一个兄弟\n\tNode* c = y->nex;                           // c 是再下一个兄弟\n\tx->nex = y->nex = null;                     // 拆散\n\treturn meld(merges(c), meld(x, y));         // x 与 y 配对在一起，剩下的继续配对\n}\n```\n然后弹出堆顶的操作就很好写了。  \n```cpp\nvoid pop() {\n\tNode* t = merges(root->child);\n\tremove(root);\n\troot = t;\n}\n```\n\n## 模板\n```cpp\nusing i64 = long long;\n\n#define __SIZ 2000006\n\nstruct Node {\n    i64 val;\n    Node *child, *nex;\n} tree[__SIZ], *rubbish_bin[__SIZ]; // 提早分配内存，new 太慢了\nNode *null = tree, *tot = tree;\ni64 bintop;\n\nclass pairing_heap {\n    Node* root;\n\n    Node* new_node() {\n        Node* nod;\n        if (bintop)\n            nod = rubbish_bin[bintop--]; // 垃圾回收\n        else\n            nod = ++tot;\n        nod->child = null;\n        nod->nex = null;\n        return nod;\n    }\n\n    void remove(Node* x) {\n        rubbish_bin[++bintop] = x;\n    }\n\n    Node* meld(Node* x, Node* y) {  // 合并两个堆\n        if (x == null)\n            return y;\n        else if (y == null)\n            return x;\n        if (x->val < y->val) {\n            y->nex = x->child;\n            x->child = y;\n            return x;\n        } else {\n            x->nex = y->child;\n            y->child = x;\n            return y;\n        }\n    }\n\n    Node* merges(Node* x) {\n        if (x == null || x->nex == null) return x;  // x 为空或者 x 没有下一个兄弟节点\n        Node* y = x->nex;                           // y 是 x 的下一个兄弟\n        Node* c = y->nex;                           // c 是下一个兄弟\n        x->nex = y->nex = null;                     // 拆散\n        return meld(merges(c), meld(x, y));         // x 与 y 配对在一起，剩下的继续配对\n    }\n\npublic:\n    pairing_heap() {\n        root = null;\n    }\n    void push(i64 x) {\n        Node* y = new_node();\n        y->val = x;\n        if (root == null)\n            root = y;\n        else\n            root = meld(root, y);\n    }\n    i64 top() {\n        return root->val;\n    }\n    void pop() {\n        Node* t = merges(root->child);\n        remove(root);\n        root = t;\n    }\n} q;\n\n```","tags":["堆"],"categories":["数据结构"]},{"title":"线性代数","path":"/post/basic-linear-algebra/","content":"## 向量\n>类比一维数组    —— zzz\n\n分为行向量与列向量。  \n行向量形如 $\\left[ 1,2,3 \\right]$  \n列向量形如 $\\left[ \\begin{array}{l} 1 \\newline 2 \\newline 3\\newline 4 \\end{array} \\right]$  \n实际上高中 whk 里面的向量是二维向量，OI 中用的向量大部分为多维向量，数组中每一个元素就是一维的坐标。  \n运算的前提很容易想到：同维度，也就是“数组”长度得一样长。\n\n加法：分量分别相加 $[a,b,c]+[a,b,c]=[2a,2b,2c]$  \n减法：加法逆运算。  \n数乘：把系数乘到分量上 $3[a,b,c]=[3a,3b,3c]$  \n数量积（内积/点乘）：分量分别相乘并相加，顾名思义，得到一个数值 $[a,b] \\cdot [c,d] = ac+bd$  \n向量积（外积/叉乘）：实际上没卵用，~~所以我不会~~  \n\n## 线性基\n线性代数中的定义：$\\mathbf V$ 中的极小线性无关向量集合 $\\{\\mathbf a,\\mathbf b,\\mathbf c\\dots \\}$ 能够表示出 $\\mathbf V$ 中所有向量。  \n在 OI 中使用的线性基与上面定义略有不同：\n\n### 异或线性基\n\n给定一数列 $a$，其线性基 $s$ 是满足以下性质的数列：\n\n1. $a$ 中任意一个数都可以用 $s$ 中的数异或得到\n2. $s$ 中任意一些数异或和不为 $0$\n3. $s$ 里面的数个数一定，并且在满足性质 $1$ 的条件下数最少\n\n如果还是不能理解，别忘了线性基**不一定**是原数列的子集。","tags":["向量","线性代数","矩阵","线性基"],"categories":["数学"]},{"title":"概率论基础","path":"/post/basic-probability/","content":"## 基本概念\n\n事件运算\n$A+B:=A\\cup B$ ，相当于或运算  \n$AB:=A\\cap B$ ，同时发生\n\n## 条件概率\n\n- 条件概率：$A$ 发生的前提下 $B$ 发生的概率，表示为 $P(B\\mid A):=\\cfrac{P(AB)}{P(A)}$\n- 全概率公式：$B$ 依赖于一堆事件 $A_1\\dots A_n$ 的其中一个，则 $P(B)=\\sum^n_{i=1} P(A_i)P(B\\mid A_i)$\n\n- 贝叶斯公式：$P(A\\mid B) = \\cfrac{P(B\\mid A)P(A)}{P(B)}$\n  实际上就是一个条件概率的推导\n  $$\n  \\begin{aligned}\n  \\frac{P(B\\mid A)P(A)}{P(B)} &= \\cfrac{\\cfrac{P(AB)}{P(A)} P(A)}{P(B)} \\newline\n  &= \\frac{P(AB)}{P(B)} \\newline\n  &= P(A\\mid B)\n  \\end{aligned}\n  $$\n\n- 若 $P(AB) = P(A)P(B)$ 则 $A,B$ 互为独立事件，于是 $P(B\\mid A) = P(B)$\n\n## 随机变量\n\n只介绍离散型随机变量。\n\n离散型随机变量 $X$，可以理解为 $X$ 有有限种取值，且每个取值都有一个概率。换句话说，$X$ 的取值是一个有限的集合，集合里面每一个值都有一个概率，$X$ 按照概率取值。\n\n随机变量独立性：对于两个独立变量 $X Y$，有 $P(X=x_i, Y=y_i) = P(X=x_i)P(Y=y_i)$ （$,$ 表示**且**）    \n倒过来也是正确的。\n\n## 期望\n一个随机变量取值对概率的加权平均数。  \n$E(X) = \\sum_i x_ip_i$，$x_i$ 代表可能的取值，$p_i$ 代表取值对应的概率。\n\n期望的线性性：$E(aX+b)=aE(X)+b$  \n我们可以设 $X$ 的意义为均匀骰子可能掷出的点数，于是上面的东西就可以轻松感性理解了~\n\n随机独立变量的乘积：$E(XY)=E(X)E(Y)$","tags":["概率"],"categories":["数学"]},{"title":"组合数学基础","path":"/post/basic-combinatorics/","content":"## 基础排列组合\n\n~~实际上主要还是组合~~\n\n### 常用记号\n\n- $n \\in \\mathbb N,n!:= 1\\times 2\\times 3\\times \\dots \\times (n-1) \\times n$ 称为非负整数 $n$ 的阶乘，特殊地，$0! =1$。\n- $n,m\\in \\mathbb N,n\\geqslant m, \\binom{n}{m}=\\frac{n!}{m!(n-m)!} \\text{ a.k.a } C^m_n$ 表示 $n$ 个数中无序地选 $m$ 个数的方案数。\n- $n,m\\in \\mathbb N,n\\geqslant m, {n \\brack m} \\text{ a.k.a } s(n,m),s_u(n,m)$ 称作第一类无符号斯特林数，表示 $n$ 个数中排成 $m$ 个圆排列的方案数~~不知道什么是圆排列~~\n- $n,m\\in \\mathbb N,n\\geqslant m, {n \\brace m} \\text{ a.k.a } S(n,m)$ 称作第二类斯特林数，即 $n$ 个两两不同的数分成 $m$ 个互不区分的非空集合的方案数\n\n### 预处理组合数\n\n#### 递推法\n\n组合数递推：$\\tbinom{n}{m} = \\tbinom{n-1}{m-1} + \\tbinom{n-1}{m}$  \n证明：对于还需要选 $j$ 个，还剩 $i$ 个没选的情况，则对于一个苹果来说，不选它的方案数为 $\\tbinom{i-1}{j}$，选它的方案数为 $\\tbinom{i-1}{j-1}$。\n\n#### 阶乘法\n\n问题：给定 $p$ 与多组 $a,b$ ，求 $\\tbinom{a}{b} \\bmod p$。\n\n设 $fact_i = i! \\bmod p,infact_i = fact_i^{-1}\\pmod p$，根据[逆元](/post/multi-inverse-element)的性质可得\n\n$$\n\\begin{aligned}\n\\binom{a}{b} &= \\frac{a!}{b!(a-b)!}\\newline\n&= \\frac{form_a \\cdot inform_b}{(a-b)!}\\newline\n&= form_a \\cdot inform_b \\cdot inform_{a-b}\n\\end{aligned}\n$$\n\n## 二项式定理\n\n二项式就是只有两个项的多项式，如 $a+b$\n\n二项式定理如下：\n\n$$\n(x+y)^n = \\sum^n_{k=0} \\binom nk x^{n-k}y^k\n$$\n\n可以利用组合方法证明：  \n假设有 $n$ 个 $(x+y)$ 相乘，由多项式乘法的法则可以知道，对于 $x^ky^{n-k}$ 这一项来说（容易想到 $x,y$ 的指数和为 $n$），它来自于 $n$ 个括号中的 $k$ 个 $x$ 与剩下 $n-k$ 个括号中的 $n-k$ 个 $y$，也就是说“$n$ 个括号中选 $k$ 个 $x$ 的方案数”就是该项的系数，即 $\\binom nk$。\n\n## 卢卡斯定理\n\n下方 $p$ 均为质数\n\n$$\n\\binom nm \\bmod p = \\binom { \\lfloor n/p \\rfloor } {\\lfloor m/p \\rfloor} \\binom {n\\bmod p}{m \\bmod p}\\bmod p\n$$\n\n### 引理\n\n$$\n(a+b)^p \\equiv a^p+b^p \\pmod p\n$$\n\n证明：考虑 $\\tbinom pk$ ，易得到$\\binom pk = \\frac{p!}{n!(p-n)!}$，这玩意 $\\bmod p$ 基本上是 $0$ ，于是我们开始把它扔到上面 [二项式定理](#二项式定理) 里面想。  \n分两种情况\n\n- $n \\neq p$ 且 $n\\neq1$\n  此时 $p$ 没法被分母任何一个因数整除，因此一定会在值中被保留下来，则该式被 $p$ 整除\n- $n=p$ 或 $n=1$\n  容易得到此时该式值为 $1$\n\n于是我们就把二项式定理中的所有项讨论完了。\n\n$$\n(x+y)^p = \\binom p 0 x^p + \\binom p1 x^{p-1}y^1 + \\dots + \\binom {p}{p-1}x^{p-(p-1)}y^{p-1} + \\binom pp y^p\n$$\n\n根据上面的讨论，左右两边的两项系数为 $1$，其余被 $p$ 整除，也就是被模掉了，于是最后剩下：\n\n$$\n(x+y)^p=x^p+y^p\n$$\n\n### 证明\n\n[引理](#引理) 推导的过程中没有任何限制，于是我们可以把它用在多项式身上\n\n考虑一个二项式 $(1+x)^n \\bmod p$，设 $n = kp+r$，则在 $\\bmod p$ 意义下有：\n\n$$\n\\begin{aligned}\n(1+x)^n &= (1+x)^{kp}(1+x)^r \\newline\n&= (1+x^p)^k(1+x)^r \\newline\n&= (1+x^p)^{\\lfloor n/p \\rfloor}(1+x)^{n\\bmod p}\n\\end{aligned}\n$$\n\n用二项式定理拆开的话，可以观察一下这个式子的内部结构\n\n$$\n(1+x)^n = \\binom n0 x^1 + \\binom{n}{1}x^2+\\dots+\\binom n{n-1}x^{n-1} + \\binom nn x^n\n$$\n\n现在我们的目标是求 $\\binom nm$，实际上在上面的式子里就是 $x^m$ 的系数。  \n想办法从前面推导出来的东西表示 $x^m$ 的系数，这里采用类似的办法，把 $m$ 拆开为 $\\lfloor m/p \\rfloor p + (m \\bmod p)$，于是目标转化为**如何在最上面的式子中找到 $x$ 相乘表示出左侧的次数**。  \n分开考虑贡献，$\\lfloor m/p \\rfloor p$ 只能从 $(1+x^p)^{\\lfloor n/p \\rfloor}$ 处得到贡献，因为这玩意显然是个 $p$ 的倍数，而另外半边式子中 $n \\bmod p$ 绝对小于 $p$。  \n于是我们也就考虑到了 $m\\bmod p$ 的贡献应当从 $n \\bmod p$ 中来，因为 $\\lfloor n/p \\rfloor > p$。  \n这样就找到了对 $\\binom nm$ 的总贡献，从 $n \\bmod p$ 中选 $m \\bmod p$ 个，另外半边同理，则为\n\n$$\n\\binom nm \\bmod p = \\binom { \\lfloor n/p \\rfloor } {\\lfloor m/p \\rfloor} \\binom {n\\bmod p}{m \\bmod p}\\bmod p\n$$","tags":["组合数学"],"categories":["数学"]},{"title":"模意义下的乘法逆元","path":"/post/multi-inverse-element/","content":"自学逆元...\n\n## 定义\n\nOI 中常用“逆元”作“模意义下的乘法逆元”。\n$$\nax\\equiv 1 \\pmod b\n$$\n则 $x$ 为模 $b$ 意义下的 $a$ 的逆元，记作 $a^{-1}$ 。  \n通俗来讲，$a\\cdot a^{-1} \\bmod b = 1$ \n\n## 用途\n\n~~先讲用途再说求法？~~\n\n对于 $\\frac ab$，想要对结果取模，但是实际上 $\\frac ab \\bmod p \\neq \\frac {a\\bmod p}{b \\bmod p}$   \n难道没有办法了吗？  \n并不是。  \n\n设 $b^{-1}$ 为 $b \\bmod p$ 意义下的逆元，则有\n$$\n\\frac ab \\bmod p = a\\cdot b^{-1}\n$$\n## 求单个逆元\n\n### 扩展欧几里得算法\n此法相对于快速幂来说，限制少，常数小，因此比较优，不再写快速幂法。~~实际上是我不会快速幂法~~\n\n容易发现乘法逆元定义式就是一个普普通通的同余方程  \n于是可以轻松使用扩欧求解  \n详见 [同余方程与二元一次不定方程](/post/exgcd)\n\n## 线性求逆元\n\n由于线性求任意多个数逆元过于简单，所以直接记录这个解法。\n\n考虑逆元的定义，容易想到对于 $a^{-1}b^{-1}$ 来说，乘 $a$ 即可消除 $a^{-1}$ 的影响，即\n$$\na\\cdot a^{-1}b^{-1} \\bmod p = (a\\cdot a^{-1} \\bmod p)b^{-1} = b^{-1}\n$$\n与此同时，两个数积的逆元等于两个数逆元的积  \n证明：\n$$\n\\begin{aligned}\naa^{-1} \\bmod p &= 1\\newline\nbb^{-1} \\bmod p &= 1\\newline\naa^{-1} \\cdot bb^{-1} \\bmod p &= 1 \\newline\nab \\cdot a^{-1}b^{-1} \\bmod p &= 1 \\newline\n\\therefore (ab)^{-1} = a^{-1}b^{-1}\n\\end{aligned}\n$$\n因此对于任意数列 $a_1 \\dots a_n$ ，可以先求出其前缀积 $s_i$ ，然后利用扩展欧几里得求累积的逆元 $f_n = s_n^{-1}$，然后从后往前线性复杂度求出前缀积的逆元 $f_{i-1} = f_ia_i \\bmod p$    ，最后从前往后扫一遍求出每个数的逆元 $inv_i = s_{i-1}f_i$ 即可。\n\n```cpp\ni32 tmp;\n\nvoid exgcd(i32 a, i32 b, i32& x, i64& y) {\n    if (!b) {\n        x = 1, y = 0;\n        return;\n    }\n    exgcd(b, a % b, x, y);\n    tmp = x;\n    x = y;\n    y = tmp - (a / b) * y;\n}\n\n#define N 5000001\n\ni32 a[N], s[N], f[N];\ni64 n, p, k, ans, ktmp, y;\n\nint main() {\n    read(n, p, k);\n    s[0] = 1;\n    for (i32 i = 1; i <= n; ++i)\n        read(a[i]), s[i] = s[i - 1] % p * a[i] % p;\n    exgcd(s[n], p, f[n], y);\n    // write(p, '\\n');\n    for (i32 i = n - 1; i; --i) {\n        f[i] = f[i + 1] % p * a[i + 1] % p;\n    }\n    f[1] %= p;\n    ans = k * f[1] % p;\n    ktmp = k % p;\n    for (i32 i = 2; i <= n; ++i) {\n        f[i] = s[i - 1] % p * f[i] % p;\n        ktmp = (ktmp * k) % p;\n        ans = ((ans % p + ktmp * f[i]) % p + p) % p;\n    }\n    write(ans, '\\n');\n    \n    return 0;\n}\n```","tags":["数论","同余"],"categories":["数学"]},{"title":"同余方程组","path":"/post/crt/","content":"同余方程组形式如下：\n$$\n\\begin{cases}\nx \\equiv a_1 \\pmod {n_1} \\newline\nx \\equiv a_2 \\pmod {n_2} \\newline\n\\dots \\newline\nx \\equiv a_k \\pmod {n_k}\n\\end{cases}\n$$\n\n## 中国剩余定理\n\n### 原理\n\n本算法用于所有 $n_i$ 两两互质的情况。\n\n实际上类似构造，先把 $n_1$ 累积起来\n$$\nM = \\prod_{i=1}^k n_i\n$$\n$$\nM_i = \\frac M{n_i}\n$$\n\n先考虑如何构造出一个同余方程的特解，设 $M_i ^{-1}$ 为 $M_i$ 在 $\\bmod n_i$ 意义下的逆元,想到 $M_iM_i^{-1} = 1\\pmod {n_i}$，于是有 $x = a_i M_i M_i^{-1}$ 满足方程 $x \\equiv a_i \\pmod {n_i}$ 。  \n这实际上就是上面定义 $M_i$ 为质数的原因：需要保证有逆元存在。\n\n至于解的合并，把 $x$ 相加即可。即 $\\sum_{i=1}^k a_iM_iM_i^{-1}$。通解即为 $nM+ \\sum_{i=1}^k a_iM_iM_i^{-1}, n\\in \\mathbb Z$ 。为什么能这样合并？因为对于 $i,j,i\\neq j$ 来说，必然存在 $n_j \\mid M_i$，因为 $n_i$ 两两互质，$M_i$ 的因子包含 $n_j$，因此不会对已经推出来的解造成任何影响。\n\n通解方面：容易想到，加减 $nM$ 也不会对解的可行性造成任何影响。\n\n### 实现\n\n```cpp\nllint ex_gcd(llint u, llint v, llint& x, llint& y) {\n    if (!v) {\n        x = 1, y = 0;\n        return u;\n    }\n\n    llint g = ex_gcd(v, u % v, x, y);\n    llint temp = x;     \n    x = y;\n    y = temp - u / v * y;\n    return g;\n}\n\nllint crt() {\n    llint tmp = 1, ans = 0;\n    for (int i = 1; i <= n; ++ i) tmp *= b[i];\n    for (int i = 1; i <= n; ++ i) {\n        llint m = tmp / b[i], x, y;\n        ex_gcd(m, a[i], x, y);\n        ans = (ans + n[i] * m * x % tmp) % tmp;\n    }\n    return (ans % tmp + tmp) % tmp;\n}\n```\n\n## 扩展中国剩余定理/同余方程合并\n\n### 原理\n\n当 $n_i$ 不互质的时候，上面做法就不再适用（不能保证逆元存在），此时我们考虑逐一合并同余方程组。  \n方法是使用 $\\operatorname{ex\\_gcd}$\n\n假设方程组只有两个方程\n\n$$\n\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\newline\nx \\equiv a_2 \\pmod{n_2} \\newline\n\\end{cases}\n$$\n\n可以写作\n\n$$\n\\begin{cases}\nx = a_1 + k_1n_1 \\newline\nx = a_2 + k_2n_2\n\\end{cases}\n$$\n则 $a_1 + k_1n_1 = a_2 + k_2n_2$。  \n移项，得 $k_1n_1 - k_2n_2 = a_2-a_1$ ，接下来按照扩展欧几里得的思路推导。  \n设 $g = \\gcd(n_1,n_2)$，若使用扩展欧几里得算法，可以求出 $n_1k_1 + n_2(-k_2) = \\gcd(n_1,n_2)$ 的一组特解 $k_1, k_2$，即 \n$$\n\\begin{aligned}\nn_1k_1 + n_2(-k_2) &= g \\newline\n(k_1 \\cdot \\frac{a_2-a_1}{g})n_1 + (-k_2 \\cdot \\frac{a_2-a_1}{g})n_2 &= a_2-a_1\n\\end{aligned}\n$$\n抽出刚才表示 $x$ 的方程组的一条，得到 $x_0 = a_1 + k_1n_1$，$k_1$ 的通解为 $k_1 + \\cfrac{n_2}gp, p\\in \\mathbb Z$，则\n$$\n\\begin{aligned}\nx &= a_1 + (k_1+\\cfrac{n_2}gp)n_1 \\newline\n&= n_1k_1 + a_1 + \\cfrac{n_1n_2}gp \\newline \n&= n_1k_1 + a_1 + \\operatorname{lcm}(n_1,n_2)\\cdot p\n\\end{aligned}\n$$\n显然我们可以把这个等式写成同余式的形式（没必要）\n\n$$\n\\begin{aligned}\nx_0 &\\equiv x \\pmod {\\operatorname{lcm}(n_1,n_2)} \\newline\nx&\\equiv n_1k_1 + a_1  \\pmod {\\operatorname{lcm}(n_1,n_2)}\n\\end{aligned}\n$$\n$\\operatorname{lcm}(n_1,n_2),n_1k_1+a_1$ 都是已知的，因此方程可解，合并完成。\n\n### 实现\n\n```cpp\n#define N 100005\n\ni128 ex_gcd(i128 a, i128 b, i128& x, i128& y) {\n    if (b) {\n        i128 tmp;\n        i128 g = ex_gcd(b, a % b, x, y);\n        tmp = x;\n        x = y;\n        y = tmp - a / b * y;\n        return g;\n    } else {\n        x = 1, y = 0;\n        return a;\n    }\n}\n\ni64 n;\ni128 a[N], m[N];  // a === x (mod m)\n\ni128 ex_crt() {\n    i128 k1, k2, a1, m1, a2, m2, c, gc, g;\n    a1 = a[1], m1 = m[1];\n    for (i64 i = 2; i <= n; ++i) {\n        a2 = a[i], m2 = m[i], c = ((a2 - a1) % m2 + m2) % m2;\n        g = ex_gcd(m1, m2, k1, k2);\n        gc = m2 / g;\n        k1 = k1 % gc * ((c / g) % gc) % gc;\n        a1 = k1 * m1 + a1;\n        m1 *= gc;\n        a1 = (a1 % m1 + m1) % m1;\n    }\n    return a1;\n}\n\nint main() {\n    read(n);\n    for (i64 i = 1; i <= n; ++i) {\n        read(m[i], a[i]);\n    }\n\n    write(ex_crt(), '\\n');\n    return 0;\n}\n```","tags":["数论","同余"],"categories":["数学"]},{"title":"离散对数（BSGS）","path":"/post/bsgs/","content":"离散对数问题，即已知 $a,b,p$，求方程 $a^x \\equiv b \\pmod p$ 最小非负整数解。\n\n## BSGS 算法\n\n### 原理\n思考暴力做法，即枚举 $x$ 直到满足方程，复杂度 $\\operatorname{O}(p)$ \n\nBSGS 类似一种分块思想，也有点像折半搜索（\n\n首先把 $x$ 拆开，拆成 $km - r$ ，然后进行变换：\n$$\n\\begin{aligned}\na^x &\\equiv b \\pmod p \\newline\na^{km-r} &\\equiv b \\pmod p \\newline\n\\frac {a^{km}}{a^r} & \\equiv b \\pmod p \\newline\na^{km} & \\equiv ba^r \\pmod p\n\\end{aligned}\n$$\n这里的 $m$ 我们设为一个固定值，然后分别枚举等式两边的 $k,r$，存哈希表（映射），然后匹配即可，其中 $k \\in [0, \\cfrac pm], r \\in [0,m]$ ，复杂度 $\\operatorname{O}(\\max(m,\\cfrac pm))$ ，则 $m=\\sqrt p$ 时最优，复杂度是一个根号。\n\n### 实现\n\n```cpp\nread(n, p);\nb = 10;\nn = n * 9 + 1;\n\nb = (b % p + p) % p;\nn = (n % p + p) % p;\n\nif (b == 0) {\n\tif (n == 0) output(1);\n\tfailed();\n}\nif (n == 1) {\n\toutput(0);\n}\nif (b == 1) {\n\tfailed();\n}\n\ni128 m = sqrt(p), z = n;\nfor (i128 i = 0; i < m; ++i) {\n\tmp[z] = i; // 存储的实际上是模数所对应的最大 r（从小到大枚举，挨个覆盖）\n\tz = z * b % p;\n}\nz = binpow(b, m);\nfor (i128 i = 1, pian = z; i <= p / m + 10; ++i) {\n\tauto it = mp.find(z);\n\tif (it != mp.end()) {\n\t\toutput(m * i - it->second);\n\t}\n\tz = z * pian % p;\n}\nfailed();\n```","tags":["数论","同余","BSGS"],"categories":["数学"]},{"title":"NOI Linux 指北","path":"/post/noi-linux-2-guide/","content":"从终端开始什么是终端？对于一个计算机来说，输入输出设备显然不是必需品（脱离使用的范畴，没有输入输出设备它也能通电成为一个吉祥物），而最初人们为了与计算机互动，发明了终端，即人类用户与计算机交互的设备。对于一个计算机操作系统，其运行过程中本身并没有显示任何东西，所谓桌面环境之类在显示器上显示的东西都是后话，最简单的输入输出方式即“我输入文字，计算机输出文字”，于是引入今天我们所要遇到的第一个概念，我称其为“文字终端”，即你输入文字，计算机输出文字的地方。对于现在来说，以往奢侈的图形显示现在已经满地都是，但是为了还能用上简单快捷的文字终端的功能，出现了“终端模拟器”，实际上就是开一个小黑窗口，里面能够输入输出（类比 CMD）。打开终端在桌面或者文件管理器中右键，点击“在终端中打开”于是出现了一个如上的窗口，这就是一个终端模拟器，里面运行一个被称为“Shell”的进程，这里不多作介绍，理解它能够输入输出文字就行。open:false 什么是 SHELL？呃，点开这里就默认你已经知道编写程序、输入输出什么的基本概念了。SHELL，顾名思义，是一层“壳”。前面说到，我们需要一个“终端”来进行交互，而 SHELL 实现的东西就是“输入”，处理，然后“输出”。相当于给机器套了一层“可交互”的“外壳”。和终端模拟器的区别？你显然输入要有来源，输出要有目标。终端模拟器就相当于一个屏幕，他能把你键盘里输入的东西扔到 SHELL 里面，然后把 SHELL 输出的东西扔到你的眼前。NOI Linux，或者说 Ubuntu，默认使用的 Shell 是 Bash。在这里你可以输入命令，做到创建文件，修改文件，删除文件等基本上你在图形界面下能做的所有事情。先...管理文件？在 Shell 中，`.` 表示当前目录，`..` 表示当前目录的父目录，`/` 表示根目录Linux 下只有一个根目录，不会像 Windows 一样不同的盘有不同的根目录也就是如下Windows:```C:- - Windows - Program Files _ UsersD:- - Software - Documents _ Steam```Linux:```/ - - usr - bin - home - dev - etc .....```绝对路径：能唯一确定的路径，也就是说从根目录表示的确定的位置，比如 `/usr/local/bin`相对路径：相对于某一目录的位置，比如当前目录是 `/usr/local/`， 则上面的路径可以表示为 `bin` 或 `./bin`先提供相应的命令：```shell# 这是一条注释，SHELL 中使用井号做单行注释# 创建文件夹mkdir folder_name# 创建一个 modmodwhr 文件夹mkdir modmodwhr# 创建空文件touch filename# 创建一个名为 whrakioi 的空文件touch whrakioi# 进入一个目录cd folder_name# 如果当前目录下有一个 hhyakioi 文件夹，则可以通过这个命令进入该文件夹cd hhyakioi# 或者 . 代表当前目录，./hhyakioi 相当于进入当前目录下的 hhyakioi 文件夹cd ./hhyakioi# 进入上一级文件夹cd ..# 进入根目录cd /# 进入某绝对路径cd /usr/share# 最后一个杠加不加无所谓cd /usr/share/# 复制一个文件到另一个位置cp /path/to/file /path/to/direction# 把 1.cpp 复制到 gjxakioi 文件夹cp 1.cpp gjxakioi/1.cpp# 复制文件夹需要添加 -r 参数cp folder_name gjxakioi/folder_name -r# 移动一个文件到另一个位置，同时可以当重命名用mv path1 path2# 重命名 1.cpp 为 2.cppmv 1.cpp 2.cpp# 移动 2.cpp 到 gjxakioi 文件夹mv 1.cpp gjxakioi/1.cpp```NOI Linux 2 的比赛环境下默认给你挂载 noip 文件夹并在 Linux 桌面上创建快捷方式，因此如果你在桌面上进入终端，则可以通过下面的命令进入 noip 文件夹```shellcd noip```或者```shellcd ./noip```开始写代码吧！想编辑下文件？如果你在 Windows 下写好了代码想要粘贴到 Linux 的文件里，则可以```shell# 新建 a.cpp 文件touch a.cpp# 使用 nano 编辑器编辑 a.cpp 文件nano a.cpp```nano 是 GNU 的一款简易终端文本编辑器，相对于 Vi/Vim 来说更适合新手使用复制了 Windows 的代码之后，确保 VMware 的共享剪贴板已经打开，然后按下 `Ctrl` + `Shift` + `V` 粘贴，然后按下 `Ctrl` + `S` 保存，`Ctrl` + `X` 退出。当然，有图形化编辑器供你使用```shell# 使用闭源 Visual Studio Code 编辑 a.cppcode a.cpp```在此之后你可以通过 `cat` 命令[^1]验证文件内容```shellcat a.cpp```编译 C++ 源码GNU 编译套件GNU Compile Collection 是 GNU 开发的一套编译器，在这里我们只使用 GNU C/C++ 编译器部分。另：GNU 计划的目标是开发出一款完全自由的操作系统和软件生态，自由软件运动致力于推进全部软件的隐私保护以及自由化，自由软件属于全人类，自由软件开发者们留下的作品与学习资料是不朽的！如果你对自由软件运动有疑问或有兴趣，可前往 GNU 官方网站 了解更多相关内容。开始编译```shellg++ grainrainisgod.cpp```这个命令会在当前目录下编译 grainrainisgod.cpp 文件，然后默认输出一个 a.out 可执行文件[^2]。可是我懒得重命名文件，所以如何执行输出可执行文件的位置和名称呢？只需要加 `-o /path/to/direction` 即可```shellg++ grainrainisgod.cpp -o grainrainisgod```当然，你也可以加入其他比赛要求的编译选项，比如说吸个氧（加 `-O2` 参数）```shellg++ grainrainisgod.cpp -o grainrainisgod -O2```开启编译警告编译警告在编译的编译阶段和警告阶段发出，能帮你发现一些低级问题和简单 UB，比如著名 UB（但是萌妹 OPTIM 还是犯了这个问题）```cppa = a++ + ++a;```编译器会发出警告```logwarning: multiple unsequenced modifications to 'a' [-Wunsequenced] cout << a++ + ++a << endl;```这样的警告对于比赛选手来说肯定是越多越好越全越好，所以需要开启全部警告，即添加 `-Wall` 参数```shellg++ grainrainisgod.cpp -o grainrainisgod -O2 -Wall```检查内存错误以及未定义行为Sanitizer 是谷歌开发的一个检测程序问题的开源套件，一般集成在 gcc 以及 clang 编译器中。相应的，MinGW-W64 并没有为 Sanitizer 做 Windows 兼容，因而无法在比赛环境 Windows 使用（LLVM/Clang 编译器包含的 Sanitizer 支持 Windows，MSVC 的也支持但是只有 AddressSanitizer）（但是显然比赛环境没有这两个编译器），所以显得 Linux 环境非常重要。Address Sanitizer 用于检测程序的内存错误，比如爆栈等问题。使用方法是添加 `-fsanitize=address` 选项Undefined Behaviour Sanitizer 用于检测程序的未定义行为，比如访问空指针，数组越界访问等问题，使用方法是添加 `-fsanitize=undefined` 选项。值得注意的是，这两个 Sanitizer 会显著拖慢程序运行速度，所以添加这两个编译选项编译出来的程序在运行时间和内存占用上参考意义不大。同时如果动态分配内存过多可能 Address Sanitizer 会抽风，UBSanitizer 倒是问题不大。所以酌情使用。总结：```shellg++ grainrainisgod.cpp -o grainrainisgod -O2 -Wall -fsanitize=address -fsanitize=undefined```如上是我赛时经常使用的编译命令。执行可执行文件```shell./grainrainisgod````.` （当前目录）+ `/` （目录分隔符）+ `grainrainisgod` 可执行文件名称注意，这里不能直接输入文件名，必须加上表示路径的符号（相对和绝对都行，此举是为了保证你知道你要执行的程序是“当前目录下”的“这个程序”，别执行成“李鬼”了）。然后就可以快乐地输入了。注意：在这个终端中复制使用 `Ctrl`+`Shift`+ `C`，粘贴使用 `Ctrl`+`Shift`+` V``Ctrl` + `C` 用于终止当前正在运行的程序，也可以在输入命令打错字时 `Ctrl` + `C` 重开一行。进阶：一些 bash 指令刚才已经学过一些命令了，接下来将会教给大家更多的 bash 相关的东西。关系运算符- `command1 && command2`：当 `command1` 执行成功后才会执行 `command2`。- `command1  command2`：当 `command1` 执行失败时才会执行 `command2`。然后给几个练习题：命令 `echo`：后面接一个字符串，作用是输出这个字符串。  示例：`echo tibrellalaji`，回车，终端出现了 `tibrellalaji` 一串字符。猜测以下的命令输出结果是什么？（一行一题）```shellecho 1 && echo 23echo 12  echo 3echhhooo 1234 echo 3woquzheshishenmezhiling && echo 123```答案 child:codeblock open:false```shell# 忽略报错信息123123```变量赋值```shella=1```bash 变量无需声明，可以直接赋值之后使用。变量名要求和 C++ 差不多：- 字母、数字、下划线- 数字不能开头但是赋值和大部分语言是不同的：等号两边不能有空格。你不必在乎 bash 的变量类型。使用变量名前加 `$`，两边可以加大括号也可以不加。示例：```bashmainpage=www.tibrella.spaceecho ${mainpage}echo $mainpageecho https://${mainpage}isgood```容易发现大括号的作用：区分变量名的边界。如果你写的是 `echo https://$mainpageisgood` 的话后面就是空的了，因为 bash 把 `mainpageisgood` 识别成了一个变量名，而这个变量不存在（也就是为空）。输入输出重定向与管道符这里是重点，在 OI 中写对拍脚本啥的非常能用得上这个东西。假设有一个文件叫做 `testfile`，一个程序叫 `test`，则：还记得吗？执行文件时必须加 `./`，否则不能执行。- `testfile < ./test`：将 `test` 的输入（`stdin`）重定向到 `testfile`，相当于在你的程序中加入了 `freopen(\"testfile\",\"r\",stdin)`- `./test > testfile`：将 `test` 的输出（`stdin`）重定向到 `testfile`，相当于在你的程序中加入了 `freopen(\"testfile\",\"w\",stdin)`。换句话说，`test` 程序输出的东西将会写入到 `testfile` 中。- 上面两个可以同时使用，比如 `joker.in < ./joker > joker.out`，相当于程序中加了两行 `freopen`。然后是管道符，它代表把前一个程序的输出重定向到后一个程序的输入里面。- `cat testfile  ./test`：输出 `filename` 文件的内容，并把其重定向到 `test` 程序的输入里面。等价于 `testfile < ./test`为啥他叫管道符呢？现在我们写一个输入一个字符串再输出它的程序：```cpp#include <string>#include <iostream>int main() { std::string s; std::cin >> s; std::cout << s; return 0;}```编译一下：`g++ test.cxx -o test`然后执行这个命令：```bashecho pipe  ./test  ./test  ./test```我们发现最后的输出是 `pipe`。  显然，这玩意就像管道，能把不同的机器（程序）的输入输出连接起来。编写一个 bash 脚本```shelltouch test.sh # 创建一个 bash 脚本nano test.sh # 编辑这个 bash 脚本```文件内容：```bash#!/bin/bashecho Hello World````#!/bin/bash` 表明你这个 `test.sh` 文件需要使用 `/bin/bash` 程序运行。（写 `#!/bin/sh` 也行，这里讲的语法和 sh/zsh 是兼容的，但是你亲爱的 NOI Linux 只有 `bash` 和 `sh`）按下 `Ctrl` + `S` 保存，`Ctrl` + `X` 退出。然后你需要让这个文件可以被执行，即给他“被执行”的权限：```shellchmod +x test.sh```执行可以直接当可执行文件执行。```shell./test.sh```输出：```Hello World```[^1]: `cat filename` 即输出 `filename` 文件的内容[^2]: Linux 下文件类型的判断与 Windows/DOS 略有不同。众所周知，Windows 下操作系统通过扩展名判断文件类型，也就是说无论你把什么文件改成 `.docx` 扩展名，Windows 都会用 Word 打开它。但是 Linux 一般通过文件头判断文件类型，也就是说无论你把可执行文件命名成 `a.out` 还是 `a.docx` 还是 `a.jpg` 甚至没有扩展名，输入 `.\\a.jpg` 或相应命令之后终端都会把它当作可执行文件执行。","tags":["NOI Linux"],"categories":["Linux"]},{"title":"更改博客主题之后的一些破事","path":"/post/blog-theme-movement/","content":">最近因为原来 [我的 butterfly 主题 fork](https://github.com/pinghigh/hexo-theme-butterfly/) 实在改不动了（实际上因为我水平太差），对于 pug 什么的也不太懂，同时由于界面过于花哨看腻了，想换点动态效果少的而又相对简单的博客主题。  \n又因为之前就观察过 hugo 的主题列表，hugo 的特点是快，大部分的 hugo 主题也非常简洁（比如 [c4096 的博客](https://c4096.cn/)所采用的主题），因此我又双叒叕去 hugo theme 列表挑了个非常符合我审美（大概）的主题，即 [stack](https://github.com/CaiJimmy/hugo-theme-stack)。\n>\n>最一开始用 test 界面测试主题功能的时候 hugo 的速度就惊艳我了，实在是过于迅速，和我之前所用的 hexo+butterfly 的速度相比，hugo 让我感觉到构建了又好像没构建的构建过程。同时它的即时修改即时预览功能也很好用（但是有的时候并不能做到完全应用新修改）。  \n但是一起到来的问题也很多，比如 stack 主题的文档并不是很完善，相对于我看过的大部分 hexo 主题来说可能是最不完善的（中英文倒是无所谓），因此我需要一边看文档一边看源码，还得看主题的示例站点的配置文件才让我的博客跑出正常的样子。\n>\n>主题配置问题还算好解决，对于我这个~~啥都不懂还贼挑的~~人来说，改动主题是必须有的部分，但是 hugo 的编写修改维护主题的文档和教程更是少之又少了...因此研究了好久也没研究出来怎么改代码块样式，改配色也没成功，但是把深浅色代码块背景宽度不统一的问题倒是解决了，还得对这个进行进一步更改。当然，主题克隆下来的第一步就是 copyright->copyleft，然后给 `&copy` 掉个头，文章许可证改为 FDL 1.3 才继续做接下来的修改。\n>\n>关于写配置，我最开始采用的是网上得到大部分好评的 toml 格式，据说比 yaml 新还好用，在此之前因为 yaml 的缩进问题我痛苦了很长时间，但是折腾了好久 toml 之后感觉 toml 更不容易被人类理解（可能只有我不理解），然后用工具回到了 yaml 的怀抱，在此之前为了研究 toml 的 map 映射语法之类的东西已经折腾不动了...\n>\n>关于换行，由于之前的 butterfly 主题能够自动换行，但是 stack 主题默认用的是 markdown 的换行规则，即行尾双空格或回车两次为一个换行，于是我博文基本上都炸了，会找时间修（逃\n\n回到 hexo 了，原因很多。\n\n- hugo 对插件支持较少，脚注之类的加强需要我自己实现。 ~~由于实现不了就直接用了 littlefoot~~ ~~实际上 littlefoot 也没配好~~\n- hugo 对第三方渲染器支持程度不高，想用 pandoc 之类的用不了（toc 会有问题）。\n- hugo 语法挺诡异的。\n- goldmark 写 $\\LaTeX$ 语法的时候换行要四个反斜杠，两个反斜杠会被转义而无法换行。\n- hugo 短码写不明白，文件目录挺迷惑的。\n- hugo module 文档也挺缺乏的，想自己写也写不动。\n\n然后选了很多主题，最终发现如果我早用了 [一刀斩](https://yidaozhan.top) fork 的 [stellaris](https://github.com/YidaozhanYa/hexo-theme-stellaris) 主题，我能少走一年弯路。\n\n- 博客内支持给自己项目设立一个文档专栏\n- 有很多种标签可以使用，保活但不限于提示框，时间线等\n- 美丽的 fluent 风格\n- 使用 React + JSX，这意味着我可以较低成本地修改这个主题（相对于以前的 pug 和 ejs 来说，这个起码我会一点，而且教程也挺多）\n- 性能较好。样式不算太少，但是相对于 butterfly 等主题，这个主题在我机房电脑上还是非常流畅的。\n\n但是最初还是遇到了一些问题，还好可以直接抄一刀斩的配置。\n\n但是需要不少更改，比如 CDN 之类。（肯定不能用他朋友给他整的 CDN 啊）\n\nValine 貌似挺过时的了，twikoo 默认样式扔这里挺丑的，然后就直接配了个 Waline 扔上去了。  \n\n用 JSX 加入了 MathJax 支持，同时为了更好的数学支持用上了 pandoc 渲染器。~~不知道为啥进入另一个页面之后数学就寄了，所以如果某一个页面的数学用不了请你刷新~~ 基本上修好了，照着一刀斩给评论写的加载方式抄了一遍。","tags":["博客"],"categories":["杂项"]},{"title":"钛合金伞的垃圾场","path":"/post/misc-note/","content":"## ArchLinux 添加证书（感谢 [Marisa](https://yjacks.github.io/)）\n```SHELL\nsudo trust anchor --store myCA.crt\n```\n\n## Grub 提示 `/usr/share/grub/grub-mkconfig_lib: 第 237 行：printf: “$”：无效格式字符`\n\n在英文环境下 `grub-mkconfig` 即可\n\n```SHELL\nenv LANG=en_US.UTF-8 sudo grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n## gcc 编译提示 `编译器内部错误：File size limit exceeded signal terminated program as`\n\n编译的时候爆内存了\n\n可能是你用了形如\n\n```cpp\nbool a[100000010] = {1,1};\n```\n\n的语句进行初始化。  \n这个语句虽然只会给你的 $a_0, a_1$ 赋值，但是在编译预处理和程序运行的过程时，它都会将数组全部展开再进行赋值/初始化\n\n所以还是老老实实赋值吧\n\n```cpp\nbool a[100000010];\na[0] = a[1] = 1;\n```\n\n## gcc 编译提示 `relocation truncated to fit: R_X86_64_PC32 against '.bss'`\n\n静态数组爆内存了，一般的解决方法是加编译选项\n\n```bash\ng++ test.cxx -o test -mcmodel=medium\n```\n\n或者\n\n```bash\ng++ test.cxx -o test -mcmodel=large\n```\n\n~~其实换 clang++ 编译有的时候就能过~~ ~~但是测评机肯定还是 gcc ，所以应该考虑下自己是不是写错数了~~","tags":["Linux","note"],"categories":["Linux"]},{"title":"模拟退火","path":"/post/simulated-annealing/","content":"模拟退火不是模拟题意，也不会让你退火（可能会让你上火），顾名思义，这个算法模拟的是“退火” 的过程。\n\n## 基本原理\n\n退火即晶体冷却的过程，将一个物体加热到一定温度后使其逐渐降温。而在物理中，物体内能越高，其粒子随机运动就更剧烈，状态也就越不稳定。物体温度高时，状态最不稳定。使降温，粒子运动变慢，状态就趋于稳定。当降温速度过快，会导致粒子来不及排列成稳定的原有的结构，从而形成能量高不稳定的非晶体。相对的，如果降温速度足够慢，粒子会渐趋有序，直至内能减为最小，此时物体呈现为晶体。\n\n上面两段所说的“非晶体”可以看作“局部最优解”，而变回原有结构的晶体则可以看作“最优解”。\n\n大体来说，模拟退火就是随机跳解，接受更优的解，同时为了防止局部最优解的陷阱，概率性接受不优的解，后者相当于物理过程中粒子的随机跳动，它带来了晶体降温结果的随机性。而跳随机解的次数多少，则相当于降温的速度，降温的速度越慢，晶体回到原有结构的可能性更高，也就相当于跳解的次数越多，跑出最优解的可能性更高。\n\n先放一张图感性理解一下\n\n![](https://pic.imgdb.cn/item/63f75151f144a01007973ad6.webp)\n\n有一个比较有趣的比喻\n\n爬山算法：一个兔子从一个点往高爬，爬到了一个山顶，但是不知道这个山顶是不是珠穆朗玛峰  \n模拟退火：一个兔子喝醉了乱跳，跳到了某个山顶也要继续跳到别的山坡，但是它逐渐清醒，向最高点跳去\n\n感性理解后我们详细讲解一下算法过程。\n\n## 算法过程\n\n设定好“初始解”，“初始温度”与“下降速度”，每一次“降温”都得到一个新解，于是出现两种情况，即新解优于旧解或不优于旧解。优于旧解显然是要接受的，但是只接受优解可能只能找到局部最优，与爬山算法无异，因而我们对于一个不优的解还需要进一步处理。\n\n而这一步处理（可能是）模拟退火的精髓所在，是把这个随机化算法和热力学/统计力学等连接起来的部分，即接受这个不优解的概率。\n\n摘自维基百科\n\n> 玻尔兹曼分布是状态能量与系统温度的概率分布函数，给出了粒子处于特定状态下的概率\n\n公式即为\n\n$$\np_i = \\frac{1}{Q} e^{\\frac{-\\epsilon_i}{kT}}\n$$\n\n此处 $p_i$ 是状态 $i$ 的概率，$\\epsilon_i$ 为状态 $i$ 的能量，$k$ 为 Boltzmann 常数，$T$ 为温度\n\n啊当然这个并不是我们接下来需要用到的准则，只是引入一个热力学常量，即 Boltzmann 常数。同时下面的准则很大程度基于上面的玻尔兹曼分布（可能是，我目测的\n\n> 1953 年 Metropolis 提出了这样一个重要性采样的方法，即设从当前状态 $i$ 生成新状态 $j$，若新状态的内能小于状态 $i$ 的内能，即 $E_j<E_i$，则接受新状态 $j$ 作为新的当前状态；否则，以概率 $\\exp(\\frac{-(E_j-E_i)}{kT})$ 接受状态 $j$，其中 $k$ 为 Boltzmann 常数。\n\n上面的概率公式中 $\\exp$ 即 $e$ 的指数函数，同时两个状态能量的差 $E_j - E_i$ 可以表示为 $\\Delta E$，则可以写出一个（我）更容易理解的表达方式，即\n\n$$\np_j = e^\\frac{-\\Delta E}{kT} \n$$\n\n总的来说，概率 $p_{new}$ 可以表示为\n\n$$\np_{new} = \n\\begin{cases}\n1, & \\text{if } \\operatorname{E}(x_{new}) < \\operatorname{E}(x_{old}) \\newline\ne^\\frac{-\\Delta E}{kT} & \\text{if } \\operatorname{E}(x_{new}) \\geqslant \\operatorname{E}(x_{old})\n\\end{cases}\n$$\n\n概率处理完了，主要算法部分也基本上结束了，下面我们引入一道例题。\n\n## 例题\n\n#### [TJOI2010]分金币\n\n##### 题目描述\n\n现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n\n##### 输入格式\n\n**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n\n对于每组测试数据的格式为：\n\n每组测试数据占两行。\n\n第一行是一个整数 $n$，表示金币的个数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。\n\n##### 输出格式\n\n对于每组数据输出一行一个整数表示答案。\n\n#### 样例 #1\n\n###### 样例输入 #1\n\n```\n2\n3\n2 2 4\n4\n1 2 3 6\n```\n\n###### 样例输出 #1\n\n```\n0\n2\n```\n\n## 提示\n\n#### 数据规模与约定\n\n- 对 $30\\%$ 的数据，保证 $1 \\leq v_i \\leq 1000$\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。\n\nTODO","tags":["随机化","模拟退火"],"categories":["算法"]},{"title":"细菌 题解","path":"/post/xijun-solution/","content":"## 题意\n\n一张有向无环带权图，有一个初始值 $k$，从入口进入后每过一条边 $i$ 则 $k = k \\times 2+w_i$（$w_i$ 为边权，有正有负），要求从入口到出口的过程中始终 $k>0$，求使方案存在的最小初始值 $k$。\n\n## 思路\n\n~~之前什么答辩题面~~\n\n先忽略 $k$ 经过一条边时翻倍，只考虑加边权，如何求出答案？由于图带边权，保证不出现环，同时判断一个 $k$ 值是否合法的方式实际上是计算一条路径边权和并与 $k$ 比较，联想到最短/长路。\n\n新题面中提到只需**存在**一种方案能让出口 $k>0$ 即可，显然是最短路。但是如果从起点求最短路还要考虑 $k$ 的影响，因此反向建图，终点初始值设为 $1$，从终点跑即可。\n\n由于边权有正有负，只能跑 SPFA。\n\n再考虑 $k$ 的变换还有一个 $\\times 2$，因此跑反向的 SPFA 松弛边时需要把新算出的 $dist_i$ 值除以 $2$。\n\n## 代码\n\n```cpp\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\n// 模板函数可以参考博文 https://blog.tibrella.space/post/2023-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%9D%82%E8%B0%88%E4%B8%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/\ntemplate <typename Type>\nvoid read(Type& _x) {\n    _x = 0;\n    bool f;\n    char ch;\n    f = 0;\n    do {\n        ch = getchar();\n        if (ch == '-') f = 1;\n    } while (ch < 48 || ch > 57);\n    do {\n        _x = (_x << 3) + (_x << 1) + (ch ^ 48);\n        ch = getchar();\n    } while (ch > 47 && ch < 58);\n    _x = f ? -_x : _x;\n}\n\ntemplate <typename Type>\nType max(Type _a, Type _b) {\n    return _a > _b ? _a : _b;\n}\n\nusing std::bitset;\nusing std::queue;\n\n#define N 105\n\nstruct edge {\n    edge* nex;\n    int u, v, w;\n} graph[N * N];\nedge* fir[N];\nint dis[N];\nedge* idx = graph;\nint n;\n\nqueue<int> q;\nbitset<N> st;\n\nvoid add(int u, int v, int w) {\n    ++idx;\n    idx->u = u;\n    idx->v = v;\n    idx->w = w;\n    idx->nex = fir[u];\n    fir[u] = idx;\n}\n\nvoid spfa(int nod);\n\nint t1;\n\nint main() {\n    read(n);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            read(t1);                // 中转变量\n            if (t1) add(j, i, -t1);  // 反向存图\n        }\n    }\n\n    spfa(n);\n\n    printf(\"%d\", dis[1]);\n\n    return 0;\n}\n\nvoid spfa(int nod) {\n    st.reset();\n    memset(dis, 0x3f, sizeof dis);\n    dis[nod] = 1;\n    st[nod] = 1;\n    q.push(nod);\n\n    while (!q.empty()) {\n        nod = q.front();\n        q.pop();\n        st[nod] = 0;\n        for (edge* e = fir[nod]; e; e = e->nex) {\n            if (dis[e->v] > max(1, (dis[nod] + e->w + 1) / 2)) {  // +1 防止除法向下取整造成错误\n                dis[e->v] = max(1, (dis[nod] + e->w + 1) / 2);\n                if (!st[e->v]) {\n                    q.push(e->v);\n                    st[e->v] = 0;\n                }\n            }\n        }\n    }\n}\n\n```","tags":["SPFA"],"categories":["题解"]},{"title":"倍增求LCA/最近共同祖先","path":"/post/multiply-lca/","content":"倍增求 LCA 是一种~~不太~~高效[^1]的求 LCA 算法，时间复杂度为 $\\operatorname{O}(n \\log n) \\sim \\operatorname{O}(\\log n)$\n\n## 原理\n\n### 初始\n\n维护一个 $fa_{i,x}$ 表示 $x$ 往根节点走 $2^i$ 步到达的节点。\n\n* 初始化时 $fa_{0,x} = father_x$\n* 更新为 $fa_{i,x} = fa_{i-1,fa_{i-1,x}}$\n\n### 查询\n\n中心思想是利用二进制向上跳。  \n假设目前要查询 a 号节点和 b 号节点的 LCA，将较深节点设为a，较浅设为b，即：\n\n* 首先将 a 向上跳到和 b 同一高度，若此时 a = b，直接返回 b 即可，即 b 为 a 的一个直接父亲，LCA 也一定是 b。\n* 否则将两个节点同时往上跳，$i$ 从大到小，每次跳 $2^i$，规则如下：\n    1. 如果跳完两个节点相同，即找到了一个共同祖先，则不跳，因为此时**不能确定**这个共同祖先是不是**最近的**。\n    2. 否则就继续同时往上跳，最终返回 $fa_{0,a}$ 即可。\n\n[^1]: 不如树剖好想好写，也不如树剖快。真要高效的话，建议欧拉序 RMQ 复杂度解决。","tags":["树","倍增"],"categories":["图论"]},{"title":"C++ 语言特性杂谈与常数优化","path":"/post/cpp-misc-opt/","content":"起因是发现很多同学对常数优化和语句的执行效率有误解（我肯定也有，但是我尽量把我知道的正确的写出来），因此写一篇杂谈做一个说明，同时介绍一些比较新的好用的语言特性（C++14）\n\n## `template` 模板关键字\n\n### 函数\n\n`template` 顾名思义是用来做模板的，那是做什么的模板呢？\n举个例子，一般来说我们写 `max` 函数替代 `std::max` 来优化的时候，写出来的大概长下面这样：\n\n```cpp\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n```\n\n在这三行代码中，第一行定义了 `max` 的返回值和参数 `a` `b` 的类型为 `int`，显然意味着这个函数只能比较 `int` 类型的量。\n\n那么如果既想要比较 `int` 又想要比较 `long long` 还想比较 `char` 等等，如果按传统的写法，就是 Ctrl+C Ctrl+V 写好几个比较函数，还得重新命名，甚是麻烦。\n\n观察写出来的几个函数，肉眼可见他们的本质区别只有返回值与参数的类型。那么有没有一种类似模板的东西，写一个函数的主要部分作为模板，返回值、变量的类型由编译器决定呢？\n\n这就是 `template` 的一大作用，也是 OI 中最常用的方面。\n\n使用起来也很简单，在函数声明前面加上 `template <typename T>`，此处 T 可以是随便一个字母或者单词，后面写函数的时候把 `int` 替换成 `T` 即可。\n\n```cpp\ntemplate <typename T>\nT max(T a, T b) {\n    return a > b ? a : b;\n}\n```\n\n此时的 `T` 相当于一个变量类型，如果这个函数被调用，编译器会给你生成一个符合传入参数的类型的 `max` 函数。\n\n当然了，如果是一个没有传参的函数，我们也能指定其类型。  \n这样写会报错：\n\n```cpp\ntemplate <typename T>\n T read() {\n\t T a;\n\t cin >> a;\n\t return a;\n }\n\nint a = read();\n```\n\n原因是没有传参进去，编译器无法推断模板函数的类型。  \n类比 [STL 容器](/post/cpp-stl-container) 中的使用方法，能不能用尖括号带一个类型名称进去呢？可以的。\n\n```cpp\ntemplate <typename T>\n T read() {\n\t T a;\n\t cin >> a;\n\t return a;\n }\n\nint a = read<int>();\n```\n\n这样写就不会报错了\n\n### 模板类\n\n和模板函数类似，我们可以泛化结构体中的类型。\n\n```cpp\nstruct qwq {\n\tint age\n};\n```\n\n~~存紫妈的年龄~~可能会爆 `int`，~~存阿求的年龄~~可能浪费 `long long` 的空间，于是可以：\n\n```cpp\ntemplate <class T>\nstruct qwq {\n\tT age;\n};\n\nqwq<int8_t> akyuu;\nqwq<__int128> yukari;\n```\n\n这样，`akyuu.age` 的类型即是 `int8_t`，`yukari.age` 的类型即是 `__int128`。\n\n### TODO: `...` 关键字\n\n## 基于范围的循环\n\n不过多介绍了，主要在 STL 里用\n\n```cpp\nfor (auto i : container) {\n    std::cout << i << ' ';\n}\n```\n\n`container` 为容器的名称，`auto` 是 C++11 以后的类型名称，编译时由编译器推断。\n\n此处 `auto` 的效果就是把 `i` 的类型设置为 `container` 的元素的类型。如果 `container` 是 `vector<int>` ，则上面语句的效果就是遍历 `container` 的所有元素并输出。\n\n此外，如果想遍历的同时修改容器中的元素，可以在 `i` 前加取址符 `&` 表示引用，如下\n\n```cpp\nfor (auto &i : container) {\n    i = 0;\n}\n```\n\n该段代码的效果即为遍历容器 `container`，同时把其中所有元素赋值为 `0`;\n\n## 函数相关\n\n### Lambda 表达式\n\n实际上就是定义了一个函数。\n\n基本语法：\n\n```cpp\n[捕获](参数){\n\t// some code...\n}\n```\n\n捕获一般没啥用，留空就好。\n\nLambda 表达式在 C++ 中是一个类型，但是不能用类型名定义，所以用 `auto` 声明。  \n举个例子，编写 `max` 函数：  \n原来是这样的\n\n```cpp\nint max(int a, int b) {\n\treturn a > b ? a : b;\n}\n```\n\n用 Lambda 表达式长这样：\n\n```cpp\nauto max = [](int a, int b) { // 捕获部分留空，传参和内部实现不变\n\treturn a > b ? a : b;\n};\n```\n\n看起来这两种方式没有什么区别，确实是这样，但是 Lambda 还有一个重要性质——匿名。\n\n显然，原来写函数的时候必须要声明，声明这个函数的名称，返回值类型，传参类型，内部实现。  \n但是观察到上面声明 Lambda 表达式 `max` 的时候，使用的是类似变量赋值的方法。那是不是只留下等式右边的部分也可以当函数使用？实际上是可以的，这就是 Lambda 函数的匿名性质。即引入 Lambda 表达式之后，就可以随时随地定义函数而不给它起名字。  \n听起来有点抽象，再举个例子：`std::sort`  \n原来我们想要自定义比较函数，只能这样：\n\n```cpp\nbool cmp(int a, int b) {\n\treturn a > b;\n}\n\n...\n\nstd::sort(a.begin(), a.end(), cmp);\n```\n\n引入 Lambda 表达式之后：\n\n```cpp\nstd::sort(a.begin(), a.end(), [](int a, int b){return a > b;});\n```\n\n在这里，我们并没有给比较函数起名字，就直接扔到了 `std::sort` 里面，这样做方便很多~\n\n读者可能有疑问：这样做效率如何？事实上，Lambda 表达式和下面的函数对象的效率都是比较高的，比第一种方式中 `cmp` 这种函数指针效率高。\n\n### 函数对象\n\n假定你已经学会了类/结构体的运算符重载。\n\n观察函数组成 `function()`，它是不是非常像一个类型 `function` 搭配上了 `()` 这个运算符？太像了！\n\n那我们是不是可以这样做：开一个对象，重载 `()` 这个运算符再当函数用？当然可以。  \n还是用 `max` 举例：\n\n```cpp\nstruct qwq {\n\tint operator() (int a, int b){\n\t\treturn a > b ? a : b;\n\t}\n};\n\nqwq max;\n\n...\n\na = max(a, b);\n```\n\n非常自然，非常易懂。\n\n### 效率\n\n~~懒得测了。~~  \n~~可以参考下 [这个博客](https://blog.csdn.net/u011392018/article/details/39028457)~~\n\n利用如上链接内方式测试的结果是：差不多。","tags":["C++","常数优化","语言特性"],"categories":["C++"]},{"title":"Manacher","path":"/post/manacher/","content":"update: 2023/6/7 重画图片（全部由 Krita + 鼠标 完成）\n\n求一个字符串最长的回文子串。\n字面意思，回文就是一个串正着读倒着读一样，子串就是一个连续的子序列。\n\n## 预处理\n\n不难发现对于一个回文字串，有两种情况：\n\n1. $\\texttt{ABBA}$ 即长度为偶数，没有中心字符，半径为 $2$，长度为 $4$\n2. $\\texttt{ABCBA}$ 即长度为奇数，有中心字符，半径为 $3$，长度为 $5$\n\n懒得给他们处理两种情况，怎么办？只需要插入一些其他字符即可。  \n比如说我们可以在头部插入一个 $\\texttt?$ 代表串开始，$\\texttt^$ 代表串结束，然后在新串的每一个字符之间插入一个 $\\texttt#$ 号，得到的新串就能达到简化情况的目的。  \n按照上面的方法处理之后，原来的两个串会变为：  \n（只观察回文子串）\n\n1. $\\texttt{?#A#B#B#A#^}$ 长度变为奇数，有中心字符，半径为 $5$，长度为 $9$\n2. $\\texttt{?#A#B#C#B#A#^}$ 长度为奇数不变，有中心字符，半径为 $6$，长度为 $11$\n\n情况被简化成一种，即长度为奇数。与此同时我们发现，新串的回文子串的 **半径 $-1$** 就是原串回文子串的 **长度**\n\n与此同时，问题不变，还是求串的最长回文子串。\n\n```cpp\nvoid init(std::string& b) {\n    b += '$';\n    b += '#';\n    for (int i = 0; i < n; ++i) {\n        b += a[i];\n        b += '#';\n    }\n    b += '^';\n    n = b.size();\n}\n```\n\n## Manacher\n\n### 基本思想\n\n~~抽象来说~~就是对于字符串的每一个位置，维护以这个位置为中心的最长回文串长度同时算出这个回文串的右边界，再通过这个右边界来更新下一个位置的最长回文串长度与右边界。\n\n具体来说，对于一个字符串 $S$，开一个数组 $P_i$ 记录以 $i$ 为中心的最长回文串半径（含 $S_i$），变量 $mid$ 为在 $i$ 之前边界最靠右的回文子串的中心，$mr$（也就是 $maxright$）记录这个回文子串的右边界，通过这些更新下一个位置的这些值。\n\n为了方便说明，以 $i$ 为中心的最长回文子串称为 $T_i$\n\n#### 继承对称点的数据\n\n当前状态：\n\n![](https://pic.imgdb.cn/item/648048c91ddac507ccdcc735.webp)\n\n枚举到 $i$ 后，对于 $mr$ 和 $i$ 来说有两种情况：$i$ 在 $mr$ 内或在 $mr$ 外\n\n- $i$ 在左侧\n  即 $i$ 被 $T_{mid}$ 包含。  \n  显然 $i$ 之前的 $P_k, k < i$ 都是已知的，$i$ 在 $mid$ 为中心的回文子串内，那么一定存在 $j$ 是 $i$ 关于 $mid$ 的对称点，想办法从 $P_j$ 推出 $P_i$，则  \n  ![](https://pic.imgdb.cn/item/648050fa1ddac507ccea1002)\n  那么 $P_j$ 已知，对于以 $j$ 为中心的最长回文子串 $T_j$ 来说有两种情况\n\n  1. $T_j$ 被 $T_{mid}$ 严格包含，由 $T_{mid}$ 的回文性质可知，此时 $P_i$ 可以继承 $P_j$ 的值，剩下的后续再推。\n  2. $T_j$ 未被 $T_{mid}$ 严格包含\n     ![](https://pic.imgdb.cn/item/64804cb51ddac507cce2a40d)\n     容易发现，两个青色串一定对称（$T_{mid}$ 的回文性质），又因为 $T_j$ 的回文性质，得到两个青色串，左青色串和橙色串分别对称。\n     此时 $T_i$ 一定被 $T_{mid}$ 严格包含。因为如果不被严格包含，则 $P_{mid}$ 的值仍可以增大，如下图  \n     ![](https://pic.imgdb.cn/item/64804ed51ddac507cce5d0b5)\n     图中蓝色块通过 $T_{mid}$ 串回文的性质已知相等，每个蓝色块均可以通过自身所在回文串推出其外侧橙色块也是相等的。  \n     显然这种情况不会出现，因为这种情况下 $P_{mid}$ 是一个假值，而以上递推过程的前提是前面的值保证正确。\n\n- $i$ 在右侧  \n  没有可以继承的值则可以直接重新推，不需要过多考虑。\n\n```cpp\nif (i < mr) {\n    p[i] = min(p[(mid << 1) - i], mr - i);\n} else {\n    p[i] = 1;\n}\n```\n\n#### 更新 $P_i$\n\n直接从当前记录的半径向外继续枚举，直到遇到两个不相同的字符为止（边界上有 `$` `^`，枚举到一定会停止，所以不用考虑边界问题）。\n\n```cpp\nwhile (b[i - p[i]] == b[i + p[i]]) {\n    ++ p[i];\n}\n```\n\n#### 更新 $mr$ 和 $mid$\n\n前文说过 $mr$ $mid$ 都是边界最靠右的回文子串的属性，那么只需要判断新找到的回文子串右边界是否大于 $mr$ 即可。\n\n```cpp\nif (i + p[i] > mr) {\n    mr = i + p[i];\n    mid = i;\n}\n```\n\n至此 Manacher 算法主要过程结束。\n\n### 实现\n\n```cpp\nvoid init(std::string& b) {\n    b += '$';\n    b += '#';\n    for (int i = 0; i < n; ++i) {\n        b += a[i];\n        b += '#';\n    }\n    b += '^';\n    n = b.size();\n}\n\nvoid manacher() {\n    int mr = 0, mid;\n    for (int i = 1; i < n; ++i) {\n        if (i < mr) {\n            p[i] = min(p[(mid << 1) - i], mr - i);\n        } else {\n            p[i] = 1;\n        }\n\n        while (b[i - p[i]] == b[i + p[i]]) {\n            ++p[i];\n        }\n\n        if (i + p[i] > mr) {\n            mr = i + p[i];\n            mid = i;\n        }\n    }\n}\n```\n\n### 时间复杂度[^1]\n\n当 $P_j$ 左侧取到左边界及以外时，$P_i$ 才需要更新（其他情况都因为不满足条件而不用进循环），而右端点是单调递增且严格小于等于 $n$ 的，因此总时间复杂度为 $\\operatorname{O}(n)$\n\n[^1]: 参考[谷雨的笔记](https://www.acwing.com/file_system/file/content/whole/index/content/7964832/)","tags":["字符串","算法","Manacher"],"categories":["字符串"]},{"title":"树状数组","path":"/post/binary-indexed-tree/","content":"> 树状数组代替线段树。 —— zzz《常数优化与 NOILinux》\n\n顾名思义，树状数组是一种树形结构，但是因为他独特的结构和拆分方式（二进制你又来了是吧），可以直接用数组存储。  \n用途是解决大部分区间修改查询问题，复杂度一般是 $\\operatorname{O}(\\log n)$ ，同时常数小（暗示 [线段树](/post/segment-tree) 不行），同时码量小，好理解（暗示 \\* 2），但是复杂的区间修改查询问题不能解决，同时区间最大最小值也不能用它处理（后文会说）\n\nUpdate on 2023/6/7 本质上就是能够以极小的常数且严格 $\\operatorname{O}(\\log n)$ 的时间复杂度进行单点修改与前缀和的维护，不过这个前缀和可以玩得比较花。\n\n实际上原理看看就得了，这玩意板子写完了半年过去都不带忘的...\n\n关于常数差距到底多大？S2 的同学们可以看看 S2OJ # 786，使用普通快读仅 2.60s（现在最快的我的提交记录是卡常版的），线段树解法貌似最快的是 lyq 学长的 6.69s。\n\n## 基本树状数组\n\n### 原理\n\n来自学长的一张图  \n**注意**下文基本上所有东西都可以/需要搭配这个图进行理解\n\n![](https://pic.imgdb.cn/item/63d613b2face21e9ef36c9df.jpg)\n\n以求区间和的树状数组为例，树中每一个节点存储一段区间的和，询问时进行前缀和加减即可得出任意区间的和。  \n分区间的方法即利用二进制，对于第 $i$ 节点来说，$i$ 的二进制形式中最低一位 `1` 的位置为 $x$，那么 $tree_i$ 就存储了 $[i-2^x+1,i]$ 区间的和。  \n注意此处 $x$ 从 `0` 开始算  \n以 $3$ 为例，$3$ 的二进制为 `0000 0011`，最低一位 `1` 的位置是 0，则 $tree_3$ 存储 $[3-1+1,3]$ 即 $[3,3]$ 的区间和。  \n再以 $8$ 为例，$8$ 的二进制为 `0000 1000`，最低一位 `1` 的位置是 3，则 $tree_8$ 存储 $[8-8+1,8]$ 即 $[1,8]$ 的区间和。\n\n<!-- TODO: 制作动画 -->\n\n### 实现\n\n#### 建立\n\n实际上不用特意处理建立，直接在输入过程中每输入一个数就[修改](#单点修改)即可。\n\n```cpp\nfor (int i = 1; i <= n; ++i) {\n    cin >> t1; // tmp\n    modify(i,t1);\n}\n```\n\n#### lowbit\n\n本函数实现查找一个数最后一位 $1$ 的位置。\n\n首先声明一个冷知识（大概冷），位运算是针对内存中存储的原数据的运算，换句话说，进行位运算的是补码而不是原码。\n\n**原码**即一个数本身的二进制表示，**反码**即在原码的基础上符号位不变其他位取反。  \n**补码**分类来说，正数的补码是它的原码，负数的补码为其反码$+1$。\n\n在这里我们只考虑最后一位 `1` 及它后面的 `0`。  \n比如 `0011 0100` 这个二进制数，我们先把它变成负数，即按位取反后加一（易证这就是他的相反数），变为 `11001011` 再变为 `11001100`。  \n发现了一件神奇的事情，原来最低一位 `1` 竟然回来了！  \n显然，这位 `1` 前面的所有数字因为被取反所以和原数完全不同；后面的所有数字原来一定是 `0` 取反后变成一排 `1`，负数的补码是反码$+1$，从而一直进位到原来最后一位 `1` 这里，而它们本身变回了 `0` ；又因为这位 `1` 被取反后是 `0` 所以无论如何都不会再向前进位。  \n从而保证对于任意一个正数 $x$，$-x$ 与 $x$ 的存储只有 $x$ 本身最后一位 `1` 是相同的。  \n因此 `lowbit()` 的实现就非常简单了，直接用 `x&-x`，得到的结果就是[原理](#原理)中所说的 $2^x$，又快又好想，用着还方便。\n\n```cpp\nint lowbit(int x) {\n    return (x&-x);\n}\n```\n\n#### 单点修改\n\n假设修改为给第 $x$ 个数增加 $v$，那我们就需要修改所有包含第 $x$ 个元素的节点，则从第 $x$ 个节点寻找父亲节点直到根节点为止（参考上图）。  \n$x$ 节点的直接父亲是 $x+\\operatorname{lowbit}(x)$，因此直接一层循环实现 $\\operatorname{O}(\\log n)$ 修改。\n\n```cpp\nvoid modify(int x, int v) {\n    for (int i = x; i <= n; i += lowbit(i)) {\n        tree[i] += v;\n    }\n}\n```\n\n#### 区间查询\n\n查询区间为 $[l,r]$ 时，将问题转化为求 $[1,r] - [1,l-1]$ 的值（前缀和知识），因此我们只需要实现查询前缀和的功能即可。  \n因为 $i$ 节点存储的是一段长度为 $\\operatorname{lowbit}(i)$ 的区间的和，因此取完 $i$ 号点的值后再取 $i-\\operatorname{lowbit}(i)$ 号节点的值，直到位置变为 $0$（到头）即可（看不懂就结合上面图）\n\n```cpp\nint query(int x) {\n    int res = 0;\n    for (int i = x; i; i -= lowbit(i)) {\n        res += tree[i];\n    }\n    return res;\n}\n\nans = query(r) - query(l-1);\n```\n\n## 改区间查单点\n\n上文我们解决了求前缀和的问题，本次需要查询单点，那么很容易联想到**差分**。更改区间对应改差分数组上的两个点，查询单点对应查询差分数组的前缀和。\n\n## 区间加区间求和\n\n~~发现树状数组好快于是回来补一下~~（2023.6.23）\n\n对原数组进行差分，易得：\n\n$$\nd_i = a_i - a_{i-1} \\newline\na_i = \\sum_{j=1}^i d_i \\newline\n$$\n\n取 $[1,x]$ 的区间和，即为：\n\n$$\n\\begin{aligned}\nans &= \\sum_{i=1}^x a_i \\newline\n&= \\sum_{i=1}^x\\sum_{j=1}^{i} d_i \\newline\n&= \\sum_{i=1}^x d_i(x-i+1) \\newline\n&= \\sum_{i=1}^x(1+x)d_i-\\sum_{i=1}^x i\\cdot d_i\n\\end{aligned}\n$$\n\n第二行到第三行那里不知道怎么推出来的话，观察每个 $d_i$ 出现的次数，显然 $d_1$ 出现 $x$ 次，$d_2$ 出现 $x-1$ 次（除了 $i=1$ 的时候都出现了），于是轻松推出来。\n\n因此我们只需要维护两个树状数组，一个维护 $d_i$ 即差分数组，另一个维护 $i\\cdot d_i$ 即可。\n\n注意：此处树状数组维护的仍然是前缀和，$i\\cdot d_i$ 中的 $i$ 就是修改的位置，而不是树状数组修改时循环的 $i$。\n\n核心代码：\n\n```cpp\n#define N 100005\n\ni64 id[N], d[N];\ni32 n;\n\ninline void mod(i32 pos, i64 val) {\n    for (i32 i = pos; i <= n; i += lowbit(i)) {\n        id[i] += pos * val;\n        d[i] += val;\n    }\n}\n\ninline i64 que(i32 pos) {\n    i64 res = 0;\n    for (i32 i = pos; i; i -= lowbit(i)) {\n        res += d[i] * (pos + 1) - id[i];\n    }\n    return res;\n}\n\ninline void modify(i32 l, i32 r, i64 val) {\n    mod(l, val);\n    mod(r + 1, -val);\n}\n\ninline i64 query(i32 l, i32 r) {\n    return que(r) - que(l - 1);\n}\n```","tags":["树状数组"],"categories":["数据结构"]},{"title":"RMQ/ST表","path":"/post/sparse-table/","content":"目标是解决 RMQ 问题，即对于一个大区间，短时间内查询一个小区间的最大最小值\n\n下文以最大值为例说明\n\nST 表本质上是一个动态规划（倍增的）\n\n先利用倍增（二进制拆分）预处理然后 $\\operatorname{O}(1)$ 查询，比线段树快，但是只支持静态区间\n\n## 原理\n\n### 预处理\n\n$f_{i,j}$ 表示从 $i$ 开始，长度为 $2^j$ 的区间中的最大值\n\n预处理阶段，对于 $f_{i,j}$ 来说，直接\n$$\n    \\max\\{ f_{i,{j-1}},f_{i+2^{j-1},j-1} \\}\n$$\n递推即可，非常容易想，时间复杂度为 $\\operatorname{O}(n\\log n)$\n\n### 查询\n\n对于一个区间 $[L,R]$ 来说，假设他的长度为 $len$ \n\n![](https://pic.imgdb.cn/item/63d4c4b0face21e9ef9f3cb9.jpg)\n\n很容易能找到一个 $k$ 使得\n$$\n    \\frac{len}{2} < 2^k \\leqslant len\n$$\n\n![](https://pic.imgdb.cn/item/63d4c785face21e9efa61b8e.jpg)\n\n显然 $[L,R]$ 被 $[L,2^k],[R-2^k-1,k]$ 严格包含，因此 ST 表中查询最大最小值的时间复杂度是常数级别的，而不是线段树的 $\\log$ 级别  \n查询结果就是 $\\max\n\\{f_{L,2^k},f_{R-2^k-1k,k}\\}$\n\n\n至于 $k$，肉眼可见 $k=\\lfloor\\log _2 (len)\\rfloor$  \n此处可以直接使用 `cmath` 库中的 `log()` 函数，它是用来求以 10 为底的对数的\n根据换底公式[^1]可知 $$k=\\lfloor\\log_2(len)\\rfloor=\\lfloor \\frac{\\lg(len)}{\\lg2} \\rfloor$$\n\n\n## 实现\n\n首先是初始化\n```cpp\nfor (int j = 0; j < M; ++j) {\n    for (int i = 1; i + (1 << j) - 1 <= n; ++i) {\n        if (!j) {\n            f[i][j] = w[i];  // 从 i 开始长度为 2^0=1 的区间最大值为 i 本身\n        } else {\n            f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);\n        }\n    }\n}\n```\n然后是查询\n```cpp\nint query(int l, int r) {\n    int len = r - l + 1;\n    int k = log(len) / log(2);\n\n    return max(f[l][k], f[r - (1 << k) + 1][k]);\n}\n```\n\n## 动态修改\n\n这个标题比较诡异，因为我提到过\n\n>只支持静态区间\n\n但是实际上我们可以用一些小 trick 实现在 st 表的尾部增加值。（前提是题目要求比较少，比如目前这道题只需要在尾部增加数，同时只需要查询尾部某长度区间的最值）  \n显然对于 st 表的每一个 $f_{i,j}$ 来说，他只会用到 $f_{k,j}$,$k>i$ 的值而不会用到前面的值，因此我们给他做一个倒转。  \n换句话说，现在 $f_{i,j}$ 表示从 $i$ 开始，向前长度为 $2^j$ 的区间中的最大值。  \n代码如下\n```cpp\nvoid add(int a) {\n    a += t;\n    a %= d;\n    ori[++tail] = a;\n    for (int j = 0; tail - (1 << j) + 1 > 0; ++j) {\n        if (!j) {\n            f[tail][j] = a;\n        } else {\n            f[tail][j] = max(f[tail][j - 1], f[tail - (1 << j - 1)][j - 1]);\n        }\n    }\n}\n\nvoid query(int len) {\n    int l = tail - len + 1;\n    int k = log2(len);\n    t =  max(f[tail][k], f[l + (1 << k) - 1][k]);\n}\n```\n\n\n[^1]: \n$$\n\\log_xy=\\frac{\\log_cy}{\\log_cx} \n$$","tags":["RMQ"],"categories":["数据结构"]},{"title":"并查集","path":"/post/dsu/","content":"今天讲的最短路啥的感觉有点费劲，先把并查集的东西写了\n\n## 用途\n\n基本上用来处理 **关系**  \n什么是关系？比如一个人和他的表弟是亲戚，亲戚的关系可以人为理清，\n但是~~毒瘤的~~出题人会给这个人安上 114514 个表弟这些表弟的 1919810 个其他亲戚以及 1145141919810 个其他无关的人，然后问你这个序列里面第 $a$ 个人和第 $b$ 个人是不是亲戚，一般的方法显然处理不了，而并查集就是专门用来解决这种东西用的。\n\n## 实现\n\n“并查集”的操作就是前两个字，即合并与查询。  \n此处默认以树实现并查集。\n\n### 合并\n\n合并的操作即把两棵树的根节点连接在一起，文字解释不清楚，但是直接用树结构实现就比较清楚了。\n\n这里我们只需要开一个数组 $F$ 存储每一个节点的祖先，每次更改 $i$ 节点的祖先只需要修改 $F_i$ 的值\n\n比如目前我们有五个点\n\n![](https://pic.imgdb.cn/item/63c64e44be43e0d30eb8b23d.png)\n\n然后由输入数据可知，`1` 和 `3`，`2` 和 `4`，`5` 和 `4`，`4` 和 `1` 是亲戚，于是我们把 `1` 设为 `5` 的祖先来表示他们的关系， `2` `4` 同理，相当于把这四个集合（或者说树）两两合并\n\n![](https://pic1.imgdb.cn/item/63c65028be43e0d30ebcaa53.jpg)\n\n下一步\n\n![](https://pic1.imgdb.cn/item/63c6526dbe43e0d30ec1760c.jpg)\n\n以及把以 `4` 为根的这棵树合并到 `1` 上，连接他们的根节点\n\n![](https://pic.imgdb.cn/item/63c657d0be43e0d30ecda861.jpg)\n\n这样我们就基本完成了这个集合的初始化，我们只需要再把根节点 `1` 的祖先设置为自己，来表示它是这棵树的根节点（应该在合并之前初始化每一个结点的祖先为自己，因为图可能会不太清楚所以改到这里了）\n\n![](https://pic.imgdb.cn/item/63c6595cbe43e0d30ed06172.jpg)\n\n代码实现思路就很清楚了\n\n```cpp\nvoid uni(int x, int y) {\n    // 查询两个节点所在树的根\n    xx = find(u);\n    yy = find(v);\n\n    if (xx != yy) f[xx] = yy; //连接根节点\n}\n/*\n...\nint main() {\n    .....\n    cin >> m >> n; // m 为人数，n 为关系数\n    int f[m+10], u, v;\n    int p,q;\n    memset(f,0,sizeof 0);\n    for (int i = 1; i <= m; ++i) {\n        f[i] = i;\n    }\n    ...\n}\n*/\n```\n\n### 查找\n\n假如我们需要查找上一张图里面 `2` `3` 是否是亲戚，如何操作呢？\n\n很容易发现，`2` `3`两个节点在同一棵树中，也就是说我们可以直接查找这两个节点的根节点，如果相同则是亲戚。查找的实现也很简单，直接递归寻找上一级的父亲节点，如果一个节点的祖先是自己，就直接输出这个节点即可\n\n```cpp\n// 查询 pos 的根\nint find(int pos) {\n    if (f[pos] == pos) return pos; // 边界\n    return find(father[pos]);\n}\n```\n\n## 优化\n\n由上文可以发现，在并查集中查找一个节点的祖先最坏情况下的时间复杂度是 $O(h)$ 的（$h$ 为树的最大深度），那么就可以通过减小最大深度来优化并查集。\n\n### 按树的大小合并\n\n假如说我们有这样两棵树\n\n![](https://pic.imgdb.cn/item/63c66020be43e0d30edcc678.jpg)\n\n现在 `1` `5`两个节点是亲戚，那么把 `5` 的祖先设为 `1` 合适还是反过来合适呢？  \n显然是前者\n\n如果按照前者合并，结果就是\n\n![](https://pic.imgdb.cn/item/63c66135be43e0d30edef9df.jpg)\n\n最大深度是 3\n\n如果按照后者合并，最大深度为 4\n\n![](https://pic.imgdb.cn/item/63c66158be43e0d30edf4e8c.jpg)\n\n也就是说，为了让 $h$ 尽可能地小，需要把深度/体积小的树合并到深度大的树上，作为大深度/体积树的子树\n\n此处定义一个 $R$ 数组记录以 $i$ 为根节点的树的最大深度为 $R_i$\n（$R$ 的修改在初始化/添加关系时修改）\n\n```cpp\nvoid uni(int x, int y) {\n    int xx = find(x);\n    int yy = find(y);\n\n    if (xx == yy) return; // 在同一棵树中不需要合并\n\n    if (r[xx] >= r[yy]) {\n        f[yy] = xx;\n        r[xx] = max(r[xx],r[yy]+1); // 可能合并后 y 树深度 +1 大于 x 树最大深度\n    } else {\n        f[xx] = yy;\n        r[yy] = max(r[yy],r[xx]+1);\n    }\n}\n```\n\n### 路径压缩\n\n![](https://pic.imgdb.cn/item/63c66407be43e0d30ee5216d.jpg)\n\n以上两棵树显然右侧的树更优，因为它的最大深度更小\n\n并查集的查询方式为“查询根节点”，这意味着我们查询时只需要关注查询最终的根节点，而不用关心查询途中经过的节点，这就是路径压缩的原理。路径压缩即把一个没有连着根的节点（如上图左侧的`4` `5` `6` `7`），“跳过”所有中间节点，直接把它连到根节点上。  \n对于上图来说，就是把 `4` `5` `6` `7` 摘出来连接到 `2` `3` 的父节点上，即 `1`，于是形成了右图，最大深度从 2 降到了 1。\n由于并查集相关的题目中可能初始化之后仍然有需要增删的元素，同时路径压缩也需要耗费时间，所以我们只在查询需要的点时优化。\n\n```cpp\nint find(int x) {\n    if (x != f[x]) { // 如果 x 不是根节点\n        f[x] = find(f[x]);\n    }\n    return f[x];\n}\n```\n\n新的查询函数可以结合上图理解。","tags":["并查集"],"categories":["数据结构"]},{"title":"图论基础","path":"/post/basic-graph/","content":"图论是嗜血分支[^1]，相应的，图论基础并没有什么太多需要思考的东西，只有一堆该死的概念等着记，有如绳之以法抽象了\n\n## 基本概念\n\n### 图\n\n由顶点（点）（Vertex）的集合和边（Edge）的集合组成，记为 $\\mathbb{G} = (\\mathbb{V}+\\mathbb{E})$  \n点的集合用 $\\mathbb{V(G)}$ 表示，点用 $u,v$ 等符号表示  \n顶点的数量称为图的“阶”，用 $n$ 表示  \n边的集合用 $\\mathbb{E(G)}$ 表示，边用 $e$ 等符号表示  \n边的个数称为图的“边数” ~~感觉说了和没说一样~~，用 $m$ 表示\n分量：一个图的子图（涉及：[强连通分量](/post/strong-cc)）\n\n### 图的种类\n\n从 $u$ 到 $v$ 的无向边： $(u,v)$  \n从 $u$ 到 $v$ 的有向边：$\\langle u,v \\rangle$\n\n有向图：图的所有边都是有向边  \n无向图：图的所有边都是无向边  \n完全图：每个点都与其他所有顶点连接；对于有向图来说，任意顶点 $u,v$ 都有边 $\\langle u,v \\rangle \\langle v,u \\rangle$  \n稀疏图/稠密图：边少/多的图  \n平凡图：一个点的图  \n零图：没有边的图  \n\n### 度\n\n对于顶点 $v$ 来说  \n入度 $ID(v)$：以 $v$ 为终点的边的个数  \n出度 $OD(v)$：以 $v$ 为起点的边的个数  \n度 $D(v)$ = 入度 + 出度  \n\n度为奇数的点为奇点，度为偶数的顶点为偶点\n\n于是可得：对于图 $\\mathbb{G}$ 中所有顶点的度=边数的两倍  \n以及推论：一个图中的奇点数量为偶数  \n\n简短证明：\n1. 每条边一定贡献一个出度一个入度共两个度  \n2. 度一定是偶数所以奇点的数量为偶数（奇$\\times$偶$=$偶）  \n\n## 存图\n\n无向图可以看作有向图但是两个点之间互相有一条有向边，所以只需要考虑有向图存图\n\n### 邻接矩阵\n\n基本思想是存两个点之间的边权（不连接即为 0 或 -1）\n\n比如当前图有四个点，则开数组 `g[5][5]`，初始化为 0。\n\n|   |1|2|3|4|\n|---|---|---|---|---|\n|**1**|0|0|0|0|\n|**2**|0|0|0|0|\n|**3**|0|0|0|0|\n|**4**|0|0|0|0|\n\n然后 1 到 2，3 到 1 有一条有向边，边权为 1，则修改 `g[1][2]` `g[3][1]` 为 1\n\n|   |1|2|3|4|\n|---|---|---|---|---|\n|**1**|0|1|0|0|\n|**2**|0|0|0|0|\n|**3**|1|0|0|0|\n|**4**|0|0|0|0|\n\n非常容易理解，缺点也显而易见，如果有 $114514$ 个点但是只有 $1$ 条边，那就需要开 $114514^2$ 的空间但是只有一个位置有数据，显然造成了巨大的浪费（空间早就炸了）  \n因此需要寻找一个只存边的存图方案，从而诞生邻接表\n\n### 邻接表\n\n考虑一件事情，对于一个图来说，有两个元素：点、边，而点的相关要素可以通过数组来以点为单位存储。  \n考虑存边：边的要素有三个，即起点、终点以及边权。考虑把边看作一个对象存储。\n\n#### 链式前向星\n\n用链表实现的邻接表\n\n先说链表，顾名思义，链状链接的列表，在这里我们把同一个起点边存到一个链表里。\n\n开一个结构体存链的每一个元素\n\n```cpp\nstruct edge {\n    int data;\n    int to;\n    edge *nex;\n};\n```\n显然，把链表每一个部分连接起来的东西就是指针 `nex`，`nex` 指向当前元素的下一个元素的地址。\n当然，如果开一个数组存储所有的元素，地址可以改为存储下标，即 `nex` 可以是一个整数，存储下一个元素在数组里的下标。\n\n[^1]: 数学，来自 [GrainRain谷神](https://grainrain.site)","categories":["图论"]},{"title":"在启用 ZSTD 压缩的 ZFS 根分区上安装 ArchLinux 并配置 Windows 双启动","path":"/post/archlinux-on-zfs-root-with-zbm/","content":"[ZFSBootMenu 基础使用](/post/zbm-guide) 和这篇文章的最后部分相同。\n本方案已经被实际测试过，完全可用，但是建议在有 Linux 基础的情况下折腾 ZFS，因为没准有某个地方我会忘记修改...\n\n## 总览\n\n分区大概长这样\n\n```TEXT\n分区1 300M FAT16 EFI\n分区2 128G ZFS   ArchLinux\n分区3 128G NTFS  Windows\n分区N **G  **FS  DATA // 其他分区\n```\n\n然后 ZFS 池里面长这样\n\n```TEXT\nzroot\n ├─ROOT\n |  ├─voidlinux // 实际上可以在这个池里安装多个 Linux，本处计划把所有 Linux 根分区数据集放在 zroot/ROOT/ 里\n |  └─archlinux\n └─data\n    └─home // 存放 /home\n```\n\nZFS 池那块看不懂没关系，只需要跟着文章做就行\n\n## 安装前\n\n准备一个有 ZFS 支持的 archiso，这里我们提供两个方案\n\n### CachyOS LiveCD（推荐）\n\n从 [CachyOS 的 Sourceforge 界面](https://sourceforge.net/projects/cachyos-arch/files/gui-installer/) 下载带 GUI 的 LiveCD（它的 CLI 安装器没 ZFS 支持），然后扔进 U 盘重启进入即可\n\n```SHELL\nsudo modprobe zfs # 加载 ZFS 模块\n\nsudo su # 切换到 root 用户\n\ntimedatectl set-ntp true  # 同步时间\n\nvim /etc/pacman.d/mirrorlist # 改镜像站\n# 开头添加\nServer = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch\n```\n\n### archiso-zfs\n\n此处使用 [eoli3n 的 archiso-zfs](https://github.com/eoli3n/archiso-zfs) 项目\n\n首先下载一个[官方的 ArchLinux LiveCD](https://archlinux.org/download/)，然后重启进入\n\n#### 联网\n\n```SHELL\niwctl # 进入 iwctl 命令行界面\n```\n\n下面的命令在 `iwctl` 中输入\n\n```SHELL\ndevice list # 列出可用设备\n# 假设上面列出的设备是 wlan0\nstation wlan0 scan\nstation wlan0 connect SSID # 连接名为 SSID 的网络\nexit\n```\n\n验证联网\n\n```SHELL\nping www.baidu.com\ntimedatectl set-ntp true  # 同步时间\n```\n\n#### 加载 ZFS 模块\n\n```SHELL\ncurl -s https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x\n```\n\n如果连接 github 有问题，则运行下面的命令替代\n\n```SHELL\ncurl -s https://ghproxy.com/https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x\n```\n\n执行过程因为网络原因会比较慢\n\n#### 改镜像站\n\n```SHELL\nvim /etc/pacman.d/mirrorlist\n# 开头添加\nServer = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch\n```\n\n至此，环境准备完毕，下面的操作不受 livecd 影响\n\n## 格式化\n\n此处认为你已经分好区了，总体需要三个分区\n\n-   ESP（EFI） 分区，300M，打了 ESP 标签（可以用 `cfdisk` 打），此处举例为 `/dev/nvme0n1p1`\n-   Linux 分区（ZFS 池），30+G，此处举例为 `/dev/nvme0n1p2`\n-   Windows 分区（如果不需要安装 Windows 就不用建），40+G，此处举例为 `/dev/nvme0n1p3`\n\n#### 创建 ZFS 池\n\n- `ashift = 12` 代表 4096 字节扇区大小，9 代表 512 扇区大小，13 代表 8192 字节扇区大小，在 4096/8192 扇区大小的 SSD 上设置 9 会导致性能损失，在 512 字节扇区大小的硬盘上设置 12/13 会导致容量损失，扇区大小可以通过 fdisk -l（不准）或者 diskgenius 这类工具查看  \n- `dedup=on` 为去重功能，可能会占用较大 RAM，低配机子可以把这行删掉  \n- `compression=zstd` 为压缩功能，zstd 目前来看压缩率和性能损失比较平衡，在意性能可以改为快速压缩算法 lz4（gzip 压缩率和性能都比不上 zstd）（好吧我后来在乎性能换成 lz4 了，实际上压缩率也不算太差）  \n- `atime=off` 我们不需要知道最后一次访问某个文件的时间。   \n- `primarycache=metadata` 默认为 `all`，为了减小 ARC 带来的内存压力改为 `metadata`  \n- `secondarycache=none` 默认为 `all`，L2ARC 感觉对桌面端弊大于利，直接取消。  \n- `checksum=blake3` 默认为 `on`，[blake3](https://github.com/BLAKE3-team/BLAKE3) 是一种高性能加密哈希算法，比默认的 SHA-2 系列快很多。\n\n其他照做即可\n\n```SHELL\nzpool create -f -o ashift=12           \\\n             -O acltype=posixacl       \\\n             -O atime=off              \\\n             -O xattr=sa               \\\n             -O dnodesize=legacy       \\\n             -O normalization=formD    \\\n             -O mountpoint=none        \\\n             -O canmount=off           \\\n             -O devices=off            \\\n             -O compression=zstd       \\\n             -O dedup=on               \\\n             -O checksum=blake3        \\\n             -O primarycache=metadata  \\\n             -O secondarycache=none    \\\n             -R /mnt                   \\\n             zroot /dev/nvme0n1p2\n```\n\n创建数据集\n\n```SHELL\nzfs create -o mountpoint=none zroot/data\nzfs create -o mountpoint=none zroot/ROOT\nzfs create -o mountpoint=/ -o canmount=noauto zroot/ROOT/archlinux\nzfs create -o mountpoint=/home zroot/data/home\n```\n\n测试 zpool 是否能够导入导出\n\n```SHELL\nzpool export zroot\nzpool import zroot -R /mnt\n```\n\n挂载 zpool\n\n```SHELL\nzfs mount zroot/ROOT/archlinux\nzfs mount -a\n```\n\n设置启动数据集\n\n```SHELL\nzpool set bootfs=zroot/ROOT/archlinux zroot\n```\n\n设置 zpool 缓存\n\n```SHELL\nzpool set cachefile=/etc/zfs/zpool.cache zroot\nmkdir /mnt/etc\nmkdir /mnt/etc/zfs\ncp /etc/zfs/zpool.cache /mnt/etc/zfs/zpool.cache\n```\n\n查看是否有挂载上\n\n```SHELL\ndf -h\n```\n\n输出\n\n```TEXT\nzroot/ROOT/archlinux   30G  128K   30G   1% /mnt\n```\n\n#### 格式化 EFI 分区\n\n注意此处挂载点不可以设置成 `/boot`！[^1]\n\n```SHELL\nmkfs.vfat /dev/nvme0n1p1\nmkdir /mnt/efi\nmount /dev/nvme0n1p1 /mnt/efi\n```\n\n## 安装\n\n这部分需要你在 `/etc/pacman.conf` 里添加 [archzfs](https://github.com/archzfs/archzfs/wiki) 源或者按照[一刀斩的博客](https://blog.yidaozhan.top/2022/08/11/arch-linux-upgrade-to-x86-64-v3-microarchitecture/)配置 CachyOS 源，此处不再赘述\n\n#### 安装基本软件包\n\n如果是 Intel 的 CPU 就把 `amd-ucode` 换成 `intel-ucode`\n\n此处使用 `zfs-linux` 包有可能会因为版本不相同然后挂掉，所以如果你添加了 CachyOS 的软件源，那么我推荐你使用 CachyOS 的自定义内核（它的内核和 zfs 模块同时编译打包，就不会出现版本不统一的问题）（最主要还是因为安装 `zfs-linux` 还得启用 v3 源），有多种任务调度器可选，比如 BMQ PDS TT 等，还有 LLVM LTO 编译的版本\n\n使用 CachyOS 内核的话直接改包即可，比如我想用 `linux-cachyos-pds`，那么把下面 `linux linux-headers zfs-linux` 换成 `linux-cachyos-pds linux-cachyos-pds-headers linux-cachyos-pds-zfs` 即可\n\n如果你不想用 CachyOS 的内核，也不想因为 zfs 模块和 linux 内核版本不统一而滚挂，那么可以使用 dkms 模块，把 `zfs-linux` 替换为 `zfs-dkms` 即可，这个的缺点是构建 dkms 模块时会风扇狂转（理论上任何内核都可以用这个当 zfs 内核模块）\n\n```SHELL\npacstrap /mnt base linux-firmware linux linux-headers zfs-linux base-devel neovim os-prober amd-ucode openssh wget networkmanager zfs-utils\n```\n\n#### 基础安装\n\n```SHELL\n# 配置 /etc/fstab\ngenfstab -U /mnt >> /mnt/etc/fstab\n# 验证 /etc/fstab\ncat /mnt/etc/fstab\n\n# chroot 进 ArchLinux\narch-chroot /mnt\n\n# 设置zpool缓存\nzpool set cachefile=/etc/zfs/zpool.cache zroot\n\n# 设置时区\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\nhwclock --systohc\ndate\n\n# 设置语言\necho -e \"\\nen_US.UTF-8 UTF-8\\nzh_CN.UTF-8 UTF-8\\nzh_TW.UTF-8 UTF-8\" >> /etc/locale.gen\n\n# 应用配置\nlocale-gen\n\n# 设置默认语言\necho -e \"\\nLANG=en_US.UTF-8\\n\" >> /etc/locale.conf\n\n# 设置root密码\npasswd\n\n# 添加非 root 用户\npacman -S fish # 如果不想用 fish 可以跳过这一步并把下一步的 fish 字段换成 bash\nuseradd -m -G wheel -s /bin/fish user # user 替换为你的用户名\npasswd user # 设置密码\nsed -i \"s|#%wheel ALL=(ALL) ALL|%wheel ALL=(ALL) ALL|g\" /etc/sudoers # 添加 sudo 权限，命令可能无效，请自行查询如何给 wheel 用户组添加 sudo 权限\n\n\n# 添加 multilib 和 archlinuxcn 仓库\narch='$arch'\necho -e \"\\n[multilib]\\nInclude = /etc/pacman.d/mirrorlist\\n\\n[archlinuxcn]\\nServer = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch\" >> /etc/pacman.conf\n```\n\n#### 配置内核钩子\n\n重点部分！\n编辑 `/etc/mkinitcpio.conf`，直接在 `HOOKS=(......)` 里面加上 `zfs`\n\n```SHELL\nnvim /etc/mkinitcpio.conf\nHOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck)\n```\n\n编辑完直接借用 ArchLinux 的极为人性化的脚本生成即可\n\n```SHELL\nmkinitcpio -P\n```\n\n#### 设置 zfs 服务以及网络管理服务\n\n```SHELL\nsystemctl enable zfs.target\nsystemctl enable zfs-import-cache\nsystemctl enable zfs-mount\nsystemctl enable zfs-import.target\nsystemctl enable sshd\nsystemctl enable NetworkManager\n```\n\n## 配置 ZFSBootMenu 引导\n\n（需要在 chroot 中完成）  \n重点部分！  \n详细了解可以看我之前那篇[在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）](https://pinghigh.github.io/2022/11/28/2022-11-28-ZFSBootMenu/)  \n在这里我们使用预构建好的 EFI 文件~~因为我没玩明白 ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核~~\n\n首先下载预构建好的 ZBM efi 引导文件\n（访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/）\n\n```SHELL\nmkdir /efi/EFI\nmkdir /efi/EFI/ZBM\nwget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi\n```\n\n再进行一个简单的配置\n\n```SHELL\nzfs set org.zfsbootmenu:commandline=\"rw\" zroot/ROOT\n```\n\n这样就做到了启动（如果没有双启动的需求没必要进行下一步了）\n\n## 配置 rEFInd 以实现与 Windows 双启动\n\n安装 refind\n\n```SHELL\npacman -Sy refind git\nrefind-install\n```\n\n这样重启之后就能双启动了  \n但是你还可以美化一下，安装 nord 主题（非必要）\n\n```SHELL\npacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst\n```\n\n## 结束\n\n退出 chroot\n\n```SHELL\nexit\n```\n\n解挂载\n\n```SHELL\numount /mnt/efi\nzfs umount zroot/ROOT/archlinux\nzfs umount -a\n```\n\n导出 zfs 池\n\n```SHELL\nzpool export zroot\n```\n\n（导出没成功也没关系，直接重启即可）\n重启\n\n```SHELL\nreboot\n```\n\n然后你的 archlinux 就可以正常使用了\n\n## 后记\n\n还是在年前完成了虚拟机上的测试，能够完美安装，原来写的还是有点低级错误的  \nHyper-V 上安装可能会涉及到 pacman 检测不到架构之类的问题，因此启用 archlinuxcn 源需要你在 `/etc/pacman.conf` 改 `Architecture = auto` 中的 `auto` 为你的架构，如 `x86_64` `x86_64-v3`  \n另外不启用 CachyOS-v3 源，只启用 CachyOS 源也可以安装 CachyOS 的优化内核，但是没有 lto 版本  \n以及我个人宣布，这是本博客 2022 年的最佳博文\n\n[^1]: 原因是 ZFSBootMenu 需要从 `/boot` 加载内核，而 ZBM 的 initramfs 启动时大概不会挂载 ESP 分区（我之前这么干寄了","tags":["ArchLinux","ZFSBootMenu","ZFS"],"categories":["Linux"]},{"title":"在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）","path":"/post/zbm-guide/","content":"## 前言\n\n写这篇博客的缘由挺简单的，当时 ClearArch 开发组讨论文件系统应当使用 ZFS 还是 F2FS，由于使用过 F2FS 作为根文件系统（它没有 Windows 下的驱动，透明压缩也不会提供额外的空间），同时查到[企鹅大大的一篇文章](https://qiedd.com/1386.html)，看到近 2x 的压缩率不禁心动，随后走上了 ZFS+zstd 作为根文件系统的折腾之路\n\n企鹅大大使用 SysLinux 引导，我在服务器尝试安装结果无法启动；看到 [CachyOS](https://cachyos.org) 的仓库中有一个打了 ZFS+zstd 支持补丁的 grub，尝试，启动不了（后来询问了 CachyOS 的开发团队得知那个补丁是不起效果的），随后，我遇到了一个完美的解决方式（指 [eoli3n 的使用 ZFSBootMenu 的安装脚本](https://github.com/eoli3n/arch-config/blob/master/scripts/zfs/install/02-install.sh)）（如果想实机全盘单系统可以直接用他的安装脚本）\n\n本文的目的是用 ZFSBootMenu 引导 zstd 压缩的 ZFS 文件系统根目录，同时附带双启动教程\n\n## ZFSBootMenu 介绍\n\n[官方仓库](https://github.com/zbm-dev/zfsbootmenu/) 介绍：\n\n> ZFSBootMenu 是用于 root-on-ZFS 系统的 ZFS 引导加载程序，支持快照和本机全盘加密\n\n其原理比较容易理解，总的来说：\n1. 引导 ZFSBootMenu，他是一个 initramfs 映像\n2. 找到并导入所有的 ZFS 存储池，然后挂载用户选择的根数据集\n3. 用 `kexec`[^1] 将系统内核、initramfs 映像加载到内存中\n4. 卸载所有 ZFS 数据集\n5. 启动最终内核\n\n总之，它能启动以 ZFS 为根目录的 Linux，速度不慢，适用环境广，是作为本文环境下引导器的不二之选\n\n## 准备\n\n确保你的电脑为 UEFI 启动，且已经分区完成，建立了根分区相应的子数据集\n\n```SHELL\n[ -d /sys/firmware/efi] && echo UEFI || echo BIOS\n```\n\n输入该命令，若输出 `UEFI`，则可以进行下一步，否则退出本教程。\n\n### 挂载 ESP 分区\n\nESP 分区一般是磁盘头部 300M 左右的 FAT16/32 分区，同时有 EFI System 标记，可以通过 `fdisk -l` 查看各个分区的标记  \n此处挂载点绝对不可以是 `/boot`，一般来说有两个其他选择：`/boot/efi` 和 `/efi`，我在这里选择了 `/efi`  \n例如我的 ESP 分区是 /dev/nvme0n1p1\n则\n```SHELL\nmkdir /mnt/efi\nmount /dev/nvme0n1p1 /mnt/efi\n```\n\n### 设置 ZFS Hook\n\n```SHELL\n# 先 arch-chroot\narch-chroot /mnt\n\n# 进入后编辑 /etc/mkinitcpio 加入 zfs 支持，在 HOOKS=(.......) 中加入 zfs\nvim /etc/mkinitcpio\n# 比如正常安装的 arch 修改后应该长这样，确保其中有 zfs 即可\nHOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck)\n\n# 编辑后加载\nmkinitcpio -P\n```\n\n## 安装 ZFSBootMenu\n\n在这里我们使用预构建好的 EFI 文件~~因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核~~\n\n```SHELL\n# /efi 换成你的 ESP 挂载目录\nmkdir /efi/EFI\nmkdir /efi/EFI/ZBM\nwget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi\n# 访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/\n\n# 配置\n# 此处假设你的根目录的数据集为 zroot/ROOT/arch\n# 这样可以引导 zroot/ROOT 下的任意子数据集，比如 zroot/ROOT/arch 上安装 arch，zroot/ROOT/void 上安装 voidlinux，这就实现了 Linux 的双启动\nzfs set org.zfsbootmenu:commandline=\"rw\" zroot/ROOT\n```\n\n## 配置 rEFInd\n\nrEFInd 能够每次开机都搜索 EFI 分区下的 efi 文件，这样就不用更新引导文件了，同时插启动盘的时候也不需要进 bios 里调启动顺序，rEFInd 会自动搜索到\n```SHELL\n# 假设当前还在 chroot 里\npacman -Sy refind\nrefind-install\n```\n非常简单，这样就实现了 Windows/macOS(HFS+) 与 Linux on ZFS 的双启动\n```SHELL\n# 安装 nord 主题\npacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst\n```\n\n## TODO\n实验并整理整个安装流程\n\n[^1]: `kexec` 是 Linux 内核的一种机制，它允许从当前运行的内核启动新内核。`kexec` 会跳过由系统固件（BIOS 或 UEFI）执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。","tags":["ArchLinux","ZFSBootMenu","ZFS"],"categories":["Linux"]},{"title":"线段树","path":"/post/segment-tree/","content":"~~闪击线段树~~\n\n## 基本线段树\n\n### 操作\n\n`push_up()` 通过子区间计算父区间的数据\n\n`build()` 将一段区间初始化成线段树\n\n`modify()` \n* 修改单点数据\n* 修改区间数据 (即 `push_down()`)\n\n`query()` 查询\n\n`push_down()` 修改区间数据并递归修改子区间的数据\n\n### 原理\n\n还是用图理解\n\n![](https://pic1.imgdb.cn/item/646ca3800d2dde5777c812ff.webp)\n\n简单来说就是把一个区间整成类似上图的完全二叉树，父节点（区间）的数据可以由子节点（区间）的数据推出（如区间最大值，区间和等），同时父节点的更改可以推到子节点里。  \n可能有点抽象，但是把操作挨个解释就比较易懂了。\n\n### 存储节点\n\n使用结构体感觉比较清晰，配上指针就能脱离中括号的束缚了\n\n```cpp\nstruct Node {\n    int u;\n    int v;\n    Node *lc, *rc;\n    int l, r, mid;\n    int lazy;  // 懒标记\n    void init(int L, int R) {\n        l = L;\n        r = R;\n        mid = l + r >> 1;\n    }\n} tr[N * 4];\n```\n\n同时 `mid` 是需要用到的变量，我这里选择直接存在里面，同时写一个初始化函数，直接传进去区间的左右端点，非常方便。\n\n### 建立线段树\n\n第一层区间为 $[l,r]$\n\n取 $mid = \\lfloor \\frac{l+r}{2} \\rfloor $\n\n则第二层的区间分别是 $[l,mid], [mid+1,r]$\n\n目前节点为 $u$，线段树数组为 $tr$，`build()` 函数如下\n```cpp\nvoid build(Node* nod, int L, int R) {\n    nod->init(L, R); // 记录区间范围\n    if (L == R) { // 到达叶子节点就回溯\n        nod->v = ori[L];\n        nod->lc = nod->rc = tr; // 防止空指针，左右儿子指向第一个空节点\n        return;\n    }\n    nod->lc = ++tail; // tail 是一个指向最后创建的节点的指针，这样是一个类似动态开点的操作\n    nod->rc = ++tail;\n    build(nod->lc, L, nod->mid);\n    build(nod->rc, nod->mid + 1, R);\n    push_up(nod);\n}\n\n```\n\n### 查询\n\n以区间和为例\n\n设查询的区间为 $[l,r]$，目前节点区间为 $[T_l,T_r]$\n\n则有二种情况\n\n1. $[l,r] \\ni [T_l,T_r]$ 查询区间包含目前节点区间（因为每次查询都可能把查询区间切割开再下传，所以这种情况可视为严格包含）\n2. $[l,r]\\cap[T_l,T_r] \\neq \\varnothing$\n3. $[l,r]\\not\\ni[T_l,T_r]$ （不存在）\n\n把第二种情况还需要再分开成三种情况\n\n1. $[l,r] \\in [lc_l,lc_r]$ 即被左儿子区间包含\n2. $[l,r] \\in [rc_l,rc_r]$ 即被右儿子区间包含\n3. $l \\leqslant mid , r > mid$ 即左右区间都不能单独覆盖查询区间，这种情况把查询区间从 mid 劈成两半再分别在左右儿子区间查询即可。\n\n所以只用处理相应的情况就可以了\n\n这里直接给出一个维护区间最大值的查询函数\n\n```cpp\nint query(Node* nod, int L, int R) {\n    push_down(nod);\n    \n    if (nod->r == R && nod->l == L) { // 严格覆盖\n        return nod->v;\n    }\n    \n    if (nod->lc->r >= R) {\n        return query(nod->lc, L, R);\n    } else if (nod->rc->l <= L) {\n        return query(nod->rc, L, R);\n    } else {\n        return query(nod->lc, L, nod->lc->r) + query(nod->rc, nod->rc->l, R);\n    }\n}\n```\n\n### 从子节点推出父节点数据\n\n还是以区间和为例，父区间最大值为两个子区间最大值中的最大值。\n\n```cpp\nvoid push_up(Node* nod) {\n    nod->v = nod->lc->v + nod->rc->v;\n}\n```\n\n### 修改区间值\n\n理解起来其实挺简单的，比如给区间 $[L,R]$ 都加一个数 $x$，朴素写法直接用类似[查询](#查询)的方法递归到底部回溯的时候一个一个更新即可。\n\n但是显然这样做效率很低，对于长度为 $n$ 的一个区间，最坏情况下它对应 $\\log n$ 个极大区间（这些区间不存在可以合并的两个）；对于每一个极大区间来说修改它和它所有子区间的值的时间复杂度显然是他的长度，即 $\\operatorname{O}(len)$。则如上朴素写法每次修改的时间复杂度最坏为 $\\operatorname{O}(n\\log n)$，属于是飞慢了。\n\n优化的方式很容易想到，就是每次修改只需要保证需要用到的节点是正确的，其他节点先不管，需要用到的时候再更改。这种方式很像前端里面的一个优化“懒加载”，即一个网页如果有很多元素，一次全部加载完可能会缓慢，所以设备显示到哪里就只加载哪里的元素，看不到的元素能不加载就不加载。同样的，这种优化方式需要打标记，同时能不下放就不下放，子节点能不修改就不修改，被称为“懒标记”。\n\n也就是说若一个节点拥有懒标记，那么该节点的子节点们都不知道这个懒标记的存在，同时也就表明该节点的叶子节点存储的信息均不是真实信息。如果需要用到当前拥有懒标记的节点的真实信息，就需要把懒标记下放到子节点，通过懒标记更改子节点数据，然后处理子节点更改造成的数据更改即可（直接 `push_up`）\n\n假设目前要求维护区间和的同时处理区间加的操作，对于每一个节点来说，我们需要维护一个懒标记 $lazy$ ，代表“当前区间的子区间需要加一个 $lazy$ ”。\n\n```cpp\nvoid modify(Node* nod, int L, int R, int v) { // 给 [L,R] 每个数加 v\n    if (L == nod->l && R == nod->r) { // 包含了\n        nod->lazy += v; // 该区间的每个子区间都需要加 v\n        nod->v += (nod->r - nod->l + 1) * v; // 当前区间一共有 R-L+1 个元素（因为严格包含所以 L 和 R 就是区间的左右端点）\n        // 用不上子区间的数据，不下传懒标记直接结束\n    } else {\n        push_down(nod);\n        /*\n        判断三种情况\n        */\n        if (nod->lc->r >= R) {\n            modify(nod->lc, L, R, v);\n        } else if (nod->rc->l <= L) {\n            modify(nod->rc, L, R, v);\n        } else {\n            modify(nod->lc, L, nod->lc->r, v);\n            modify(nod->rc, nod->rc->l, R, v);\n        }\n        push_down(nod);\n        push_up(nod);\n    }\n}\n```\n\n```cpp\nvoid push_down(Node* nod) {\n    if (nod->lazy == 0) return;\n    if (nod->lc) nod->lc->lazy += nod->lazy;\n    if (nod->rc) nod->rc->lazy += nod->lazy;\n    nod->lc->v += (nod->mid - nod->l + 1) * nod->lazy;\n    nod->rc->v += (nod->r - nod->mid) * nod->lazy;\n    nod->lazy = 0;\n}\n```\n\n值得注意的是，加上懒标记之后，为了保证查询时访问的节点数据正确，需要在查询时添加 `push_down()` 操作（上文已加）。\n\n### 完整实现\n\n区间加修改&求区间和\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\n#define N 1000150\n\nstruct Node {\n    int u;\n    int v;\n    Node *lc, *rc;\n    int l, r, mid;\n    int lazy;  // 懒标记\n    void init(int L, int R) {\n        l = L;\n        r = R;\n        mid = l + r >> 1;\n    }\n} tr[N * 4];\n\nint n, m;\nint x, y, k;\nint ori[N];\nchar beh;\nint t1, t2, t3;\nint cnt = 1;\nNode* tail = tr;\n\nvoid push_up(Node* nod) {\n    nod->v = nod->lc->v + nod->rc->v;\n}\n\nvoid build(Node* nod, int L, int R) {\n    nod->init(L, R);\n    if (L == R) {\n        nod->v = ori[L];\n        nod->lc = nod->rc = tr;\n        return;\n    }\n    nod->lc = ++tail;\n    nod->rc = ++tail;\n    build(nod->lc, L, nod->mid);\n    build(nod->rc, nod->mid + 1, R);\n    push_up(nod);\n}\n\nvoid push_down(Node* nod) {\n    if (nod->lazy == 0) return;\n    if (nod->lc) nod->lc->lazy += nod->lazy;\n    if (nod->rc) nod->rc->lazy += nod->lazy;\n    nod->lc->v += (nod->mid - nod->l + 1) * nod->lazy;\n    nod->rc->v += (nod->r - nod->mid) * nod->lazy;\n    nod->lazy = 0;\n}\n\nvoid modify(Node* nod, int L, int R, int v) {\n    if (L == nod->l && R == nod->r) {\n        nod->lazy += v;\n        nod->v += (nod->r - nod->l + 1) * v;\n    } else {\n        push_down(nod);\n        if (nod->lc->r >= R) {\n            modify(nod->lc, L, R, v);\n        } else if (nod->rc->l <= L) {\n            modify(nod->rc, L, R, v);\n        } else {\n            modify(nod->lc, L, nod->lc->r, v);\n            modify(nod->rc, nod->rc->l, R, v);\n        }\n        push_down(nod);\n        push_up(nod);\n    }\n}\n\nint query(Node* nod, int L, int R) {\n    push_down(nod);\n    if (nod->r == R && nod->l == L) {\n        return nod->v;\n    }\n\n    if (nod->lc->r >= R) {\n        return query(nod->lc, L, R);\n    } else if (nod->rc->l <= L) {\n        return query(nod->rc, L, R);\n    } else {\n        return query(nod->lc, L, nod->lc->r) + query(nod->rc, nod->rc->l, R);\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        cin >> ori[i];\n    }\n    build(++tail, 1, n);\n    while (m--) {\n        cin >> beh;\n        if (beh == '1') {\n            cin >> t1 >> t2 >> t3;\n            modify(tr + 1, t1, t2, t3);\n        } else {\n            cin >> t1 >> t2;\n            cout << query(tr + 1, t1, t2) << endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n## 区间加乘同时存在\n\n上文介绍了加法的懒标记，如果是单独乘法的懒标记也很好实现。但是如果需要同时处理加法、乘法两个区间操作该怎么办捏？\n\n只需要使用一下分配律即可。\n\n$(nod_cnod_v + nod_a) \\cdot d=d \\cdot nod_cnod_v+d \\cdot nod_a$ \n\n$nod_c$ 即乘法懒标记， $nod_a$ 即加法懒标记，$d$ 是需要乘的数（操作数）","tags":["线段树"],"categories":["数据结构"]},{"title":"同余方程与二元一次不定方程","path":"/post/exgcd/","content":"## 同余\n\n### 定义\n\n$a\\bmod m = b \\bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \\equiv b \\pmod m$\n\n等价于 $m$ 整除 $(a-b)$，即 $m\\mid(a-b)$\n\n### 同余方程\n\n$ax \\equiv b \\pmod m$\n\n已知 $a,b,n$，求解 $x$。  \n当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解  \n若 $x_0$ 是方程的一个解，解集即为 $\\{ x_0+km /\\gcd(a,m) | k\\in \\mathbb{Z} \\}$\n\n有解证明：\n\n对于线性同余方程 $ax \\equiv b\\pmod m$ 可以转换为 $ax+km=b,k\\in \\mathbb{Z}$\n\n设 $d=\\gcd(a,m)$，若方程有解为 $c$， 则 $m \\mid (ac-b)$ ，从而 $d\\mid(ac-b)$，又因为 $d\\mid a$，即 $d\\mid ac$，于是有 $d\\mid b$，即 $\\gcd(a,m)\\mid b$\n\n### 扩展欧几里得算法\n\n#### 前置知识\n\n##### 裴蜀定理\n\n$$\n\\forall a,b, \\exists x,y,ax+by=\\gcd(a,b)\n$$\n\n即 $ax\\equiv \\gcd(a,b)\\pmod b$\n\n#### 用途\n\n- 求解同余方程 $ax \\equiv \\gcd(a,n) \\pmod n$\n  - $\\forall a,b,\\exists x,y,ax+by=\\gcd(a,b)$ (裴蜀定理)  \n    即 $ax\\equiv \\gcd(a,b) \\pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出\n\n同时,[逆元](/post/multi-inverse-element)的定义也是一个同余方程,也就是说该法可以求模意义下的逆元\n\n#### 原理\n\n对于方程 $ax_1+by_1=\\gcd (a,b)$，由裴蜀定理可得一定存在一组 $x_1,y_1$ 使得等式成立\n\n于是分两类讨论\n\n- $b = 0$ 时，$ax_1+by_1=a$，显然 $x_1 = 1, y_1 \\in \\mathbf R$\n\n- $b \\neq 0$ 时，利用四个未知量 $x_1,y_1,x_2,y_2$ 列出两个方程\n  $$\n  \\begin{cases}\n  ax_1+by_1 = \\gcd(a,b) = \\gcd(b, a\\bmod b) ① \\newline\n  bx_2+(a\\bmod b)y_2 = \\gcd(b, a \\bmod b) = \\gcd(a,b) = ax_1+by_1 ②\n  \\end{cases}\n  $$\n  易得\n  $$\n  a \\bmod b = a-\\lfloor\\frac{a}{b}\\rfloor b\n  $$\n  由此我们可以继续展开推导 $②$ 式\n  $$\n  \\begin{aligned}\n  bx_2+(a\\bmod b)y_2 &= ax_1+by_1 \\newline\n  bx_2+(a-\\lfloor \\dfrac{a}{b}\\rfloor b)y_2 &= ax_1+by_1 \\newline\n  ay_2+b(x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2) &= ax_1+by_1\n  \\end{aligned}\n  $$\n    <!--$x_2,y_2$ 只是两个表示未知量的符号，所以我们可以把它们两个互换一下，得到\n    \n    $$\n    ax_2+b(y_2-\\lfloor \\dfrac{a}{b} \\rfloor x_2) = ax_1+by_1\n    $$\n    -->\n  因此\n  $$\n  \\begin{cases}\n  x_1 = y_2 \\newline\n  y_1 = x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2\n  \\end{cases}\n  $$\n\n#### 实现\n\n<!--\n* 算法：函数 `ex_gcd(a,b)`\n  * 若 $b=0$，$ax_1+by_1=\\gcd(a,b)$ 的解是 $x_1=1,y_1=0$，直接返回\n  * 否则递归调用 $\\operatorname{ex\\_gcd}(b,a\\bmod b)$，求解 $bx_2+(a\\bmod b)y_2 = \\gcd(b, a\\bmod b)$\n  * 用上一步解的 $x_2,y_2$，令 $x_1=y_2, y_1=x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2$ ，$x_1$ 和 $y_1$ 就是当前方程的解\n  * 返回 $x_1,y_1$\n* 对于任意同余方程 $ax\\equiv b \\pmod n$，只要满足 $\\gcd(a,n)\\mid b$\n  就可以先用扩欧求出 $ax_2\\equiv \\gcd(a,n)\\ \\pmod n$\n  即 $d=\\gcd(a,n)$，得到 $a(\\frac bd)x_2\\equiv b\\ \\pmod n$\n  所以原方程一解 $x_0=(\\frac bd)x_2$，通解 $x_0+(\\frac nd)k, k\\in \\mathbf{Z}$\n  -->\n\n##### 函数 $\\operatorname{exgcd}(a,b,x,y)$\n\n采用递归实现，因此先判定递归边界，则 $b=0$ 时到达边界，此时 $x = 1, y = 0$\n\n未到边界，则先继续调用 $\\operatorname{exgcd}(b, a\\bmod b, x, y)$ ，然后根据递归回溯得到的 $x,y$ 得到 $x_1, y_1$，即\n\n$$\n\\begin{cases}\nx_1 = y \\newline\ny_1 = x-\\lfloor \\dfrac{a}{b} \\rfloor y\n\\end{cases}\n$$\n\n返回到头为止。\n\n##### 求解 $ax + by = c$ ，即 $a \\equiv c \\pmod b$\n\n先判断是否有解，若 $\\gcd(a,b) \\mid c$ 则有解（[裴蜀定理](#裴蜀定理)）\n然后利用 $\\operatorname{exgcd}$ 求解 $ax_1 + by_1 = \\gcd (a,b)$\n即得到一份特解 $x = x_1 \\times \\frac{c}{\\gcd(a,b)}, y = y_1 \\times \\frac{c}{\\gcd(a,b)}$\n\n求通解，实质上是使 $x,y$ 进行一定变换但等式依然成立。\n易想到 $x$ 下降时 $y$ 上升，因此设：$g = \\gcd(a,b), i>j$\n\n$$\n\\begin{aligned}\nax_i+by_i&=c \\newline\nax_j + by_j &= c\n\\end{aligned} \\newline\n$$\n\n导一下式子，得\n\n$$\n\\begin{aligned}\nax_i+by_i &= ax_j + by_j \\newline\na(x_i - x_j) &= b(y_j - y_i) \\newline\n\\frac ag (x_i - x_j) &= \\frac bg (y_j - y_i)\n\\end{aligned} \\newline\n$$\n\n因为 $g$ 是最大公因数，所以 $\\frac ag$ 与 $\\frac bg$ 互质。又因为方程中每一个字母都是整数，所以易得：$\\frac bg$ 是 $x_i-x_j$ 的倍数，而 $\\frac ag$ 是 $y_j - y_i$ 的倍数（即 $- \\frac ag$ 是 $y_i - y_j$ 的倍数）\n\n于是通解就推出来了\n\n$$\n\\begin{cases}\n\\mathbf X = \\{x+\\cfrac bg k \\mid k\\in\\mathbf Z\\} \\newline\n\\mathbf Y = \\{y-\\cfrac ag k \\mid k\\in\\mathbf Z\\}\n\\end{cases}\n$$\n\n关于最小正整数 $x$，求法如下：\n\n- 情况 1：$\\gcd(a,b) = 1$\n  - 此时 $\\frac bg = 1$ ，则 $x_{min} = x \\bmod b$\n- 情况 2：$\\gcd(a,b)=g\\neq 1$\n  - 想办法列出新方程（$x,y$ 不变）$a_1x+b_1y=c_1,\\gcd(a_1,b_1)=1$，即 $a_1,b_1$ 互质\n  - 容易想到 $a_1 = \\frac ag, b_1 = \\frac bg$，然后为了保证等式成立，$c_1 = \\frac cg$\n  - 显然直接化为了第一种情况，于是 $x_{min} = x \\bmod \\frac b{\\gcd(a,b)}$\n\n#### 代码\n\n##### 题目描述\n\n给定不定方程\n$$ax+by=c$$\n若该方程无整数解，输出 $-1$。  \n若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  \n若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。\n\n正整数解即为 $x, y$ 均为正整数的解，$\\boldsymbol{0}$ **不是正整数**。  \n整数解即为 $x,y$ 均为整数的解。  \n$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。\n\n###### 输入格式\n\n第一行一个正整数 $T$，代表数据组数。\n\n接下来 $T$ 行，每行三个由空格隔开的正整数 $a, b, c$。\n\n###### 输出格式\n\n$T$ 行。\n\n若该行对应的询问无整数解，一个数字 $-1$。  \n若该行对应的询问有整数解但无正整数解，包含 $2$ 个由空格隔开的数字，依次代表整数解中，$x$ 的最小正整数值，$y$ 的最小正整数值。  \n否则包含 $5$ 个由空格隔开的数字，依次代表正整数解的数量，正整数解中，$x$ 的最小值，$y$ 的最小值，$x$ 的最大值，$y$ 的最大值。\n\n##### 实现\n\n```cpp\ni64 ex_gcd(i64 u, i64 v, i64& x, i64& y) {\n    if (!v) {\n        x = 1, y = 0;\n        return u;\n    }\n\n    i64 g = ex_gcd(v, u % v, x, y);\n    i64 temp = x;\n    x = y;\n    y = temp - u / v * y;\n    return g;\n}\n\ni64 a, b, c, g, x, y, ga, gb, maxx, maxy, minx, miny;\ni64 t;\ni64 k;\n\nint main() {\n    read(t);\n    while (t--) {\n        read(a, b, c);\n        // if (a < b) std::swap(a, b);\n        g = ex_gcd(a, b, x, y);\n        x *= c / g, y *= c / g;\n        if (c % g) {\n            puts(\"-1\");\n        } else {\n            ga = a / g;\n            gb = b / g;\n\n            /*\n            此处先把 x 的最小正整数值求出来，容易想到 x 最小时 y 最大\n            x > 1 时，直接往小取就行\n            x <= 1 时，求 1 和 x 的差值然后把差值向上取整地消掉即可\n            y 同理\n            */\n            if (x > 1) {\n                k = (x - 1) / gb;\n                minx = x - k * gb;\n                maxy = y + k * ga;\n            } else {\n                k = ceil((1.0 - x) / gb);\n                minx = x + k * gb;\n                maxy = y - k * ga;\n            }\n            if (y > 1) {\n                k = (y - 1) / ga;\n                miny = y - k * ga;\n                maxx = x + k * gb;\n            } else {\n                k = ceil((1.0 - y) / ga);\n                miny = y + k * ga;\n                maxx = x - k * gb;\n            }\n\n            // 如果 x, y 的最大值不是正整数，那么无正整数解，最小正整数 x, y 就是上面所求\n            if (maxy <= 0 || maxx <= 0) {\n                write(minx, ' ', miny, '\\n');\n            } else {\n                // 此处算个数的时候需要注意要算自身，所以 + 1\n                write((i64)ceil(maxy - 1.0) / ga + 1, ' ', minx, ' ', miny, ' ', maxx, ' ', maxy, '\\n');\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["数论","同余"],"categories":["数学"]},{"title":"初等数论","path":"/post/elementary-number-theory/","content":"## 质数相关\n\n质数即一个数的因数只包含 $1$ 和自己。  \n筛法请见：[质数筛法](/post/prime-sieve)\n\n\n## 模运算相关\n\n首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\\leqslant r<m$，$q$ 就是商，$r$ 就是余数。    \nC++ 中模运算可能结果是负数。当 $n<0$ 时，模运算结果满足 $-m<r \\leqslant 0$。    \n因此可以使用 \n\n```cpp\n(n % m + m) % m\n```\n\n进行取余操作。\n\n## 求[最大公约数](/post/gcd)\n\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n    int a,b,r;\n    cin >> a >> b;\n    while (a % b) {\n        r = a % b;\n        a = b;\n        b = r;\n    }\n    cout << b << endl;\n    return 0;\n}\n```\n\n## 同余方程相关\n\n[同余方程与二元一次不定方程](/post/exgcd)\n\n## 数论函数\n\n定义域[^1]为正整数的函数。\n\n### 积性函数\n\n积性函数 $f(n)$ 满足：$f(1)=1$，且 $\\forall x,y\\in \\mathbb{N^*},\\gcd(x,y)=1$，都有 $f(xy)=f(x)f(y)$。\n\n完全积性函数 $f(n)$ 满足：满足：$f(1)=1$，且 $\\forall x,y\\in \\mathbb{N^*}$，都有 $f(xy)=f(x)f(y)$。\n\n#### 性质\n\n若 $f(x),g(x)$ 为积性函数，则以下函数也为积性函数。\n\n- $h(x)=f(x^p)$\n- $h(x)=f^p(x)$\n- $h(x)=f(x)g(x)$\n- $h(x)=\\sum _{d\\mid x} f(d)g(\\frac xd)$（[Dirichlet 卷积](#Dirichlet 卷积)）\n \n\n#### 常见积性函数\n\n- $\\varepsilon(n)=[n=1]$[^2]（完全积性）\n- 欧拉函数 $\\varphi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]$\n\n### Dirichlet 卷积\n\n有两个数论函数 $f(x),g(x)$，其狄利克雷卷积计算的结果 $h(x)$ 即：\n\n$$\n\\begin{aligned}  \nh(x) &= \\sum _{d\\mid x} f(d)g(\\frac xd) \\newline\n     &= \\sum _{ab=x} f(a)g(b)\n\\end{aligned}\n$$\n\n后一种形式容易理解一点。人话来解释 $h(x)$ 的计算过程，就是把 $x$ 的每一对因数 $a,b$ 找出来（即 $ab=x$），然后计算 $f(a)g(b)$ 和 $f(b)g(a)$，再对这对东西求和。\n\n上面的式子可以简记为\n\n$$\nh=f*g\n$$\n\n#### 性质\n\n- 两个积性函数的狄利克雷卷积形式依然是积性函数。\n\n- 满足交换律 结合律 分配律\n\n### 其他东西\n\n- 单位函数 $\\epsilon(n)=[n=1]$。\n- 对于每个 $f(1) \\neq 0$ 的数论函数 $f$，都存在一个函数 $g$ 使 $f*g=\\epsilon$（函数逆元）\n- 整除分块：对于 $i,k\\in \\mathbb{N^*}$，$k$ 为定值时，$\\lfloor \\frac ki \\rfloor$ 有大约 $\\sqrt k$ 种取值。可以用这个做答案关于 $i\\in[x,y], \\lfloor \\frac ki \\rfloor$ 相关的问题（把整除结果相同的数算成一个块来求答案，这样的块大约有 $\\sqrt k$ 个）。\n- $I(n)$ 恒等函数，始终等于 $1$。\n- $id(n)=n$ 单位函数。\n\n\n[^1]: 函数 $f(x)$ 的定义域即为 $x$ 的取值范围。\n[^2]: 艾佛森括号 $[a]$ 中包含一个条件 $a$，该表达式当 $a$ 成立时为 $1$，否则为 $0$。","tags":["数论","同余"],"categories":["数学"]},{"title":"背包 DP","path":"/post/backpack-dp/","content":"第一次使用 $\\LaTeX$\n\n## 01 背包\n\n### 朴素\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#define MAXN 1010\n\nusing namespace std;\n\nint n, m;\nint v[MAXN], w[MAXN];\nint f[MAXN][MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; i ++) {\n        cin >> v[i] >> w[i];\n    }\n\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 1; j <= m; j ++) {\n            f[i][j] = f[i - 1][j];\n            if (j >= v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);\n        }\n    }\n\n    cout << f[n][m];\n\n    return 0;\n}\n```\n\n### 一维优化\n\n```cpp\n#include <iostream>\n#define MAXN 1010\n\nusing namespace std;\n\nint n,m;\nint v[MAXN],w[MAXN];\nint f[MAXN];\n\nint main() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) {\n        cin >> v[i] >> w[i];\n    }\n\n    for (int i = 1; i <= n; i ++) { // 按照物品从头到尾枚举\n        for (int j = m; j >= v[i]; j --) { // 按照体积从最大体积到当前（第 i 个）物品枚举\n            f[j] = max(\n                f[j], // 此时未更新的 f[j] 是上一次（i-1）枚举的数据，即 f[j] 是不选第 i 个物品的 f[j]\n                f[j - v[i]] + w[i]\n                );\n        }\n    }\n\n    cout << f[m] << endl;\n\n    return 0;\n}\n```\n\n## 完全背包\n\n### 朴素做法\n\n即 3 维做法\n\n<!-- * 状态表示 $f_{i,j}$\n    * 集合：所有只考虑前 $i$ 个物品，且总体积不大于 $j$ 的所有选法\n    * 属性：$max$ （最大）\n* 状态计算 -> 即集合的划分\n    * 目前我们要求 $max f_{i,j}$，不容易直接求，就采用类似 01 背包问题的“曲线救国”方法\n        1. 去掉 $k$ 个第 $i$ 个物品，变为 $max f_{i-1,j}$\n        2. 去掉相应的 $k$ 个第 $i$ 个物品的空间，变为 $max f_{i-1,j-v_ik}$\n        3. 求上面的 $max$\n        4. 加回 $k$ 个第 $i$ 个物品的价值，变为 $max f_{i-1,j-v_ik} + w_ik$\n-->\n\n先考虑状态，容易想到选到某个位置后，其特征有空间，物品种类和价值。价值是要求的，所以我们可以开二维状态，分别表示空间和物品种类。即 $f_{i,j}$ 表示从前 $i$ 种物品里选，占了 $j$ 单位空间的最大收益。  \n参考 lzp 大佬博客中的要求，这个状态是否能保证唯一且可递推呢？\n\n- 唯一：选物品的范围确定，所占用的空间确定，在所有方案中存储最大收益的方案。由于空间确定，因此不会影响后面决策，此时一定能保证最优且唯一。\n- 可递推：前面最优，容易想到通过枚举新拿的物品数量求得当前最优方案（后面讲）\n\n接下来讲递推过程：  \n前面 0/1 背包我们只需要考虑一个物品**是否选**，但是现在还需要考虑**选多少**。  \n考虑是否选择时，我们直接枚举当前物品的状态，即 0/1，选或不选。  \n放到现在这个题目中，把刚才 0/1 背包枚举**选或不选**的过程看作枚举**物品数量**，即选 $1$ 个或选 $0$ 个，这启发我们可以通过枚举物品数量来解决**选多少**的问题。  \n状态转移方程就自然而然地出来了：\n\n$$\nf_{i,j} = \\max \\left\\{ f_{i-1,j-v_ik} + w_ik \\right\\}\n$$\n\n```cpp\nint backpack() {\n    #define MAXN 1010\n\n    using namespace std;\n\n    int n,m; //! 应当定义在函数外部，原因我不说，因为没人看\n    int v[MAXN],w[MAXN];\n    int f[MAXN][MAXN];\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) {\n        cin >> v[i] >> w[i];\n    }\n\n    for (int i = 1; i <= n; i ++)\n        for (int j = 0; j <= m; j ++) {\n            for (int k = 0; k * v[i] <= j; k ++)\n                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n        }\n    cout << f[n][m] << endl;\n}\n```\n\n### 2 维优化\n\n上面的转移有三维！太慢了！想办法如何减去一个维度。\n\n状态方面，没有办法再降了，因为去掉任意一维都会导致无法表示唯一的状态。  \n那就考虑优化递推的过程。想一想是否有哪些状态能够转移到当前状态但是没考虑到？答案是有的。  \n考虑递推过程的第二层、第三层循环，对于每一个体积 $j$，$k$ 都需要从 $1$ 枚举到 $j/v_ik$ ，形象点来说大概长这样\n\n| 1 | 2 | 3 | 4 |  \n| --- | --- | --- | --- |  \n| xxx | | | |  \n| xxx | xxx | | |  \n| xxx | xxx | xxx | |  \n| xxx | xxx | xxx | xxx |  \n\n显然，$k = 1,2,3$ 时都重复地枚举了待转移状态，想办法把这些冗余的东西去掉——直接从算过 $k=1,2,3$ 的状态转移过来。  \n这意味着我们不能再单纯的用物品数量进行递推。观察第一行到第二行，容易发现在满体积的时候，第二行只是比第一行多了一个物品 $i$ 而已。  \n讨论单个物品是否选择，于是新的递推方式就显而易见了，设当前状态为 $f_{i,j}$，我既可以选一个物品 $i$，也可以不选一个物品 $i$，从 $f_{i-1,j}$ 转移过来。  \n状态转移方程：\n\n$$\nf_{i,j} =\n\\begin{cases}\nf_{i-1,j} \\newline\n\\max \\left\\{ f_{i-1,j}, f_{i,j-v_i} + w_i \\right\\},\\ j\\geqslant v_i\n\\end{cases}\n$$\n\n代码如下\n\n```cpp\n#define MAXN 1010\n\nusing namespace std;\n\nint n,m;\nint v[MAXN],w[MAXN];\nint f[MAXN][MAXN];\n\n\ncin >> n >> m;\nfor (int i = 1; i <= n; i ++) {\n\tcin >> v[i] >> w[i];\n}\n\nfor (int i = 1; i <= n; i ++)\n\tfor (int j = 0; j <= m; j ++) {\n\t//  原做法\n\t//  for (int k = 0; k *v[i] <= j; k ++)\n\t//      f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n\t\tf[i][j] = f[i - 1][j];\n\t\tif (j >= v[i]) f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]);\n\t}\ncout << f[n][m] << endl;\n\n```\n\n滚动数组优化\n\n```cpp\n#define MAXN 1010\n\nusing namespace std;\n\nint n,m;\nint v[MAXN],w[MAXN];\nint f[MAXN][MAXN];\n\nint backpack() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) {\n        cin >> v[i] >> w[i];\n    }\n\n    for (int i = 1; i <= n; i ++)\n        for (int j = v[i]; j <= m; j ++) {\n            // f[i][j] = f[i - 1][j]; 恒等式直接删除\n            // if (j >= v[i]) 直接从 v[i] 开始循环就完事了\n            f[j] = max(f[j], f[j-v[i]] + w[i]);\n        }\n    cout << f[m] << endl;\n}\n```\n\n## 多重背包\n\n### 朴素\n\n$N$ 种物品，背包容量为 $V$，第 $i$ 件物品最多能选 $C_i$ 个，每件物品占空间 $v_i$，价值为 $w_i$\n\n第一种容易想到的解法是把完全背包的方法拿来用，因为多重背包只是加了 $k$ 的限制。\n状态转移方程：\n\n$$\nf_{i,j} = \\max\\{f_{i,j}, f_{i-1,j - C_ik} + w_ik\\}\n$$\n\n考虑多重背包和完全背包的区别可以发现，多重背包虽然每种物品不只一种，但是有确定的数量，而完全背包没有数量限制，则可以轻松地在~~忽略时间复杂度的情况下~~把多重背包**拆分**成 01 背包，即把 $M_i$ 件第 $i$ 件物品挨个算单个物品再按照 01 背包的方式处理。\n\n```cpp\nfor (int i = 1; i <= n; ++ i) {\n    for (int j = 0; j <= m; ++ j) {\n        for (int k = 0; k <= min(c[i],j/w[i])/* 数量和体积两个都限制数量 */; ++ k) {\n            f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]);\n        }\n    }\n}\n```\n\n### 二进制优化\n\n这种暴力方式求解比较慢，容易发现，在求解过程中，每个**同种**物品是按照**不同种**物品进行处理的，换句话说，我选第一个 a 物品与选第二个 a 物品，实际上效果都是选 1 个 a 物品，但是这样的情况在上文解法中做了两次决策，显然有一种是多余的。  \n也就是说，接下来的优化方向是**减少**每次决策所遇到的**同数量同种**物品，那会联想到什么呢？  \n想办法把物品分为多个组，使这些组的不同组合能表示出所有数量，于是想到进制，这里采用二进制拆分。\n\n易证，使用 $2^0, 2^1, 2^2, 2^3... 2^{k-1}$ 能够表示出 $0$ 到 $2^{k-1}$ 之间的所有的数，即二进制计数。也就是说，如果把物品的数量 $C_i$ 拆分成 $2^0, 2^1, 2^2...2^{k-1} + p,0 \\leq p < 2^{k-1}$，由 $p$ 的范围可得，其中 $2^0+...2^{k-1}$ 能够表示出 $[0,p]$ 的所有整数，然后也能轻松得出 $2^0+...+2^{k-1}$ 选出若干与 $p$ 相加能表示出 $[p,p+2^k-1]$ 之间所有整数，两个合并即是 $[0,C_i]$\n\n因此可以将 $C_i$ 拆分为 $k+1$ 种新的物品，每种新物品的体积和价值分别为：\n\n$$\n\\begin{aligned}\n&2^0 \\cdot w_i,2^1 \\cdot w_i,2^2 \\cdot w_i,\\dots,2^{k-1} \\cdot w_i,p \\cdot w_i \\newline\n&2^0 \\cdot v_i,2^1 \\cdot v_i,2^2 \\cdot v_i,\\dots,2^{k-1} \\cdot v_i,p \\cdot v_i\n\\end{aligned}\n$$\n\n拆分完再进行 01 背包即可。\n\n代码来自 [GrainRain 's Blog](https://grainrain.site/2022/10/13/2022.10.13%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/)\n\n```cpp\nconst int N = 25000;\n// 一共有 1000 项，每项最多拆分成 log s 项\nconst int M = 2010;\n\nint n, m;\nint v[N], w[N];\nint f[N];\n\ncin >> n >> m;\n\nint cnt = 0;\nfor (int i = 1; i <= n; i ++) {\n    int a, b, s;\n    cin >> a >> b >> s;\n\n    for (int k = 1; k <= s; k *= 2) { // 从2^0 开始枚举 2 的次幂\n        s -= k;\n        v[++ cnt] = a * k;\n        w[cnt] = b * k;\n    }\n    if (s > 0) {\n        v[++ cnt] = a * s;\n        w[cnt] = b * s;\n    }\n}\nn = cnt;\n// 二进制拆分读入\n\nfor (int i = 1; i <= n; i ++)\n    for(int j = m; j >= v[i]; j --)\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n\ncout << f[m] << endl;\n// 01背包解题过程\n```\n\n## 分组背包\n\n$N$ 组物品，第 $i$ 组有 $C_i$ 个物品，第 $i$ 组的第 $j$ 个物品的价值是 $w_{i,j}$，体积为 $v_{i,j}$，背包体积为 $M$，每组物品只能选择 $1$ 个\n\n直接枚举组时挨个枚举物品就行了。  \n按照组划分阶段，第 $i$ 组不选则 $f_{i,j} = f_{i-1,j}$，第 $i$ 组选第 $k$ 个则 $f_{i,j} = f_{i-1,j-v_{i,k}} + w_{i,k}$\n\n这里直接给出数组删维优化过的代码\n\n```cpp\nfor (int i = 1; i <= n; ++ i) {\n\tfor (int j = m; j >= m; -- j) {\n\t\tfor (int k = 1; k <= c[i]; ++ k) {\n\t\t\tf[i][j] = max(f[j], f[j-v[i][k]] + w[i][k]);\n\t\t}\n\t}\n}\n```\n\n## 依赖背包\n\n~~我的 Windows 盘还剩 5 个 G，新买的东方冰之勇者记占 2G,LLVM 依赖于 MSVC 生成工具，MSVC 占用 2G 磁盘，LLVM 占用 2G 磁盘，问我应该怎么安装收益最大~~  \n~~reboot to archlinux!~~\n\nA 物品依赖于 B，选 B 物品之前需要先选 A 物品，问最大价值\n\n容易发现对于任意有依赖关系的物品 A B 来说，一共有以下三种可能的决策  \n（A 依赖 B）\n\n1. A B 都不选\n2. 选 B 不选 A\n3. A B 都选\n\n因为这三种情况只会出现一个，联想分组背包的特征，将这三种情况每个看成一个组里的物品，即转化为了分组背包。\n\n当成树形 DP 好做一点，加到 TODO 里面。","tags":["动态规划","背包问题"],"categories":["动态规划"]},{"title":"质数筛法","path":"/post/prime-sieve/","content":"埃氏筛```text2 3 4 5 6 7 8 92 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 //筛掉2的倍数2 3 5 7 ~~9~~ //筛掉3的倍数```例：```cpp#include <cstdio>#include <cmath>bool b[100000005];int main() { int n; scanf(\"%d\",&n); for (int i=2; i <= sqrt(n); i++) { // 注意枚举质数的范围 if (!b[i]){ // b[i]值为0表示i为质数 for (int j = i; j <= n/i; j++) { // 筛掉i的倍数 b[i*j]=1; } } } for (int i = 2; i <= n; i ++) { if (!b[i]){ printf(\"%d \",i); } } return 0;}```11 行处为一个小优化：$i$ 的倍数从 $i^2$ 开始枚举 （考虑 $j = k\\cdot i<i\\cdot i$， $j$ 一定会被 $k$ 的质因数筛去）举个例子：筛 $2$ 的倍数时，被打标记的数字分别是```TEXT2*2,2*3,2*4......2*n/2```那么我们筛 $i$ 的倍数时，无优化算法被打标记的数分别是```i*2,i*3,i*4.......i*n/i```可以发现，$2i$ 和 $4i$ (即 $2\\cdot 2i$)在枚举 $2$ 的倍数时已经被打过标记了  其他任意一个 $k\\cdot i, 2\\leqslant k< i$ 都同理。线性筛 (转载)版权声明：下方为lyf_018原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/qq_41653433/article/details/88976544初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数。如果按照埃氏筛做法枚举每个质数的倍数，会造成重复筛除，影响效率。例如 $30=5\\times 3\\times 2$，它被 $2\\times 15$ 筛了一次，又被 $3\\times 10$ 筛了一次，为了解决这个问题，线性筛应运而生：```cppint mark[MAXN];  int prime[MAXN]; //判断是否是一个素数  Mark 标记数组 index 素数个数  int Prime(int n){ int index = 0; for(int i = 2; i < n; i++){ //如果未标记则得到一个素数 if(mark[i] == 0) prime[++index] = i; //标记目前得到的素数的i倍为非素数 for(int j = 1; j <= index && prime[j] * i < n; j++){ mark[i * prime[j]] = 1; if(i % prime[j] == 0) break; } } return index;  }```利用了每个合数必有一个最小素因子。每个合数仅被它的最小素因子筛去正好一次。所以为线性时间。  代码中体现在：```cppif(i%prime[j]==0) break;```$prime$ 数组中的素数是递增的,当 $i$ 能整除 $prime_j$，那么 $i\\cdot prime_{j+1}$ 这个合数肯定也可以被 $prime_j$ 筛掉，因为 $i$ 中含有 $prime_j$, $prime_j$ 比 $prime_{j+1}$ 小。接下去的素数同理，所以不用筛下去了。 在满足 $i\\  \\bmod \\ prime_j = 0$ 这个条件之前以及第一次满足该条件时,$prime_j$ 必定是 $prime_j\\cdot i$ 的最小因子","tags":["数论"],"categories":["数学"]},{"title":"搜索基础","path":"/post/basic-search/","content":"## DFS与BFS\n\n深度优先搜索： 一棵树从一个枝向下搜索，搜到头之后回溯，继续搜下一个枝  \n宽度优先搜索（Breath First Search 而不是 Brain Fuck Scheduler）（后者已经停止维护了）： 一层一层搜到底部\n\n### DFS\n\n注意回溯需要“恢复现场”\n\n[一个例题](https://luogu.com.cn/problem/P1706)\n \n```cpp\n#include <cstdio>\n\nconst int N = 10;\n\nint n; // 层数\nint path[N]; // 存储状态\nbool state[N]; // 存储各个枝是否被使用\n\nvoid dfs(int a) {\n    if (a == n) { // 到达最底层\n        for (int i = 0; i < n; i ++) {\n            printf(\"%5d\",path[i]);\n        }\n        putchar('\\n');\n        return ;\n    } \n    \n    for (int i = 1; i <= n; i ++) {\n        if (!state[i]) { // i没有被使用\n            path[a] = i;\n            state[i] = 1;\n            dfs(a+1); // 搜索下一层\n            state[i] = 0; // dfs结束之后，开始回溯，恢复现场\n        }\n    }\n}\n\nint main() { \n    scanf(\"%d\",&n);\n\n    dfs(0);\n\n    return 0;\n}\n\n```","tags":["搜索"],"categories":["基础算法"]},{"title":"STL","path":"/post/cpp-stl-container/","content":"## STL\n\n### vector 变长数组\n需要引入头文件`vector`\n#### 声明\n```cpp\nvector<类型> 名称\n```\n多个vector组成的数组\n```cpp\nvector<类型> 名称[some_num]\n```\n此处的类型也可以是自定义的结构体、类\n\n示例\n```cpp\n#include<vector>\nvector<int> a;\nvector<int> b[233];\n```\n#### [常用命令](##STL容器常用命令)\n#### 迭代器\n类似指针/数组下标之类的东西\n\n```cpp\n#include <vector>\n#include <iostream>\nint main() {\n    vector<int> a({\"NVIDIA\",\"FUCK\",\"YOU\",\"EOF\"});\n\n    std::cout << *a.begin() << std::endl; // a.begin() 指向 a 的第一个元素 此处相当于 a[0]\n    std::cout << *(a.end()-1) << std::endl; // a.end() 指向 a 的最后一个元素的后一位，直接使用是越界访问，此处相当于 a[a.size()-1]\n\n    vector<int>::iterator it = a.begin();\n    vector<int>::iterator it_end = a.end(); // C++11 显然使用 auto it=a.begin(); 更好写\n    std::cout << *it << std::endl; // 此时相当于 a[0] 与 *a.begin()\n    // vector 的迭代器是一个随机访问迭代器，可以加减\n    std::cout << *(it + 1) << std::endl; // 相当于 a[1]\n    std::cout << *(it-it_end) << std::endl; // 求两个下标之间的距离\n    return 0;\n}\n```\n\n## STL容器常用命令\n```cpp\nsth.size(); // 返回容器 sth 的实际长度（包含的元素个数）\nsth.empty(); // 返回一个 bool 值，表示容器 sth 是否为空\nsth.clear(); // 把容器 sth 清空\n```","tags":["STL"],"categories":["C++"]},{"title":"类与结构体","path":"/post/cpp-class-struct/","content":"## 类 (class) 与 结构体 (struct)\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass Person {\n    private: // Person类私有 只能在 Person 这个类里面调用\n        int age, height;\n         double money;\n    public:\n        string name;\n        void say() {\n            cout << \"I'm \" << name << endl;\n        }\n        int get_age() {\n            return age; // Person 类中可以调用由 Person 类私有的量\n        }\n        void add_money(int a){\n          money += a;\n        }\n    private: // private/public 可以有多个\n        string books[1000];\n};  // 类定义结束要加分号\n\nint main(){\n    Person pinghigh();\n    Person persons[10]; // 可以定义一个 Person 类的数组\n    pinghigh.name = \"Tibrella\"; // name 是公有变量，外部可以访问\n//  pinghigh.age = 15;    //!错误， age 是私有变量，外部不可访问\n    pinghigh.add_money(12345);\n    pinghigh.say();\n    cout << pinghigh.get_age() << endl;\n    return 0;\n}\n```\n\n输出:\n\n```text\nI'm Tibrella\n14\n```\n\n### class 与 struct 的异同\n\n唯一一点不同是 class 中的量默认为 private , struct 中的量默认为 public  \n其他完全相同","tags":["C++","结构体","类"],"categories":["C++"]},{"title":"STL string","path":"/post/stl-string/","content":"可变长的字符序列，需要引入头文件 `<string>`\n\n### 赋值\n\n```cpp\n#include <string>\nusing namespace std;\nint main(){\n    string s1; // 默认空字符串\n    string s2 = s1; // string 类型可以互相赋值，无需 memcpy() 或 strcpy() 。 s2 是 s1 的一个副本\n    string s3 = \"hiya\"; // s3 是该字符串(\"hiya\")字面值的一个副本（我也不知道是什么，总之 s3 的值是\"hiya\"\n    string s4(5,'T'); // s4 的内容是“TTTTT”\n\n    return 0;\n}\n```\n\n### 输入输出\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n    string s1, s2;\n\n//读入无空格字符串\n    cin >> s1; // scanf() fgets() 不能读入 string 类型\n//读入一行\n    getline(cin,s2);\n//输出\n    cout << s1 << endl << s2 << endl;\n    /*\n    printf() 不能直接输出string类型\n    需要写成 printf(\"%s\",s1.c_str())\n    这里 s.c_str() 作用是把 string 类型转化为字符数组\n    */\n    // 当然也可以 puts(s1.c_str())\n\n    return 0;\n}\n```\n\n#### 后记\n\n使用 `getline(cin,str)` 输入时需要注意回车符  \n什么意思呢？举个例子\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n  string a,b;\n  cin >> a;\n  getline(cin, s);\n  cout << a << endl << b << endl;\n  return 0;\n}\n```\n\n这时你输入\n\n```TEXT\nNVIDIA\nFUCK U\n```\n\n程序会在你输入完第一行后直接输出一个`NVIDIA`与几个换行符  \n原因是 cin 遇到回车停止，此时 getline 直接把`NVIDIA`后的部分(空)读入然后再次遇到回车符，停止输入。  \n为了避免这种情况，我们需要忽略掉一个回车符，可以使用`getchar()`。\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n  string a,b;\n  cin >> a; // NVIDIA\n  getchar(); // \\n（跳过一个换行符）\n  getline(cin, s); // FUCK U\n  cout << a << endl << b << endl;\n  return 0;\n}\n```\n\n### 常用操作\n\n-   `str.empty()`\n    -   返回一个 bool 值。\n    -   如果 string 为空返回 1，非空返回 0。\n-   `str.size()` 返回 string 的长度，等价于 `s.length()`\n    -   `strlen()` 需要循环一遍数组，时间复杂度为 O(n)。\n    -   `str.size()` 不需要循环，时间复杂度为 O(1)。\n-   比较\n    -   string 型之间按字典序比较直接 `str1 < str2` 即可，`== != <= >= < > <=>`都支持。\n-   相加\n    -   string 型之间相加直接 `str1 += str2`、`str3 = str1 + str2` 这样写即可。\n    -   与其他类型（字符、字符串）相加时会先把这些类型的量转化为 string 对象，可以直接加这些类型的量，如 `str += 'a'` 、 `str1 = str2 + \"abc\"`\n    -   相加运算时，必须保证等号两边都有 string 型，`str1 = str2 + \"hello\" + 'a' `、 `str1 += \"hello\"` 是可以的， 但是 `str1 = \"hello\" + 'a'` 会报错。\n        -   注意运算顺序，如 `string s1 = s2 + \"abc\" + 'd'` 正确，因为会先将 s2 与 \"abc\" 相加得到另一个 string 对象，再继续运算。而 `string s1 = \"abc\" + 'd' + s2` 会报错，因为 \"abc\" 和 'd' 不能相加 （\"abc\"和\"cde\"也不行）\n-   操作单个字符\n\n    -   可以当作字符数组处理，如 `str[0]` , `str[3]`\n    -   独特的遍历方式\n\n        ```cpp\n        #include <iostream>\n        #include <string>\n        using namespace std;\n        int main(){\n          cout << \"So, NVIDIA,\" << endl;\n          string s = \"Fuck U\";\n          for (char c : s) { // char c可以写作 auto c\n            cout << c << endl;\n          }\n          return 0;\n        }\n        ```\n\n        输出：\n\n        ```text\n        So, NVIDIA,\n        F\n        u\n        c\n        k\n\n        U\n        ```\n\n-   `str.pop_back()` 删除 string 型字符串的最后一个字符\n-   `str.substr(int i,int len)`\n    -   输出字符串 str 从 i 开始长度为 len 的字符串","tags":["字符串"],"categories":["C++"]},{"title":"字符数组","path":"/post/cpp-string/","content":"color:error 警告 本文有因为初学 C++ 臆想过多导致的很多谬误，待修字符数组输出```cpp#include <iostream>#include <cstdio>using namespace std;int main(){ char str[3]=\"ab\"; // 以下三种输出方式都是遇到换行或空格不停止，而是遇到'\\0'才停止 cout << str << endl; printf(\"%s\\n\",str); puts(str); // 等价于上面的printf语句 return 0;}```读入分两种情况  1.读入一个字符串，遇到空格/回车停止  使用 cin```cpp#include <iostream>using namespace std;int main(){ char str[3]; cin >> str; //输入 cout << str << endl; return 0;}```或使用 scanf```cpp#include <cstdio>int main(){ char str[3]; scanf(\"%s\",str); //输入 /* 这里注意一点，str 不能写作 &str 数组名实际上是一个指针，存储数组的第一个元素的内存地址（指向数组的第一个元素） scanf(\"%s\",__) 这里下划线部分应当是一个内存地址，而整型、浮点、字符等类型变量中存储的不是地址而是它对应的内容，所以需要用‘&’取出它的内存地址，如取出整型（int）变量a的内存地址就是 &a。 而数组名本身就存储着内存地址，所以不需要再用 & 取一遍内存地址 */ printf(\"%s\",str); return 0;}```2.读入一行内容，输入空格不停止```cpp#include <iostream>#include <cstring>using namespace std;int main(){ char str[100]; fgets(str,100,stdin); // gets() 函数在 C11 标准中因为容易溢出而被删除，取而代之的是 fgets() /* \"str\"为字符串名 “100”是读入的最大字符数（一般使用数组长度即可） “stdin”应该是一个接口，不用管，照着写就行 */ cout << str << endl; return 0;}```或```cpp#include <iostream>#include <cstdio>#include <string>using namespace std;int main(){ char str[100]; string str1; cin.getline(str,100); // 字符数组使用 cin.getline() getline(cin,str1); // string 使用 getline() cout << str << endl << str1 << endl; return 0;}```常用函数[^1]- `strlen(str)` 求字符串长度（不包含'\\0'）- `strcmp(a,b)` 比较两个字符串大小(ASCII 码)， a < b 返回 -1 ，a == b 返回 0， a > b 返回 1（比较方式为字典序[^2]）- `strcpy(a,b)` 将字符串 `b` 赋值给从 `a` 开始的字符数组strlen()示例```cpp#include <iostream> // 用于输出#include <cstring> // 或者string.h，这是C语言的头文件using namespace std; // 用于输出int main(){ char s[100]=\"abc\"; cout << strlen(s) << endl; return 0;}```strcmp()示例```cpp#include <iostream> // 用于输出#include <cstring> // 或者string.h，这是C语言的头文件using namespace std; // 用于输出int main(){ char s[100]; scanf(\"%s\",s); cout << strcmp(s,\"abc\") << endl; return 0;}```此处将输入的字符串与 abc 进行比较```text输入#1 bac#2 abc#3 aac输出#1 1#2 0#3 -1```strcpy 示例```cpp#include <iostream> // 用于输出#include <cstring> // 或者string.h，这是C语言的头文件using namespace std; // 用于输出int main(){ char s1[100]=\"abc\",s2[100]; strcpy(s2,s1); // s1 复制到 s2 cout << s2 << endl; return 0;}```输出为`abc`[^1]: 以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。 如 ```cpp for (int i = 0; i <= strlen(str); i++) ``` 最好改写成 ```cpp for (int i =  0, len=strlen(str); i <= len; i++) ```[^2]: 字典序：从前向后比，如 2 与 10，比较数字则 10 大，按字典序比较则是 2 大（因为 2>1）","tags":["C++","字符串","字符数组"],"categories":["C++"]},{"title":"读入未知数量的数据","path":"/post/cpp-read-until-eof/","content":"实际上是借助读入函数的返回值实现的。\n\n```cpp\n#include <stdio.h>\nint main() {\n    int k,sum=0;\n    while (scanf(\"%d\",&k) != EOF)   // EOF是读取结束标识\n    // 又因为 scanf 在读取到 EOF 会返回 -1，所以也可以写成 while (~scanf(\"%d\",&k))\n    {\n        sum += 1;\n    }\n    printf(\"%d\",sum);\n    return 0;\n}\n```\n\n另外一点值得注意的是，关于使用 `cin >> x` 时的返回值并不是 `cin` 的返回值，`cin` 只是一个对象，而实际进行运算的是流运算符 `>>`。\n\nWindows 系统输入 [^组合键]\n\n```shell\n1 2 3\n^z\n```\n\nGNU/Linux 输入\n\n```shell\n1 2 3\n^d\n```\n\n输出\n\n```text\n3\n```\n\n[^组合键]: 本文中\\^z、\\^d 都指组合键，\\^d 为 Ctrl+D，\\^z 为 Ctrl+Z。","tags":["C++"],"categories":["C++"]},{"title":"最大公约数","path":"/post/gcd/","content":"## 最大公约数\n### 辗转相除法\n\n例：\n```text\n70 % 50 = 20\n50 % 20 = 10\n20 % 10 = 0\n```\n\n取模到0为止，此时10就是70、50最大公约数\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n    int a,b,r;\n    cin >> a >> b;\n    while (a % b != 0){\n        r = a % b;\n        a = b;\n        b = r;\n    }\n    cout << b << endl;\n    return 0;\n}\n```\n\n### 更相减损术\n\n```text\n54 24\n|        除以2（可除可不除，除后方便计算）\nV\n27 12\n27-12=15    大减小\n...\n...\n\n6-3=3\n```\n\n此处3=3,所以最大公约数为3","tags":["最大公约数"],"categories":["数学"]},{"title":"Hello World","path":"/post/hello world/","content":"这是一个测试页\n\n```cpp\n#include <iostream>\n\nusing std::cout;\n\n#define endl '\\n'\n\nint main() {\n    std::ios::sync_with_stdio(0);\n    cout.tie(0);\n\n    cout << \"Hello World!\" << endl;\n\n    return 0;\n}\n```\n\n$Test Math$ ~~好吧，数学好像还不支持~~ 添加了支持[^1]  \n$$ Test $$\n\n[^1]: 注释测试；~~另外，如果在本站任意位置发现数学公式未渲染且确认不是您的网络问题，请刷新一下。~~ 修好了，可能就是你的网络问题。"},{"title":"关于","path":"/about/index.html","content":"一个正在学习 OI 的将要退役的傻逼。\n\n欢迎一起交流。"},{"path":"/links/index.html","content":"# 友情链接标题：Tibrella 的隙间  URL：https://blog.tibrella.space/ 或 https://www.tibrella.space/  简介：天终会再明。"},{"title":"Timeline","path":"/timeline/index.html","content":"2021 年 ? 月 ? 日使用 Github Pages + LOFFER 搭建了第一个博客页面，上传了一个给某历史老师的整活文章。 2022 年 1 月 ? 日在 C4096 的引路下开始使用 Arch Linux。~~命运的齿轮开始转动~~ 2022 年 ? 月 ? 日迁移至 Hexo + Butterfly，并开始记录 Linux 折腾笔记。 2022 年 6 月 20 日中考前一天把自编译内核 linux-tikogasa 搞了出来，同时折腾了 github actions。仓库已经删除了，这是 yjacks 的 fork 存档 2023 年 6 月 ? 日飞蛾扑火。 2022 年 3 月 14 日购买 tibrella.top 域名。 2022 年 12 月 28 日为 Catium 的 PHP 练手项目编写了纯 HTML + CSS 前端页面，同时是我第一次接触前端。 2023 年 2 月 24 日博客切换到 Hugo + Stack。 2023 年 5 月 18 日用纯 HTML + CSS 写了初代个人主页。 2023 年 6 月 8 日学习 React JSX，并用两天时间搭配 Geist UI 写出了第二代个人主页。 2023 年 8 月 16 日博客切换回 Hexo + Stellaris。 2023 年 11 月 18 日退役，回归高考 2023 年 12 月 ? 日tibrella.top 过期，购买十年 tibrella.space 域名。"},{"title":"Tikogasa Kernel","path":"/wiki/linux-tikogasa/index.html","content":"本内核由于 ZFS-builtin 违反许可证，所以只提供构建脚本，不分发二进制包。\n\n仓库中的 config 不是默认优化而是我自己写的，精简掉了很多模块（比如 XFS，INTEL 显卡，除了 Realtek 以外的所有声卡等），所以你需要自己搞一份 config。\n\n实际上优化 config 的过程是在 PKGBUILD 里写好了的，所以你把 Arch 官方的配置拿来 build 也没问题。\n\n添加了 cjktty 补丁。\n\n编译时添加了特异化编译，所以你需要在 config 和 PKGBUILD 里找到 `ZEN2` `znver2` 相关字样，换成你自己的架构。"}]