[{"content":"最近因为原来 我的 butterfly 主题 fork 实在改不动了（实际上因为我水平太差），对于 pug 什么的也不太懂，同时由于界面过于花哨看腻了，想换点动态效果少的而又相对简单的博客主题。 又因为之前就观察过 hugo 的主题列表，hugo 的特点是快，大部分的 hugo 主题也非常简洁（比如 c4096 的博客所采用的主题），因此我又双叒叕去 hugo theme 列表挑了个非常符合我审美（大概）的主题，即 stack。\n最一开始用 test 界面测试主题功能的时候 hugo 的速度就惊艳我了，实在是过于迅速，和我之前所用的 hexo+butterfly 的速度相比，hugo 让我感觉到构建了又好像没构建的构建过程。同时它的即时修改即时预览功能也很好用（有的时候并不能做到完全应用新修改）。 但是一起到来的问题也很多，比如 stack 主题的文档并不是很完善，相对于我看过的大部分 hexo 主题来说可能是最不完善的（中英文倒是无所谓），因此我需要一边看文档一边看源码，还得看主题的示例站点的配置文件才让我的博客跑出正常的样子。\n主题配置问题还算好解决，对于我这个啥都不懂还贼挑的人来说，改动主题是必须有的部分，但是 hugo 的编写修改维护主题的文档和教程更是少之又少了\u0026hellip;因此研究了好久也没研究出来怎么改代码块样式，改配色也没成功，但是把深浅色代码块背景宽度不统一的问题倒是解决了，还得对这个进行进一步更改。当然，主题克隆下来的第一步就是 copyright-\u0026gt;copyleft，然后给 \u0026amp;copy 掉个头，文章许可证改为 FDL 1.3 才继续做接下来的修改。\n关于写配置，我最开始采用的是网上得到大部分好评的 toml 格式，据说比 yaml 新还好用，在此之前因为 yaml 的缩进问题我痛苦了很长时间，但是折腾了好久 toml 之后感觉 toml 更不容易被人类理解（可能只有我不理解），然后用工具回到了 yaml 的怀抱，在此之前为了研究 toml 的 map 映射语法之类的东西已经折腾不动了\u0026hellip;\n关于换行，由于之前的 butterfly 主题能够自动换行，但是 stack 主题默认用的是 markdown 的换行规则，即行尾双空格或回车两次为一个换行，于是我博文基本上都炸了，会找时间修（逃\n","date":"2023-02-24T21:40:29Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-2-24-move-to-hugo/","title":"更改博客主题之后的一些破事"},{"content":"模拟退火不是模拟题意，也不会让你退火（可能会让你上火），顾名思义，这个算法模拟的是“退火” 的过程。\n基本原理 退火即晶体冷却的过程，将一个物体加热到一定温度后使其逐渐降温。而在物理中，物体内能越高，其粒子随机运动就更剧烈，状态也就越不稳定。物体温度高时，状态最不稳定。使降温，粒子运动变慢，状态就趋于稳定。当降温速度过快，会导致粒子来不及排列成稳定的原有的结构，从而形成能量高不稳定的非晶体。相对的，如果降温速度足够慢，粒子会渐趋有序，直至内能减为最小，此时物体呈现为晶体。\n上面两段所说的“非晶体”可以看作“局部最优解”，而变回原有结构的晶体则可以看作“最优解”。\n大体来说，模拟退火就是随机跳解，接受更优的解，同时为了防止局部最优解的陷阱，概率性接受不优的解，后者相当于物理过程中粒子的随机跳动，它带来了晶体降温结果的随机性。而跳随机解的次数多少，则相当于降温的速度，降温的速度越慢，晶体回到原有结构的可能性更高，也就相当于跳解的次数越多，跑出最优解的可能性更高。\n先放一张图感性理解一下\n有一个比较有趣的比喻\n爬山算法：一个兔子从一个点往高爬，爬到了一个山顶，但是不知道这个山顶是不是珠穆朗玛峰\n模拟退火：一个兔子喝醉了乱跳，跳到了某个山顶也要继续跳到别的山坡，但是它逐渐清醒，向最高点跳去\n感性理解后我们详细讲解一下算法过程。\n算法过程 设定好“初始解”，“初始温度”与“下降速度”，每一次“降温”都得到一个新解，于是出现两种情况，即新解优于旧解或不优于旧解。优于旧解显然是要接受的，但是只接受优解可能只能找到局部最优，与爬山算法无异，因而我们对于一个不优的解还需要进一步处理。\n而这一步处理（可能是）模拟退火的精髓所在，是把这个随机化算法和热力学/统计力学等连接起来的部分，即接受这个不优解的概率。\n摘自维基百科\n玻尔兹曼分布是状态能量与系统温度的概率分布函数，给出了粒子处于特定状态下的概率\n公式即为\n$$ p_i = \\frac{1}{Q} e^{\\frac{-\\epsilon_i}{kT}} $$\n此处 $p_i$ 是状态 $i$ 的概率，$\\epsilon_i$ 为状态 $i$ 的能量，$k$ 为 Boltzmann 常数，$T$ 为温度\n啊当然这个并不是我们接下来需要用到的准则，只是引入一个热力学常量，即 Boltzmann 常数。同时下面的准则很大程度基于上面的玻尔兹曼分布（可能是，我目测的\n1953 年 Metropolis 提出了这样一个重要性采样的方法，即设从当前状态 $i$ 生成新状态 $j$，若新状态的内能小于状态 $i$ 的内能，即 $E_j\u0026lt;E_i$，则接受新状态 $j$ 作为新的当前状态；否则，以概率 $\\exp(\\frac{-(E_j-E_i)}{kT})$ 接受状态 $j$，其中 $k$ 为 Boltzmann 常数。\n上面的概率公式中 $\\exp$ 即 $e$ 的指数函数，同时两个状态能量的差 $E_j - E_i$ 可以表示为 $\\Delta E$，则可以写出一个（我）更容易理解的表达方式，即\n$$ p_j = e^\\frac{-\\Delta E}{kT} $$\n总的来说，概率 $p_{new}$ 可以表示为\n$$ p_{new} = \\begin{cases} 1, \u0026amp; \\text{if } \\operatorname{E}(x_{new}) \u0026lt; \\operatorname{E}(x_{old}) \\\\ e^\\frac{-\\Delta E}{kT} \u0026amp; \\text{if } \\operatorname{E}(x_{new}) \\geqslant \\operatorname{E}(x_{old}) \\end{cases} $$\n概率处理完了，主要算法部分也基本上结束了，下面我们引入一道例题。\n例题 题面：\n[JSOI2004] 平衡点 / 吊打XXX 题目描述 如图，有 $n$ 个重物，每个重物系在一条足够长的绳子上。\n每条绳子自上而下穿过桌面上的洞，然后系在一起。图中 $x$ 处就是公共的绳结。假设绳子是完全弹性的（即不会造成能量损失），桌子足够高（重物不会垂到地上），且忽略所有的摩擦，求绳结 $x$ 最终平衡于何处。\n注意：桌面上的洞都比绳结 $x$ 小得多，所以即使某个重物特别重，绳结 $x$ 也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。\n输入格式 文件的第一行为一个正整数 $n$（$1\\le n\\le 1000$），表示重物和洞的数目。\n接下来的 $n$ 行，每行是 $3$ 个整数 $x_i, y_i, w_i$，分别表示第 $i$ 个洞的坐标以及第 $i$ 个重物的重量。（$-10000\\le x_i,y_i\\le10000, 0\u0026lt;w_i\\le1000$）\n输出格式 你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结 $x$ 的横坐标和纵坐标。两个数以一个空格隔开。\n样例 #1 样例输入 #1 3\r0 0 1\r0 2 1\r1 1 1 样例输出 #1 0.577 1.000 物理还没学势能所以题解先咕咕\n","date":"2023-02-23T14:11:18Z","image":"https://pic.imgdb.cn/item/63f76817f144a01007c05a60.jpg","permalink":"https://blog.tibrella.top/post/2023-2-23-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","title":"模拟退火"},{"content":"题意 一张有向无环带权图，有一个初始值 $k$，从入口进入后每过一条边 $i$ 则 $k = k \\times 2+w_i$（$w_i$ 为边权，有正有负），要求从入口到出口的过程中始终 $k\u0026gt;0$，求使方案存在的最小初始值 $k$。\n思路 之前什么答辩题面\n先忽略 $k$ 经过一条边时翻倍，只考虑加边权，如何求出答案？由于图带边权，保证不出现环，同时判断一个 $k$ 值是否合法的方式实际上是计算一条路径边权和并与 $k$ 比较，联想到最短/长路。\n新题面中提到只需存在一种方案能让出口 $k\u0026gt;0$ 即可，显然是最短路。但是如果从起点求最短路还要考虑 $k$ 的影响，因此反向建图，终点初始值设为 $1$，从终点跑即可。\n由于边权有正有负，只能跑 SPFA。\n再考虑 $k$ 的变换还有一个 $\\times 2$，因此跑反向的 SPFA 松弛边时需要把新算出的 $dist_i$ 值除以 $2$。\n代码 #include \u0026lt;bitset\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; // 模板函数可以参考博文 https://blog.tibrella.top/post/2023-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%9D%82%E8%B0%88%E4%B8%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/ template \u0026lt;typename Type\u0026gt; void read(Type\u0026amp; _x) { _x = 0; bool f; char ch; f = 0; do { ch = getchar(); if (ch == \u0026#39;-\u0026#39;) f = 1; } while (ch \u0026lt; 48 || ch \u0026gt; 57); do { _x = (_x \u0026lt;\u0026lt; 3) + (_x \u0026lt;\u0026lt; 1) + (ch ^ 48); ch = getchar(); } while (ch \u0026gt; 47 \u0026amp;\u0026amp; ch \u0026lt; 58); _x = f ? -_x : _x; } template \u0026lt;typename Type\u0026gt; Type max(Type _a, Type _b) { return _a \u0026gt; _b ? _a : _b; } using std::bitset; using std::queue; #define N 105 struct edge { edge* nex; int u, v, w; } graph[N * N]; edge* fir[N]; int dis[N]; edge* idx = graph; int n; queue\u0026lt;int\u0026gt; q; bitset\u0026lt;N\u0026gt; st; void add(int u, int v, int w) { ++idx; idx-\u0026gt;u = u; idx-\u0026gt;v = v; idx-\u0026gt;w = w; idx-\u0026gt;nex = fir[u]; fir[u] = idx; } void spfa(int nod); int t1; int main() { read(n); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { read(t1); // 中转变量 if (t1) add(j, i, -t1); // 反向存图 } } spfa(n); printf(\u0026#34;%d\u0026#34;, dis[1]); return 0; } void spfa(int nod) { st.reset(); memset(dis, 0x3f, sizeof dis); dis[nod] = 1; st[nod] = 1; q.push(nod); while (!q.empty()) { nod = q.front(); q.pop(); st[nod] = 0; for (edge* e = fir[nod]; e; e = e-\u0026gt;nex) { if (dis[e-\u0026gt;v] \u0026gt; max(1, (dis[nod] + e-\u0026gt;w + 1) / 2)) { // +1 防止除法向下取整造成错误 dis[e-\u0026gt;v] = max(1, (dis[nod] + e-\u0026gt;w + 1) / 2); if (!st[e-\u0026gt;v]) { q.push(e-\u0026gt;v); st[e-\u0026gt;v] = 0; } } } } } ","date":"2023-02-23T14:11:18Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-2-26-s2oj-184/","title":"细菌 题解"},{"content":"倍增求 LCA 是一种高效的求 LCA 算法，时间复杂度为 $\\operatorname{O}(\\log{n})$\n原理 初始 维护一个 $fa_{i,x}$ 表示 $x$ 往根节点走 $2^i$ 步到达的节点。\n初始化时 $fa_{0,x} = father_x$ 更新为 $fa_{i,x} = fa_{i-1,fa_{i-1,x}}$ 查询 中心思想是利用二进制向上跳。\n假设目前要查询 a 号节点和 b 号节点的 LCA，将较深节点设为a，较浅设为b，即：\n首先将 a 向上跳到和 b 同一高度，若此时 a = b，直接返回 b 即可，即 b 为 a 的一个直接父亲，LCA 也一定是 b。 否则将两个节点同时往上跳，$i$ 从大到小，每次跳 $2^i$，规则如下： 如果跳完两个节点相同，即找到了一个共同祖先，则不跳，因为此时不能确定这个共同祖先是不是最近的。 否则就继续同时往上跳，最终返回 $fa_{0,a}$ 即可。 ","date":"2023-02-02T21:27:12Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-2-2-lca/","title":"倍增求LCA/最近共同祖先"},{"content":"起因是发现很多同学对常数优化和语句的执行效率有误解（我肯定也有，但是我尽量把我知道的正确的写出来），因此写一篇杂谈做一个说明，同时介绍一些比较新的好用的语言特性（C++14）\ntemplate 模板函数 基本 template 顾名思义是用来做模板的，那是做什么的模板呢？ 举个例子，一般来说我们写 max 函数替代 std::max 来优化的时候，写出来的大概长下面这样：\nint max(int a, int b) { return a \u0026gt; b ? a : b; } 在这三行代码中，第一行定义了 max 的返回值和参数 a b 的类型为 int，显然意味着这个函数只能比较 int 类型的量。\n那么如果既想要比较 int 又想要比较 long long 还想比较 char 等等，如果按传统的写法，就是 Ctrl+C Ctrl+V 写好几个比较函数，还得重新命名，甚是麻烦。\n观察写出来的几个函数，肉眼可见他们的本质区别只有返回值与参数的类型。那么有没有一种类似模板的东西，写一个函数的主要部分作为模板，返回值、变量的类型由编译器决定呢？\n这就是 template 的一大作用，也是 OI 中最常用的方面。\n使用起来也很简单，在函数声明前面加上 template \u0026lt;typename T\u0026gt;，此处 T 可以是随便一个字母或者单词，后面写函数的时候把 int 替换成 T 即可。\ntemplate \u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b ? a : b; } 此时的 T 相当于一个变量类型，如果这个函数被调用，编译器会给你生成一个符合传入参数的类型的 max 函数。\nTODO: ... 关键字 基于范围的循环 不过多介绍了，主要在 STL 里用\nfor (auto i : container) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } container 为容器的名称，auto 是 C++11 以后的类型名称，编译时由编译器推断。\n此处 auto 的效果就是把 i 的类型设置为 container 的元素的类型。如果 container 是 vector\u0026lt;int\u0026gt; ，则上面语句的效果就是遍历 container 的所有元素并输出。\n此外，如果想遍历的同时修改容器中的元素，可以在 i 前加取址符 \u0026amp; 表示引用，如下\nfor (auto \u0026amp;i : container) { i = 0; } 该段代码的效果即为遍历容器 container，同时把其中所有元素赋值为 0;\n","date":"2023-02-02T21:06:12Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%9D%82%E8%B0%88%E4%B8%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/","title":"语言特性杂谈与常数优化"},{"content":"求一个字符串最长的回文子串。 字面意思，回文就是一个串正着读倒着读一样，子串就是一个连续的子序列。\n预处理 不难发现对于一个回文字串，有两种情况：\nABBA 即长度为偶数，没有中心字符，半径为 2，长度为 4 ABCBA 即长度为奇数，有中心字符，半径为 3，长度为 5 懒得给他们处理两种情况，怎么办？只需要插入一些其他字符即可。\n比如说我们可以在头部插入一个 ? 代表串开始，^ 代表串结束，然后在新串的每一个字符之间插入一个 # 号，得到的新串就能达到简化情况的目的。 按照上面的方法处理之后，原来的两个串会变为：\n（只观察回文子串）\n?#A#B#B#A#^ 长度变为奇数，有中心字符，半径为 5，长度为 9 ?#A#B#C#B#A#^ 长度为奇数不变，有中心字符，半径为 6，长度为 11 情况被简化成一种，即长度为奇数。与此同时我们发现，新串的回文子串的 半径$-1$ 就是原串回文子串的 长度\n与此同时，问题不变，还是求串的最长回文子串。\nvoid init() { b += \u0026#39;$\u0026#39;; b += \u0026#39;#\u0026#39;; for (int i = 0; i \u0026lt; n; ++i) { b += a[i]; b += \u0026#39;#\u0026#39;; } b += \u0026#39;^\u0026#39;; n=b.size(); } Manacher 基本思想 抽象来说就是对于字符串的每一个位置，维护以这个位置为中心的最长回文串长度同时算出这个回文串的右边界，再通过这个右边界来更新下一个位置的最长回文串长度与右边界。\n具体来说，对于一个字符串 $S$，开一个数组 $P_i$ 记录以 $i$ 为中心的最长回文串半径（含 $S_i$），变量 $mid$ 为在 $i$ 之前边界最靠右的回文子串的中心，$mr$（也就是 $maxright$）记录这个回文子串的右边界，通过这些更新下一个位置的这些值。\n为了方便说明，以 $i$ 为中心的最长回文子串称为 $T_i$\n继承对称点的数据 枚举到 $i$ 之前的状态：\n枚举到 $i$ 后，对于 $mr$ 和 $i$ 来说有两种情况：$i$ 在左侧或 $mr$ 在左侧\n$i$ 在左侧 即 $i$ 被 $T_{mid}$ 包含。\n显然 $i$ 之前的 $P_k$ 都是已知的，同时 $i$ 在一个回文字串内，那么假设 $j$ 是 $i$ 关于 $mid$ 的对称点，则\n那么 $P_j$ 已知，对于以 $j$ 为中心的最长回文子串 $T_j$ 来说有两种情况\n$T_j$ 被 $T_{mid}$ 完全包含，此时 $P_i$ 可以继承 $P_j$ （因为回文）（不用考虑边界问题，后续会处理） $T_j$ 未被 $T_{mid}$ 完全包含，此时 $T_i$ 一定被 $T_{mid}$ 完全包含。因为如果不被完全包含，则 $P_{mid}$ 的值仍可以增大，如下图\n图中蓝色块通过 $T_{mid}$ 串回文的性质已知相等，每个蓝色块均可以通过自身所在回文串推出其外侧橙色块也是相等的。\n显然这种情况不会出现，因为这种情况下 $P_{mid}$ 是一个假值。 $i$ 在右侧\n没有可以继承的值则可以直接重新推，不需要过多考虑。\nif (i \u0026lt; mr) { p[i] = min(p[(mid \u0026lt;\u0026lt; 1) - i], mr - i); } else { p[i] = 1; } 更新 $P_i$ 直接从当前记录的半径向外继续枚举，直到遇到两个不相同的字符为止（边界上有 $ ^，枚举到一定会停止，所以不用考虑边界问题）。\nwhile (b[i - p[i]] == b[i + p[i]]) { ++ p[i]; } 更新 $mr$ 和 $mid$ 前文说过 $mr$ $mid$ 都是边界最靠右的回文子串的属性，那么只需要判断新找到的回文子串右边界是否大于 $mr$ 即可。\nif (i + p[i] \u0026gt; mr) { mr = i + p[i]; mid = i; } 至此 Manacher 算法主要过程结束。\n实现 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using std::cin; using std::cout; using std::endl; using std::sort; using std::string; template \u0026lt;typename T\u0026gt; T max(T a, T b) { return a\u0026gt;b?a:b; } template \u0026lt;typename T\u0026gt; T min(T a, T b) { return a\u0026lt;b?a:b; } constexpr int N = 2e7 + 514; int n; string a, b; int p[N]; // p[i] 表示以第 i 个字符为中心的最长回文子串半径 int res; void init() { b += \u0026#39;$\u0026#39;; b += \u0026#39;#\u0026#39;; for (int i = 0; i \u0026lt; n; ++i) { b += a[i]; b += \u0026#39;#\u0026#39;; } b += \u0026#39;^\u0026#39;; n=b.size(); } void manacher() { int mr = 0, mid; for (int i = 1; i \u0026lt; n; ++i) { if (i \u0026lt; mr) { p[i] = min(p[(mid\u0026lt;\u0026lt;1)-i], mr - i); } else { p[i] = 1; } while (b[i-p[i]] == b[i+p[i]]) { ++ p[i]; } if (i+p[i]\u0026gt;mr) { mr = i+p[i]; mid = i; } } } int main() { std::ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); a.reserve(N); b.reserve(N); cin \u0026gt;\u0026gt; a; n = a.size(); init(); manacher(); for (int i = 0; i \u0026lt; n; ++i) { // 最后需要枚举一遍来找出最大值 res = max(res, p[i]); } cout \u0026lt;\u0026lt; res - 1 \u0026lt;\u0026lt; endl; return 0; } 时间复杂度1 当 $P_j$ 左侧取到左边界及以外时，$P_i$ 才需要更新（其他情况都因为不满足条件而不用进循环），而右端点是单调递增且严格小于等于 $n$ 的，因此总时间复杂度为 $\\operatorname{O}(n)$\n参考谷雨的笔记\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-31T20:27:12Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-1-31-manacher/","title":"Manacher"},{"content":"顾名思义，树状数组是一种树形结构，但是因为他独特的结构和拆分方式（二进制你又来了是吧），可以直接用数组存储。\n用途是解决大部分区间修改查询问题，复杂度一般是 $\\operatorname{O}(\\log n)$ ，同时常数小（暗示线段树不行），同时码量小，好理解（暗示*2），但是复杂的区间修改查询问题不能解决，同时区间最大最小值也不能用它处理（后文会说）\n基本树状数组 原理 来自学长的一张图\n注意下文基本上所有东西都可以/需要搭配这个图进行理解\n以求区间和的树状数组为例，树中每一个节点存储一段区间的和，询问时进行前缀和加减即可得出任意区间的和。\n分区间的方法即利用二进制，对于第 $i$ 节点来说，$i$ 的二进制形式中最低一位 1 的位置为 $x$，那么 $tree_i$ 就存储了 $[i-2^x+1,i]$ 区间的和。\n注意此处 $x$ 从 0 开始算\n以 $3$ 为例，$3$ 的二进制为 0000 0011，最低一位 1 的位置是 0，则 $tree_3$ 存储 $[3-1+1,3]$ 即 $[3,3]$ 的区间和。\n再以 $8$ 为例，$8$ 的二进制为 0000 1000，最低一位 1 的位置是 3，则 $tree_8$ 存储 $[8-8+1,8]$ 即 $[1,8]$ 的区间和。\n实现 建立 实际上不用特意处理建立，直接在输入过程中每输入一个数就修改即可。\nfor (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; t1; // tmp modify(i,t1); } lowbit 本函数实现查找一个数最后一位 $1$ 的位置。\n首先声明一个冷知识（大概冷），位运算是针对内存中存储的原数据的运算，换句话说，进行位运算的是补码而不是原码。\n原码即一个数本身的二进制表示，反码即在原码的基础上符号位不变其他位取反。\n补码分类来说，正数的补码是它的原码，负数的补码为其反码$+1$。\n在这里我们只考虑最后一位 1 及它后面的 0。\n比如 0011 0100 这个二进制数，我们先把它变成负数，即按位取反后加一（易证这就是他的相反数），变为 11001011 再变为 11001100。\n发现了一件神奇的事情，原来最低一位 1 竟然回来了！\n显然，这位 1 前面的所有数字因为被取反所以和原数完全不同；后面的所有数字原来一定是 0 取反后变成一排 1，负数的补码是反码$+1$，从而一直进位到原来最后一位 1 这里，而它们本身变回了 0 ；又因为这位 1 被取反后是 0 所以无论如何都不会再向前进位。\n从而保证对于任意一个正数 $x$，$-x$ 与 $x$ 的存储只有 $x$ 本身最后一位 1 是相同的。\n因此 lowbit() 的实现就非常简单了，直接用 x\u0026amp;-x，得到的结果就是原理中所说的 $2^x$，又快又好想，用着还方便。\nint lowbit(int x) { return (x\u0026amp;-x); } 单点修改 假设修改为给第 $x$ 个数增加 $v$，那我们就需要修改所有包含第 $x$ 个元素的节点，则从第 $x$ 个节点寻找父亲节点直到根节点为止（参考上图）。\n$x$ 节点的直接父亲是 $x+\\operatorname{lowbit}(x)$，因此直接一层循环实现 $\\operatorname{O}(\\log(n))$ 修改。\nvoid modify(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) { tree[i] += v; } } 区间查询 查询区间为 $[l,r]$ 时，将问题转化为求 $[1,r] - [1,l-1]$ 的值（前缀和知识），因此我们只需要实现查询前缀和的功能即可。\n因为 $i$ 节点存储的是一段长度为 $\\operatorname{lowbit}(i)$ 的区间的和，因此取完 $i$ 号点的值后再取 $i-\\operatorname{lowbit}(i)$ 号节点的值，直到位置变为 $0$（到头）即可（看不懂就结合上面图）\nint query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) { res += tree[i]; } return res; } ans = query(r) - query(l-1); 改区间查单点 上文我们解决了求前缀和的问题，本次需要查询单点，那么很容易联想到差分。更改区间对应改差分数组上的两个点，查询单点对应查询差分数组的前缀和。\n","date":"2023-01-29T14:12:27Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-1-29-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","title":"树状数组"},{"content":"目标是解决 RMQ 问题，即对于一个大区间，短时间内查询一个小区间的最大最小值\n下文以最大值为例说明\nST 表本质上是一个动态规划（倍增的）\n先利用倍增（二进制拆分）预处理然后 $\\operatorname{O}(1)$ 查询，比线段树快，但是只支持静态区间\n原理 预处理 $f_{i,j}$ 表示从 $i$ 开始，长度为 $2^j$ 的区间中的最大值\n预处理阶段，对于 $f_{i,j}$ 来说，直接 $$ \\max{ f_{i,{j-1}},f_{i+2^{j-1},j-1} } $$ 递推即可，非常容易想，时间复杂度为 $\\operatorname{O}(n\\log n)$\n查询 对于一个区间 $[L,R]$ 来说，假设他的长度为 $len$\n很容易能找到一个 $k$ 使得 $$ \\frac{len}{2} \u0026lt; 2^k \\leqslant len $$\n显然 $[L,R]$ 被 $[L,2^k],[R-2^k-1,k]$ 严格包含，因此 ST 表中查询最大最小值的时间复杂度是常数级别的，而不是线段树的 $\\log$ 级别\n查询结果就是 $\\max {f_{L,2^k},f_{R-2^k-1k,k}}$\n至于 $k$，肉眼可见 $k=\\lfloor\\log _2 (len)\\rfloor$\n此处可以直接使用 cmath 库中的 log() 函数，它是用来求以 10 为底的对数的 根据换底公式1可知 $$k=\\lfloor\\log_2(len)\\rfloor=\\lfloor \\frac{\\lg(len)}{\\lg2} \\rfloor$$\n实现 首先是初始化\nfor (int j = 0; j \u0026lt; M; ++j) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; ++i) { if (!j) { f[i][j] = w[i]; // 从 i 开始长度为 2^0=1 的区间最大值为 i 本身 } else { f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } } } 然后是查询\nint query(int l, int r) { int len = r - l + 1; int k = log(len) / log(2); return max(f[l][k], f[r - (1 \u0026lt;\u0026lt; k) + 1][k]); } 动态修改 这个标题比较诡异，因为我提到过\n只支持静态区间\n但是实际上我们可以用一些小 trick 实现在 st 表的尾部增加值。（前提是题目要求比较少，比如目前这道题只需要在尾部增加数，同时只需要查询尾部某长度区间的最值）\n显然对于 st 表的每一个 $f_{i,j}$ 来说，他只会用到 $f_{k,j}$,$k\u0026gt;i$ 的值而不会用到前面的值，因此我们给他做一个倒转。\n换句话说，现在 $ f_{i,j} $ 表示从 $ i $ 开始，向前长度为 $ 2^j $ 的区间中的最大值。\n代码如下\nvoid add(int a) { a += t; a %= d; ori[++tail] = a; for (int j = 0; tail - (1 \u0026lt;\u0026lt; j) + 1 \u0026gt; 0; ++j) { if (!j) { f[tail][j] = a; } else { f[tail][j] = max(f[tail][j - 1], f[tail - (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } } } void query(int len) { int l = tail - len + 1; int k = log2(len); t = max(f[tail][k], f[l + (1 \u0026lt;\u0026lt; k) - 1][k]); } $ \\log_xy=\\frac{\\log_cy}{\\log_cx} $\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-27T14:22:33Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-1-28-rmq/","title":"RMQ/ST表"},{"content":"今天讲的最短路啥的感觉有点费劲，先把并查集的东西写了\n用途 基本上用来处理 关系\n什么是关系？比如一个人和他的表弟是亲戚，亲戚的关系可以人为理清， 但是毒瘤的出题人会给这个人安上 114514 个表弟这些表弟的 1919810 个其他亲戚以及 1145141919810 个其他无关的人，然后问你这个序列里面第 $a$ 个人和第 $b$ 个人是不是亲戚，一般的方法显然处理不了，而并查集就是专门用来解决这种东西用的。\n实现 “并查集”的操作就是前两个字，即合并与查询。\n此处默认以树实现并查集。\n合并 合并的操作即把两棵树的根节点连接在一起，文字解释不清楚，但是直接用树结构实现就比较清楚了。\n这里我们只需要开一个数组 $F$ 存储每一个节点的祖先，每次更改 $i$ 节点的祖先只需要修改 $F_i$ 的值\n比如目前我们有五个点\n然后由输入数据可知，1 和 3，2 和 4，5 和 4，4 和 1 是亲戚，于是我们把 1 设为 5 的祖先来表示他们的关系， 2 4 同理，相当于把这四个集合（或者说树）两两合并\n下一步\n以及把以 4 为根的这棵树合并到 1 上，连接他们的根节点\n这样我们就基本完成了这个集合的初始化，我们只需要再把根节点 1 的祖先设置为自己，来表示它是这棵树的根节点（应该在合并之前初始化每一个结点的祖先为自己，因为图可能会不太清楚所以改到这里了）\n代码实现思路就很清楚了\nvoid uni(int x, int y) { // 查询两个节点所在树的根 xx = find(u); yy = find(v); if (xx != yy) f[xx] = yy; //连接根节点 } /* ... int main() { ..... cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; // m 为人数，n 为关系数 int f[m+10], u, v; int p,q; memset(f,0,sizeof 0); for (int i = 1; i \u0026lt;= m; ++i) { f[i] = i; } ... } */ 查找 假如我们需要查找上一张图里面 2 3 是否是亲戚，如何操作呢？\n很容易发现，2 3两个节点在同一棵树中，也就是说我们可以直接查找这两个节点的根节点，如果相同则是亲戚。查找的实现也很简单，直接递归寻找上一级的父亲节点，如果一个节点的祖先是自己，就直接输出这个节点即可\n// 查询 pos 的根 int find(int pos) { if (f[pos] == pos) return pos; // 边界 return find(father[pos]); } 优化 由上文可以发现，在并查集中查找一个节点的祖先最坏情况下的时间复杂度是 $O(h)$ 的（$h$ 为树的最大深度），那么就可以通过减小最大深度来优化并查集。\n按树的大小合并 假如说我们有这样两棵树\n现在 1 5两个节点是亲戚，那么把 5 的祖先设为 1 合适还是反过来合适呢？\n显然是前者\n如果按照前者合并，结果就是\n最大深度是 3\n如果按照后者合并，最大深度为 4\n也就是说，为了让 $h$ 尽可能地小，需要把深度/体积小的树合并到深度大的树上，作为大深度/体积树的子树\n此处定义一个 $R$ 数组记录以 $i$ 为根节点的树的最大深度为 $R_i$ （$R$ 的修改在初始化/添加关系时修改）\nvoid uni(int x, int y) { int xx = find(x); int yy = find(y); if (xx == yy) return; // 在同一棵树中不需要合并 if (r[xx] \u0026gt;= r[yy]) { f[yy] = xx; r[xx] = max(r[xx],r[yy]+1); // 可能合并后 y 树深度 +1 大于 x 树最大深度 } else { f[xx] = yy; r[yy] = max(r[yy],r[xx]+1); } } 路径压缩 以上两棵树显然右侧的树更优，因为它的最大深度更小\n并查集的查询方式为“查询根节点”，这意味着我们查询时只需要关注查询最终的根节点，而不用关心查询途中经过的节点，这就是路径压缩的原理。路径压缩即把一个没有连着根的节点（如上图左侧的4 5 6 7），“跳过”所有中间节点，直接把它连到根节点上。\n对于上图来说，就是把 4 5 6 7 摘出来连接到 2 3 的父节点上，即 1，于是形成了右图，最大深度从 2 降到了 1。 由于并查集相关的题目中可能初始化之后仍然有需要增删的元素，同时路径压缩也需要耗费时间，所以我们只在查询需要的点时优化。\nint find(int x) { if (x != f[x]) { // 如果 x 不是根节点 f[x] = find(f[x]); } return f[x]; } 新的查询函数可以结合上图理解。\n","date":"2023-01-17T15:11:36Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-1-17-%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"并查集"},{"content":"图论是嗜血分支1，相应的，图论基础并没有什么太多需要思考的东西，只有一堆该死的概念等着记，有如绳之以法抽象了\n基本概念 图 由顶点（点）（Vertex）的集合和边（Edge）的集合组成，记为 $\\mathbb{G} = (\\mathbb{V}+\\mathbb{E})$\n点的集合用 $\\mathbb{V(G)}$ 表示，点用 $u,v$ 等符号表示\n顶点的数量称为图的“阶”，用 $n$ 表示\n边的集合用 $\\mathbb{E(G)}$ 表示，边用 $e$ 等符号表示\n边的个数称为图的“边数” 感觉说了和没说一样，用 $m$ 表示\n图的种类 从 $u$ 到 $v$ 的无向边： $(u,v)$\n从 $u$ 到 $v$ 的有向边：$\\langle u,v \\rangle$\n有向图：图的所有边都是有向边\n无向图：图的所有边都是无向边\n完全图：每个点都与其他所有顶点连接；对于有向图来说，任意顶点 $u,v$ 都有边 $\\langle u,v \\rangle \\langle v,u \\rangle$\n稀疏图/稠密图：边少/多的图\n平凡图：一个点的图\n零图：没有边的图\n度 对于顶点 $v$ 来说\n入度 $ID(v)$：以 $v$ 为终点的边的个数\n出度 $OD(v)$：以 $v$ 为起点的边的个数\n度 $D(v)$ = 入度 + 出度\n度为奇数的点为奇点，度为偶数的顶点为偶点\n于是可得：对于图 $\\mathbb{G}$ 中所有顶点的度=边数的两倍\n以及推论：一个图中的奇点数量为偶数\n简短证明：\n每条边一定贡献一个出度一个入度共两个度 度一定是偶数所以奇点的数量为偶数（奇$\\times$偶$=$偶） 存图 无向图可以看作有向图但是两个点之间互相有一条有向边，所以只需要考虑有向图存图\n邻接矩阵 基本思想是存两个点之间的边权（不连接即为 0 或 -1）\n比如当前图有四个点，则开数组 g[5][5]，初始化为 0。\n1 2 3 4 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4 0 0 0 0 然后 1 到 2，3 到 1 有一条有向边，边权为 1，则修改 g[1][2] g[3][1] 为 1\n1 2 3 4 1 0 1 0 0 2 0 0 0 0 3 1 0 0 0 4 0 0 0 0 非常容易理解，缺点也显而易见，如果有 114514 个点但是只有 1 条边，那就需要开 114514*114514 的空间但是只有一个位置有数据，显然造成了巨大的浪费（空间早就炸了）\n因此需要寻找一个只存边的存图方案，从而诞生邻接表\n链式前向星 用链表实现的邻接表\n先说链表，顾名思义，链状链接的列表\n开一个结构体存链的每一个元素\nstruct Node { int data; Node *nex; } 显然，把链表每一个部分连接起来的东西就是指针 nex，nex 指向当前元素的下一个元素的地址。\n当然，如果开一个数组存储所有的元素，地址可以改为存储下标，即 nex 可以是一个整数，存储下一个元素在数组里的下标。\n数学，来自 GrainRain谷神\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-15T14:05:20Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2023-1-15-basic-graph/","title":"图论基础"},{"content":"前情提要\n总览 分区大概长这样\n分区1 300M FAT16 EFI 分区2 128G ZFS ArchLinux 分区3 128G NTFS Windows 分区N **G **FS DATA // 其他分区 然后 ZFS 池里面长这样\nzroot ├─ROOT | ├─voidlinux // 实际上可以在这个池里安装多个 Linux，本处计划把所有 Linux 根分区数据集放在 zroot/ROOT/ 里 | └─archlinux └─data └─home // 存放 /home ZFS池那块看不懂没关系，只需要跟着文章做就行\n安装前 准备一个有 ZFS 支持的 archiso，这里我们提供两个方案\nCachyOS LiveCD（推荐） 从 CachyOS 的 Sourceforge 界面 下载带 GUI 的 LiveCD（它的 CLI 安装器没 ZFS 支持），然后扔进 U 盘重启进入即可\nsudo modprobe zfs # 加载 ZFS 模块 sudo su # 切换到 root 用户 timedatectl set-ntp true # 同步时间 vim /etc/pacman.d/mirrorlist # 改镜像站 # 开头添加 Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch archiso-zfs 此处使用 eoli3n 的 archiso-zfs 项目\n首先下载一个官方的 ArchLinux LiveCD，然后重启进入\n联网 iwctl # 进入 iwctl 命令行界面 下面的命令在 iwctl 中输入\ndevice list # 列出可用设备 # 假设上面列出的设备是 wlan0 station wlan0 scan station wlan0 connect SSID # 连接名为 SSID 的网络 exit 验证联网\nping www.baidu.com timedatectl set-ntp true # 同步时间 加载 ZFS 模块 curl -s https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x 如果连接 github 有问题，则运行下面的命令替代\ncurl -s https://ghproxy.com/https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x 执行过程因为网络原因会比较慢\n改镜像站 vim /etc/pacman.d/mirrorlist # 开头添加 Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch 至此，环境准备完毕，下面的操作不受 livecd 影响\n格式化 此处认为你已经分好区了，总体需要三个分区\nESP（EFI） 分区，300M，打了 ESP 标签（可以用 cfdisk 打），此处举例为 /dev/nvme0n1p1 Linux 分区（ZFS池），30+G，此处举例为 /dev/nvme0n1p2 Windows 分区（如果不需要安装 Windows 就不用建），40+G，此处举例为 /dev/nvme0n1p3 创建 ZFS 池 ashift = 12 代表 4096 字节扇区大小，9 代表 512 扇区大小，13 代表 8192 字节扇区大小，在 4096/8192 扇区大小的 SSD 上设置 9 会导致性能损失，在 512 字节扇区大小的硬盘上设置 12/13会导致容量损失，扇区大小可以通过 fdisk -l（不准）或者 diskgenius 这类工具查看\ndedup=on 为去重功能，可能会占用较大 RAM，低配机子可以把这行删掉\ncompression=zstd 为压缩功能，zstd 目前来看压缩率和性能损失比较平衡，在意性能可以改为快速压缩算法 lz4（gzip 压缩率和性能都比不上 zstd）\n其他照做即可\nzpool create -f -o ashift=12 \\ -O acltype=posixacl \\ -O relatime=on \\ -O xattr=sa \\ -O dnodesize=legacy \\ -O normalization=formD \\ -O mountpoint=none \\ -O canmount=off \\ -O devices=off \\ -O compression=zstd \\ -O dedup=on \\ -R /mnt \\ zroot /dev/nvme0n1p2 创建数据集\nzfs create -o mountpoint=none zroot/data zfs create -o mountpoint=none zroot/ROOT zfs create -o mountpoint=/ -o canmount=noauto zroot/ROOT/archlinux zfs create -o mountpoint=/home zroot/data/home 测试zpool是否能够导入导出\nzpool export zroot zpool import zroot -R /mnt 挂载zpool\nzfs mount zroot/ROOT/archlinux zfs mount -a 设置启动数据集\nzpool set bootfs=zroot/ROOT/archlinux zroot 设置zpool缓存\nzpool set cachefile=/etc/zfs/zpool.cache zroot mkdir /mnt/etc mkdir /mnt/etc/zfs cp /etc/zfs/zpool.cache /mnt/etc/zfs/zpool.cache 查看是否有挂载上\ndf -h 输出\nzroot/ROOT/archlinux 30G 128K 30G 1% /mnt 格式化 EFI 分区 注意此处挂载点不可以设置成 /boot！1\nmkfs.vfat /dev/nvme0n1p1 mkdir /mnt/efi mount /dev/nvme0n1p1 /mnt/efi 安装 这部分需要你在 /etc/pacman.conf 里添加 archzfs 源或者按照一刀斩的博客配置 CachyOS 源，此处不再赘述\n安装基本软件包 如果是 Intel 的 CPU 就把 amd-ucode 换成 intel-ucode\n此处使用 zfs-linux 包有可能会因为版本不相同然后挂掉，所以如果你添加了 CachyOS 的软件源，那么我推荐你使用 CachyOS 的自定义内核（它的内核和 zfs 模块同时编译打包，就不会出现版本不统一的问题）（最主要还是因为安装 zfs-linux 还得启用 v3 源），有多种任务调度器可选，比如 BMQ PDS TT 等，还有 LLVM LTO 编译的版本\n使用 CachyOS 内核的话直接改包即可，比如我想用 linux-cachyos-pds，那么把下面 linux linux-headers zfs-linux 换成 linux-cachyos-pds linux-cachyos-pds-headers linux-cachyos-pds-zfs 即可\n如果你不想用 CachyOS 的内核，也不想因为 zfs 模块和 linux 内核版本不统一而滚挂，那么可以使用 dkms 模块，把 zfs-linux 替换为 zfs-dkms 即可，这个的缺点是构建 dkms 模块时会风扇狂转（理论上任何内核都可以用这个当 zfs 内核模块）\npacstrap /mnt base linux-firmware linux linux-headers zfs-linux base-devel neovim os-prober amd-ucode openssh wget networkmanager zfs-utils 基础安装 # 配置 /etc/fstab genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab # 验证 /etc/fstab cat /mnt/etc/fstab # chroot 进 ArchLinux arch-chroot /mnt # 设置zpool缓存 zpool set cachefile=/etc/zfs/zpool.cache zroot # 设置时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc date # 设置语言 echo -e \u0026#34;\\nen_US.UTF-8 UTF-8\\nzh_CN.UTF-8 UTF-8\\nzh_TW.UTF-8 UTF-8\u0026#34; \u0026gt;\u0026gt; /etc/locale.gen # 应用配置 locale-gen # 设置默认语言 echo -e \u0026#34;\\nLANG=en_US.UTF-8\\n\u0026#34; \u0026gt;\u0026gt; /etc/locale.conf # 设置root密码 passwd # 添加非 root 用户 pacman -S fish # 如果不想用 fish 可以跳过这一步并把下一步的 fish 字段换成 bash useradd -m -G wheel -s /bin/fish user # user 替换为你的用户名 passwd user # 设置密码 sed -i \u0026#34;s|#%wheel ALL=(ALL) ALL|%wheel ALL=(ALL) ALL|g\u0026#34; /etc/sudoers # 添加 sudo 权限 # 添加 multilib 和 archlinuxcn 仓库 arch=\u0026#39;$arch\u0026#39; echo -e \u0026#34;\\n[multilib]\\nInclude = /etc/pacman.d/mirrorlist\\n\\n[archlinuxcn]\\nServer = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch\u0026#34; \u0026gt;\u0026gt; /etc/pacman.conf 配置内核钩子 重点部分！ 编辑 /etc/mkinitcpio.conf，直接在 HOOKS=(......) 里面加上 zfs\nnvim /etc/mkinitcpio.conf HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck) 编辑完直接借用 ArchLinux 的极为人性化的脚本生成即可\nmkinitcpio -P 设置 zfs 服务以及网络管理服务 systemctl enable zfs.target systemctl enable zfs-import-cache systemctl enable zfs-mount systemctl enable zfs-import.target systemctl enable sshd systemctl enable NetworkManager 配置 ZFSBootMenu 引导 （需要在 chroot 中完成）\n重点部分！\n详细了解可以看我之前那篇在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）\n在这里我们使用预构建好的 EFI 文件因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核\n首先下载预构建好的 ZBM efi 引导文件 （访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/）\nmkdir /efi/EFI mkdir /efi/EFI/ZBM wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi 再进行一个简单的配置\nzfs set org.zfsbootmenu:commandline=\u0026#34;rw\u0026#34; zroot/ROOT 这样就做到了启动（如果没有双启动的需求没必要进行下一步了）\n配置 rEFInd 以实现与 Windows 双启动 安装 refind\npacman -Sy refind git refind-install 这样重启之后就能双启动了\n但是你还可以美化一下，安装 nord 主题（非必要）\npacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst 结束 退出 chroot\nexit 解挂载\numount /mnt/efi zfs umount zroot/ROOT/archlinux zfs umount -a 导出 zfs 池\nzpool export zroot （导出没成功也没关系，直接重启即可） 重启\nreboot 然后你的 archlinux 就可以正常使用了\n后记 还是在年前完成了虚拟机上的测试，能够完美安装，原来写的还是有点低级错误的\nHyper-V 上安装可能会涉及到 pacman 检测不到架构之类的问题，因此启用 archlinuxcn 源需要你在 /etc/pacman.conf 改 Architecture = auto 中的 auto 为你的架构，如 x86_64 x86_64-v3\n另外不启用 CachyOS-v3 源，只启用 CachyOS 源也可以安装 CachyOS 的优化内核，但是没有 lto 版本\n以及我个人宣布，这是本博客 2022 年的最佳博文\n原因是 ZFSBootMenu 需要从 /boot 加载内核，而 ZBM 的 initramfs 启动时大概不会挂载 ESP 分区（我之前这么干寄了\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-15T19:46:43Z","image":"https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg","permalink":"https://blog.tibrella.top/post/2022-12-zfsrootarch/","title":"在启用 ZSTD 压缩的 ZFS 根分区上安装 ArchLinux 并配置 Windows 双启动"},{"content":"前言 写这篇博客的缘由挺简单的，当时 ClearArch 开发组讨论文件系统应当使用 ZFS 还是 F2FS，由于使用过 F2FS 作为根文件系统（它没有 Windows 下的驱动，透明压缩也不会提供额外的空间），同时查到企鹅大大的一篇文章，看到近 2x 的压缩率不禁心动，随后走上了 ZFS+zstd 作为根文件系统的折腾之路\n企鹅大大使用 SysLinux 引导，我在服务器尝试安装结果无法启动；看到 CachyOS 的仓库中有一个打了 ZFS+zstd 支持补丁的 grub，尝试，启动不了（后来询问了 CachyOS 的开发团队得知那个补丁是不起效果的），随后，我遇到了一个完美的解决方式（指 eoli3n 的使用 ZFSBootMenu 的安装脚本）（如果想实机全盘单系统可以直接用他的安装脚本）\n本文的目的是用 ZFSBootMenu 引导 zstd 压缩的 ZFS 文件系统根目录，同时附带双启动教程\nZFSBootMenu 介绍 官方仓库 介绍：\nZFSBootMenu 是用于 root-on-ZFS 系统的 ZFS 引导加载程序，支持快照和本机全盘加密\n其原理比较容易理解，总的来说：\n引导 ZFSBootMenu，他是一个 initramfs 映像 找到并导入所有的 ZFS 存储池，然后挂载用户选择的根数据集 用 kexec1 将系统内核、initramfs 映像加载到内存中 卸载所有 ZFS 数据集 启动最终内核 总之，它能启动以 ZFS 为根目录的 Linux，速度不慢，适用环境广，是作为本文环境下引导器的不二之选\n准备 确保你的电脑为 UEFI 启动，且已经分区完成，建立了根分区相应的子数据集\n[ -d /sys/firmware/efi] \u0026amp;\u0026amp; echo UEFI || echo BIOS 输入该命令，若输出 UEFI，则可以进行下一步，否则退出本教程。\n挂载 ESP 分区 ESP 分区一般是磁盘头部 300M 左右的 FAT16/32 分区，同时有 EFI System 标记，可以通过 fdisk -l 查看各个分区的标记\n此处挂载点绝对不可以是 /boot，一般来说有两个其他选择：/boot/efi 和 /efi，我在这里选择了 /efi\n例如我的 ESP 分区是 /dev/nvme0n1p1 则\nmkdir /mnt/efi mount /dev/nvme0n1p1 /mnt/efi 设置 ZFS Hook # 先 arch-chroot arch-chroot /mnt # 进入后编辑 /etc/mkinitcpio 加入 zfs 支持，在 HOOKS=(.......) 中加入 zfs vim /etc/mkinitcpio # 比如正常安装的 arch 修改后应该长这样，确保其中有 zfs 即可 HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck) # 编辑后加载 mkinitcpio -P 安装 ZFSBootMenu 在这里我们使用预构建好的 EFI 文件因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核\n# /efi 换成你的 ESP 挂载目录 mkdir /efi/EFI mkdir /efi/EFI/ZBM wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi # 访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/ # 配置 # 此处假设你的根目录的数据集为 zroot/ROOT/arch # 这样可以引导 zroot/ROOT 下的任意子数据集，比如 zroot/ROOT/arch 上安装 arch，zroot/ROOT/void 上安装 voidlinux，这就实现了 Linux 的双启动 zfs set org.zfsbootmenu:commandline=\u0026#34;rw\u0026#34; zroot/ROOT 配置 rEFInd rEFInd 能够每次开机都搜索 EFI 分区下的 efi 文件，这样就不用更新引导文件了，同时插启动盘的时候也不需要进 bios 里调启动顺序，rEFInd 会自动搜索到\n# 假设当前还在 chroot 里 pacman -Sy refind refind-install 非常简单，这样就实现了 Windows/macOS(HFS+) 与 Linux on ZFS 的双启动\n# 安装 nord 主题 pacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst TODO 实验并整理整个安装流程\nkexec 是 Linux 内核的一种机制，它允许从当前运行的内核启动新内核。kexec 会跳过由系统固件（BIOS 或 UEFI）执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-11-28T16:32:35Z","image":"https://pic.imgdb.cn/item/63a8671208b683016397a5d0.jpg","permalink":"https://blog.tibrella.top/post/2022-11-28-zfsbootmenu/","title":"在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）"},{"content":"闪击线段树\n基本线段树 操作 push_up() 通过子区间计算父区间的数据\nbuild() 将一段区间初始化成线段树\nmodify()\n修改单点数据 修改区间数据 (即 push_down()) query() 查询\npush_down() 修改区间数据并递归修改子区间的数据\n原理 还是用图理解\n简单来说就是把一个区间整成类似上图的完全二叉树，父节点（区间）的数据可以由子节点（区间）的数据推出（如区间最大值，区间和等），同时父节点的更改可以推到子节点里。\n可能有点抽象，但是把操作挨个解释就比较易懂了。\n存储节点 使用结构体感觉比较清晰，配上指针就能脱离中括号的束缚了\nstruct Node { int u; int v; Node *lc, *rc; int l, r, mid; int lazy; // 懒标记 void init(int L, int R) { l = L; r = R; mid = l + r \u0026gt;\u0026gt; 1; } } tr[N * 4]; 同时 mid 是需要用到的变量，我这里选择直接存在里面，同时写一个初始化函数，直接传进去区间的左右端点，非常方便。\n建立线段树 第一层区间为 $[l,r]$\n取 $mid = \\lfloor \\frac{l+r}{2} \\rfloor $\n则第二层的区间分别是 $[l,mid], [mid+1,r]$\n目前节点为 $u$，线段树数组为 $tr$，build() 函数如下\nvoid build(Node* nod, int L, int R) { nod-\u0026gt;init(L, R); // 记录区间范围 if (L == R) { // 到达叶子节点就回溯 nod-\u0026gt;v = ori[L]; nod-\u0026gt;lc = nod-\u0026gt;rc = tr; // 防止空指针，左右儿子指向第一个空节点 return; } nod-\u0026gt;lc = ++tail; // tail 是一个指向最后创建的节点的指针，这样是一个类似动态开点的操作 nod-\u0026gt;rc = ++tail; build(nod-\u0026gt;lc, L, nod-\u0026gt;mid); build(nod-\u0026gt;rc, nod-\u0026gt;mid + 1, R); push_up(nod); } 查询 以区间和为例\n设查询的区间为 $[l,r]$，目前节点区间为 $[T_l,T_r]$\n则有二种情况\n$[l,r] \\ni [T_l,T_r]$ 查询区间包含目前节点区间（因为每次查询都可能把查询区间切割开再下传，所以这种情况可视为严格包含） $[l,r]\\cap[T_l,T_r] \\neq \\varnothing$ $[l,r]\\not\\ni[T_l,T_r]$ （不存在） 把第二种情况还需要再分开成三种情况\n$[l,r] \\in [lc_l,lc_r]$ 即被左儿子区间包含 $[l,r] \\in [rc_l,rc_r]$ 即被右儿子区间包含 $l \\leqslant mid , r \u0026gt; mid$ 即左右区间都不能单独覆盖查询区间，这种情况把查询区间从 mid 劈成两半再分别在左右儿子区间查询即可。 所以只用处理相应的情况就可以了\n这里直接给出一个维护区间最大值的查询函数\nint query(Node* nod, int L, int R) { push_down(nod); if (nod-\u0026gt;r == R \u0026amp;\u0026amp; nod-\u0026gt;l == L) { // 严格覆盖 return nod-\u0026gt;v; } if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { return query(nod-\u0026gt;lc, L, R); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { return query(nod-\u0026gt;rc, L, R); } else { return query(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r) + query(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R); } } 从子节点推出父节点数据 还是以区间和为例，父区间最大值为两个子区间最大值中的最大值。\nvoid push_up(Node* nod) { nod-\u0026gt;v = nod-\u0026gt;lc-\u0026gt;v + nod-\u0026gt;rc-\u0026gt;v; } 修改区间值 理解起来其实挺简单的，比如给区间 $[L,R]$ 都加一个数 $x$，朴素写法直接用类似查询的方法递归到底部回溯的时候一个一个更新即可。\n但是显然这样做效率很低，对于长度为 $n$ 的一个区间，最坏情况下它对应 $\\log n$ 个极大区间（这些区间不存在可以合并的两个）；对于每一个极大区间来说修改它和它所有子区间的值的时间复杂度显然是他的长度，即 $\\operatorname{O}(len)$。则如上朴素写法每次修改的时间复杂度最坏为 $\\operatorname{O}(n\\log n)$，属于是飞慢了。\n优化的方式很容易想到，就是每次修改只需要保证需要用到的节点是正确的，其他节点先不管，需要用到的时候再更改。这种方式很像前端里面的一个优化“懒加载”，即一个网页如果有很多元素，一次全部加载完可能会缓慢，所以设备显示到哪里就只加载哪里的元素，看不到的元素能不加载就不加载。同样的，这种优化方式需要打标记，同时能不下放就不下放，子节点能不修改就不修改，被称为“懒标记”。\n也就是说若一个节点拥有懒标记，那么该节点的子节点们都不知道这个懒标记的存在，同时也就表明该节点的叶子节点存储的信息均不是真实信息。如果需要用到当前拥有懒标记的节点的真实信息，就需要把懒标记下放到子节点，通过懒标记更改子节点数据，然后处理子节点更改造成的数据更改即可（直接 push_up）\n假设目前要求维护区间和的同时处理区间加的操作，对于每一个节点来说，我们需要维护一个懒标记 $lazy$ ，代表“当前区间的子区间需要加一个 $lazy$ ”。\nvoid modify(Node* nod, int L, int R, int v) { // 给 [L,R] 每个数加 v if (L == nod-\u0026gt;l \u0026amp;\u0026amp; R == nod-\u0026gt;r) { // 包含了 nod-\u0026gt;lazy += v; // 该区间的每个子区间都需要加 v nod-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;l + 1) * v; // 当前区间一共有 R-L+1 个元素（因为严格包含所以 L 和 R 就是区间的左右端点） // 用不上子区间的数据，不下传懒标记直接结束 } else { push_down(nod); /* 判断三种情况 */ if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { modify(nod-\u0026gt;lc, L, R, v); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { modify(nod-\u0026gt;rc, L, R, v); } else { modify(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r, v); modify(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R, v); } push_down(nod); push_up(nod); } } void push_down(Node* nod) { if (nod-\u0026gt;lazy == 0) return; if (nod-\u0026gt;lc) nod-\u0026gt;lc-\u0026gt;lazy += nod-\u0026gt;lazy; if (nod-\u0026gt;rc) nod-\u0026gt;rc-\u0026gt;lazy += nod-\u0026gt;lazy; nod-\u0026gt;lc-\u0026gt;v += (nod-\u0026gt;mid - nod-\u0026gt;l + 1) * nod-\u0026gt;lazy; nod-\u0026gt;rc-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;mid) * nod-\u0026gt;lazy; nod-\u0026gt;lazy = 0; } 值得注意的是，加上懒标记之后，为了保证查询时访问的节点数据正确，需要在查询时添加 push_down() 操作（上文已加）。\n完整实现 区间加修改\u0026amp;求区间和\n#include \u0026lt;iostream\u0026gt; using namespace std; #define int long long #define N 1000150 struct Node { int u; int v; Node *lc, *rc; int l, r, mid; int lazy; // 懒标记 void init(int L, int R) { l = L; r = R; mid = l + r \u0026gt;\u0026gt; 1; } } tr[N * 4]; int n, m; int x, y, k; int ori[N]; char beh; int t1, t2, t3; int cnt = 1; Node* tail = tr; void push_up(Node* nod) { nod-\u0026gt;v = nod-\u0026gt;lc-\u0026gt;v + nod-\u0026gt;rc-\u0026gt;v; } void build(Node* nod, int L, int R) { nod-\u0026gt;init(L, R); if (L == R) { nod-\u0026gt;v = ori[L]; nod-\u0026gt;lc = nod-\u0026gt;rc = tr; return; } nod-\u0026gt;lc = ++tail; nod-\u0026gt;rc = ++tail; build(nod-\u0026gt;lc, L, nod-\u0026gt;mid); build(nod-\u0026gt;rc, nod-\u0026gt;mid + 1, R); push_up(nod); } void push_down(Node* nod) { if (nod-\u0026gt;lazy == 0) return; if (nod-\u0026gt;lc) nod-\u0026gt;lc-\u0026gt;lazy += nod-\u0026gt;lazy; if (nod-\u0026gt;rc) nod-\u0026gt;rc-\u0026gt;lazy += nod-\u0026gt;lazy; nod-\u0026gt;lc-\u0026gt;v += (nod-\u0026gt;mid - nod-\u0026gt;l + 1) * nod-\u0026gt;lazy; nod-\u0026gt;rc-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;mid) * nod-\u0026gt;lazy; nod-\u0026gt;lazy = 0; } void modify(Node* nod, int L, int R, int v) { if (L == nod-\u0026gt;l \u0026amp;\u0026amp; R == nod-\u0026gt;r) { nod-\u0026gt;lazy += v; nod-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;l + 1) * v; } else { push_down(nod); if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { modify(nod-\u0026gt;lc, L, R, v); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { modify(nod-\u0026gt;rc, L, R, v); } else { modify(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r, v); modify(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R, v); } push_down(nod); push_up(nod); } } int query(Node* nod, int L, int R) { push_down(nod); if (nod-\u0026gt;r == R \u0026amp;\u0026amp; nod-\u0026gt;l == L) { return nod-\u0026gt;v; } if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { return query(nod-\u0026gt;lc, L, R); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { return query(nod-\u0026gt;rc, L, R); } else { return query(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r) + query(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R); } } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; ori[i]; } build(++tail, 1, n); while (m--) { cin \u0026gt;\u0026gt; beh; if (beh == \u0026#39;1\u0026#39;) { cin \u0026gt;\u0026gt; t1 \u0026gt;\u0026gt; t2 \u0026gt;\u0026gt; t3; modify(tr + 1, t1, t2, t3); } else { cin \u0026gt;\u0026gt; t1 \u0026gt;\u0026gt; t2; cout \u0026lt;\u0026lt; query(tr + 1, t1, t2) \u0026lt;\u0026lt; endl; } } return 0; } 区间加乘同时存在 上文介绍了加法的懒标记，如果是单独乘法的懒标记也很好实现。但是如果需要同时处理加法、乘法两个区间操作该怎么办捏？\n只需要使用一下分配律即可。\n$(nod_cnod_v + nod_a) \\cdot d=d \\cdot nod_cnod_v+d \\cdot nod_a$\n$nod_c$ 即乘法懒标记， $nod_a$ 即加法懒标记，$d$ 是需要乘的数（操作数）\n","date":"2022-10-27T14:22:33Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-10-xianduanshu/","title":"线段树"},{"content":"%%% 模运算相关 首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\\leqslant r\u0026lt;m$，$q$ 就是商，$r$ 就是余数。 C++ 中模运算可能结果是负数。当 $n\u0026lt;0$ 时，模运算结果满足 $-m\u0026lt;r \\leqslant 0$。 因此可以使用\n((n%m)+m)%m 进行取余操作。\n辗转相除法 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a,b,r; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; while (a % b != 0) { r = a % b; a = b; b = r; } cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 同余 定义 $a\\bmod m = b \\bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \\equiv b \\pmod m$\n等价于 $m$ 整除 $(a-b)$，即 $m\\mid(a-b)$\n同余方程 $ax \\equiv b \\pmod m$\n已知 $a,b,n$，求解 $x$。\n当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解\n若 $x_0$ 是方程的一个解，解集即为 ${ x_0+km /\\gcd(a,m) | k\\in \\mathbf{Z} }$\n有解证明：\n对于线性同余方程 $ax \\equiv b\\pmod m$ 可以转换为 $ax+km=b,k\\in \\mathbf{Z}$\n设 $d=\\gcd(a,m)$，若方程有解为 $c$， 则 $m \\mid (ac-b)$ ，从而 $d\\mid(ac-b)$，又因为 $d\\mid a$，即 $d\\mid ac$，于是有 $d\\mid b$，即 $\\gcd(a,m)\\mid b$\n扩展欧几里得算法 前置知识 裴蜀定理 $$ \\forall a,b, \\exists x,y,ax+by=\\gcd(a,b) $$\n即 $ax\\equiv \\gcd(a,b)\\pmod b$\n用途 求解同余方程 $ax \\equiv \\gcd(a,n) \\pmod n$ $\\forall a,b,\\exists x,y,ax+by=\\gcd(a,b)$ (裴蜀定理)\n即 $ax\\equiv \\gcd(a,b) \\pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出 原理 对于方程 $ax_1+by_1=\\gcd (a,b)$，由裴蜀定理可得一定存在一组 $x_1,y_1$ 使得等式成立\n于是分两类讨论\n$b = 0$ 时，$ax_1+by_1=a$，显然 $x_1 = 1, y_1 \\in \\mathbf R$\n$b \\neq 0$ 时，利用四个未知量 $x_1,y_1,x_2,y_2$ 列出两个方程\n$$ \\begin{cases} ax_1+by_1 = \\gcd(a,b) = \\gcd(b, a\\bmod b) ① \\\\ bx_2+(a\\bmod b)y_2 = \\gcd(b, a \\bmod b) = \\gcd(a,b) = ax_1+by_1 ② \\end{cases} $$\n易得\n$$ a \\bmod b = a-\\lfloor\\frac{a}{b}\\rfloor b $$\n由此我们可以继续展开推导 $②$ 式\n$$ \\begin{aligned} bx_2+(a\\bmod b)y_2 \u0026amp;= ax_1+by_1 \\\\ bx_2+(a-\\lfloor \\dfrac{a}{b}\\rfloor b)y_2 \u0026amp;= ax_1+by_1 \\\\ ay_2+b(x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2) \u0026amp;= ax_1+by_1 \\end{aligned} $$\n$x_2,y_2$ 只是两个表示未知量的符号，所以我们可以把它们两个互换一下，得到\n$$ ax_2+b(y_2-\\lfloor \\dfrac{a}{b} \\rfloor x_2) = ax_1+by_1 $$\n因此\n$$ \\begin{cases} x_1 = x_2 \\\\ y_1 = y_2-\\lfloor \\dfrac{a}{b} \\rfloor x_2 \\end{cases} $$\n实现 算法：函数 ex_gcd(a,b) 若 b=0，ax+by=gcd(a,b) 的解是 x=1, y=0，直接返回 否则递归调用 ex_gcd(b,a%b)，求解 bx'+(a%b)y'=gcd(b,a%b) 用上一步解的 x',y'，令 x=y'，y=x'-a/b*y'，x和y就是当前方程的解 返回x,y 对于任意同余方程 $ax\\equiv b \\pmod n$，只要满足 $\\gcd(a,n)\\mid b$\n就可以先用扩欧求出 $ax\u0026rsquo;\\equiv \\gcd(a,n)\\ \\pmod n$\n即 $d=\\gcd(a,n)$，得到 $ax\u0026rsquo;(b/d)\\equiv b\\ \\pmod n$\n所以原方程一解 $x_0=x\u0026rsquo;(b/d)$，通解 $x_0+k(n/d), k\\in \\mathbf{Z}$ 代码 #include \u0026lt;algorithm\u0026gt; int ex_gcd(int u, int v, int \u0026amp;x, int \u0026amp;y) { if (!v) { x = 1, y = 0; return u; } int xx, yy; int g = ex_gcd(v, u%v, xx ,yy); x = yy; y = xx - u/v*yy; return g; } ","date":"2022-10-24T09:10:49Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-10-basic-math/","title":"初级数论"},{"content":"第一次使用 $\\LaTeX$\n01背包 朴素 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAXN 1010 using namespace std; int n, m; int v[MAXN], w[MAXN]; int f[MAXN][MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) { for (int j = 1; j \u0026lt;= m; j ++) { f[i][j] = f[i - 1][j]; if (j \u0026gt;= v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[n][m]; return 0; } 一维优化 #include \u0026lt;iostream\u0026gt; #define MAXN 1010 using namespace std; int n,m; int v[MAXN],w[MAXN]; int f[MAXN]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) { // 按照物品从头到尾枚举 for (int j = m; j \u0026gt;= v[i]; j --) { // 按照体积从最大体积到当前（第 i 个）物品枚举 f[j] = max( f[j], // 此时未更新的 f[j] 是上一次（i-1）枚举的数据，即 f[j] 是不选第 i 个物品的 f[j] f[j - v[i]] + w[i] ); } } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; return 0; } 完全背包 朴素做法 即 3 维做法\n状态表示 $f_{i,j}$ 集合：所有只考虑前 $i$ 个物品，且总体积不大于 $j$ 的所有选法 属性：$max$ （最大） 状态计算 -\u0026gt; 即集合的划分 目前我们要求 $max f_{i,j}$，不容易直接求，就采用类似 01 背包问题的“曲线救国”方法 去掉 $k$ 个第 $i$ 个物品，变为 $max f_{i-1,j}$ 去掉相应的 $k$ 个第 $i$ 个物品的空间，变为 $max f_{i-1,j-v_ik}$ 求上面的 $max$ 加回 $k$ 个第 $i$ 个物品的价值，变为 $max f_{i-1,j-v_ik} + w_ik$ int backpack() { #define MAXN 1010 using namespace std; int n,m; //! 应当定义在函数外部，原因我不说，因为没人看 int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = 0; j \u0026lt;= m; j ++) { for (int k = 0; k *v[i] \u0026lt;= j; k ++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; } 2 维优化 状态转移方程为 $f_{i,j} = max{f_{i,j}, f_{i-1,j - v_ik} + w_ik}$\n因此可得\nf[i,j] = max(f[i-1,j], f[i-1,j-v] + w, f[i-1,j-2*v] + 2*w, f[i-1,j-3*v] + 3*w, ...... ) f[i,j-v] = max( f[i-1,j-v] , f[i-1,j-2*v] + w, f[i-1,j-3*v] + 2*w, ...... ) 从我这拙劣的对齐 可以看出他们的关系捏\n也就是说 第一行 后面的一大坨\nf[i-1,j-v] + w, f[i-1,j-2*v] + 2*w, f[i-1,j-3*v] + 3*w, ...... 等价于\nf[i,j-v] + w 最终我们可以把该节第一行的状态转移方程优化为 $f_{i,j} = max(f_{i-1,j}, f_{i,j-v})$\n代码如下\nint full_backpack() { #define MAXN 1010 using namespace std; int n,m; //! 应当定义在函数外部，原因我不说，因为没人看 int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = 0; j \u0026lt;= m; j ++) { // 原做法 // for (int k = 0; k *v[i] \u0026lt;= j; k ++) // f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); f[i][j] = f[i - 1][j]; if (j \u0026gt;= v[i]) f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]); } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; } 然后强删一维，变成一维DP数组捏\nint backpack() { #define MAXN 1010 using namespace std; int n,m; //! 应当定义在函数外部，原因我不说，因为没人看 int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = v[i]; j \u0026lt;= m; j ++) { // f[i][j] = f[i - 1][j]; 恒等式直接删除 // if (j \u0026gt;= v[i]) 直接从 v[i] 开始循环就完事了 f[j] = max(f[j], f[j-v[i]] + w[i]); } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; } 多重背包 朴素 $N$ 种物品，背包容量为 $V$，第 $i$ 件物品最多能选 $C_i$ 个，每件物品占空间 $v_i$，价值为 $w_i$\n第一种容易想到的解法是把完全背包的方法拿来用，因为多重背包只是加了 $k$ 的限制\n状态转移方程即 $f_{i,j} = \\max{f_{i,j}, f_{i-1,j - C_ik} + w_ik 0} $\n考虑多重背包和完全背包的区别可以发现，多重背包虽然每种物品不只一种，但是有确定的数量，而完全背包没有数量限制，则可以轻松地在忽略时间复杂度的情况下把多重背包拆分成 01 背包，即把 $M_i$ 件第 $i$ 件物品挨个算单个物品再按照 01 背包的方式处理。\nfor (int i = 1; i \u0026lt;= n; ++ i) { for (int j = 0; j \u0026lt;= m; ++ j) { for (int k = 0; k \u0026lt;= min(c[i],j/w[i])/* 数量和体积两个都限制数量 */; ++ k) { f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); } } } 二进制优化 这种暴力方式求解比较慢，容易发现，在求解过程中，每个同种物品是按照不同种物品进行处理的，换句话说，我选第一个 a 物品与选第二个 a 物品，实际上效果都是选 1 个 a 物品，但是这样的情况在上文解法中做了两次决策，显然有一种是多余的。\n也就是说，接下来的优化方向是减少每次决策所遇到的同数量同种物品，那会联想到什么呢？\n01 背包的决策是 选 与 不选，因此称为“01”背包，而 01 能够提醒我们利用二进制表示不同的数（不管想不想到反正这就是优化方法）\n易证，使用 $2^0, 2^1, 2^2, 2^3\u0026hellip; 2^{k-1}$ 能够表示出 $0$ 到 $2^{k-1}$ 之间的所有的数，即二进制计数。也就是说，如果把物品的数量 $C_i$ 拆分成 $2^0, 2^1, 2^2\u0026hellip;2^{k-1} + p,0 \\leq p \u0026lt; 2^{k-1}$，由 $p$ 的范围可得，其中 $2^0+\u0026hellip;2^{k-1}$ 能够表示出 $[0,p]$ 的所有整数，然后也能轻松得出 $2^0+\u0026hellip;+2^{k-1}$ 选出若干与 $p$ 相加能表示出 $[p,p+2^k-1]$ 之间所有整数，两个合并即是 $[0,C_i]$\n因此可以将 $C_i$ 拆分为 $k+1$ 种新的物品，每种新物品的体积和价值分别为： $$ 2^0 \\cdot w[i],2^1 \\cdot w[i],2^2 \\cdot w[i],\u0026hellip;,2^{k-1} \\cdot w[i],p \\cdot w[i] \\\\ 2^0 \\cdot v[i],2^1 \\cdot v[i],2^2 \\cdot v[i],\u0026hellip;,2^{k-1} \\cdot v[i],p \\cdot v[i] $$ 拆分完再进行 01 背包即可。\n代码来自 GrainRain \u0026rsquo;s Blog\nconst int N = 25000; // 一共有 1000 项，每项最多拆分成 log s 项 const int M = 2010; int n, m; int v[N], w[N]; int f[N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int cnt = 0; for (int i = 1; i \u0026lt;= n; i ++) { int a, b, s; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; s; for (int k = 1; k \u0026lt;= s; k *= 2) { // 从2^0 开始枚举 2 的次幂 s -= k; v[++ cnt] = a * k; w[cnt] = b * k; } if (s \u0026gt; 0) { v[++ cnt] = a * s; w[cnt] = b * s; } } n = cnt; // 二进制拆分读入 for (int i = 1; i \u0026lt;= n; i ++) for(int j = m; j \u0026gt;= v[i]; j --) f[j] = max(f[j], f[j - v[i]] + w[i]); cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; // 01背包解题过程 分组背包 $N$ 组物品，第 $i$ 组有 $C_i$ 个物品，第 $i$ 组的第 $j$ 个物品的价值是 $w_{i,j}$，体积为 $v_{i,j}$，背包体积为 $M$，每组物品只能选择 $1$ 个\n直接枚举组时挨个枚举物品就行了。\n按照组划分阶段，第 $i$ 组不选则 $f_{i,j} = f_{i-1,j}$，第 $i$ 组选第 $k$ 个则 $f_{i,j} = f_{i-1,j-v_{i,k}} + w_{i,k}$\n这里直接给出数组删维优化过的代码\nfor (int i = 1; i \u0026lt;= n; ++ i) { for (int j = m; j \u0026gt;= m; -- j) { for (int k = 1; k \u0026lt;= c[i]; ++ k) { f[i][j] = max(f[j], f[j-v[i][k]] + w[i][k]); } } } 依赖背包 我的 Windows 盘还剩 3 个 G，新买的东方冰之勇者记占 2G,LLVM 依赖于 MSVC 生成工具，MSVC 占用 2G 磁盘，LLVM 占用 2G 磁盘，问我应该怎么安装收益最大\nreboot to archlinux!\nA 物品依赖于 B，选 B 物品之前需要先选 A 物品，问最大价值\n容易发现对于任意有依赖关系的物品 A B 来说，一共有以下三种可能的决策 （A 依赖 B）\nA B 都不选 选 B 不选 A A B 都选 因为这三种情况只会出现一个，联想分组背包的特征，将这三种情况每个看成一个组里的物品，即转化为了分组背包。\n直接 dfs 就能解决依赖关系，但是这种情况怎么看都是要涉及到树形 DP 或者图论的）\n","date":"2022-10-23T18:49:29Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-9-backpack/","title":"背包DP"},{"content":"DFS与BFS 深度优先搜索： 一棵树从一个枝向下搜索，搜到头之后回溯，继续搜下一个枝\n宽度优先搜索（Breath First Search不是Brain Fuck Scheduler）（后者已经停止维护了）： 一层一层搜到底部\n搜索方式 数据结构 空间复杂度 最短路特性 DFS stack O(h) 不具有 BFS queue O(2h) 具有1 DFS 注意回溯需要“恢复现场”\n一个例题\n#include \u0026lt;cstdio\u0026gt; const int N = 10; int n; // 层数 int path[N]; // 存储状态 bool state[N]; // 存储各个枝是否被使用 void dfs(int a) { if (a == n) { // 到达最底层 for (int i = 0; i \u0026lt; n; i ++) { printf(\u0026#34;%5d\u0026#34;,path[i]); } putchar(\u0026#39;\\n\u0026#39;); return ; } for (int i = 1; i \u0026lt;= n; i ++) { if (!state[i]) { // i没有被使用 path[a] = i; state[i] = 1; dfs(a+1); // 搜索下一层 state[i] = 0; // dfs结束之后，开始回溯，恢复现场 } } } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); dfs(0); return 0; } 在一个权值都为1的树中，使用BFS搜索到的目标点一定离起始点距离最短\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-07T21:50:20Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-8-7-oi%E7%AC%94%E8%AE%B0/","title":"搜索"},{"content":"STL vector 变长数组 需要引入头文件vector\n声明 vector\u0026lt;类型\u0026gt; 名称 多个vector组成的数组\nvector\u0026lt;类型\u0026gt; 名称[some_num] 此处的类型也可以是自定义的结构体、类\n示例\n#include\u0026lt;vector\u0026gt; vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; b[233]; 常用命令 迭代器 类似指针/数组下标之类的东西\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { vector\u0026lt;int\u0026gt; a({\u0026#34;NVIDIA\u0026#34;,\u0026#34;FUCK\u0026#34;,\u0026#34;YOU\u0026#34;,\u0026#34;EOF\u0026#34;}); std::cout \u0026lt;\u0026lt; *a.begin() \u0026lt;\u0026lt; std::endl; // a.begin() 指向 a 的第一个元素 此处相当于 a[0] std::cout \u0026lt;\u0026lt; *(a.end()-1) \u0026lt;\u0026lt; std::endl; // a.end() 指向 a 的最后一个元素的后一位，直接使用是越界访问，此处相当于 a[a.size()-1] vector\u0026lt;int\u0026gt;::iterator it = a.begin(); vector\u0026lt;int\u0026gt;::iterator it_end = a.end(); // C++11 显然使用 auto it=a.begin(); 更好写 std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 此时相当于 a[0] 与 *a.begin() // vector 的迭代器是一个随机访问迭代器，可以加减 std::cout \u0026lt;\u0026lt; *(it + 1) \u0026lt;\u0026lt; std::endl; // 相当于 a[1] std::cout \u0026lt;\u0026lt; *(it-it_end) \u0026lt;\u0026lt; std::endl; // 求两个下标之间的距离 return 0; } STL容器常用命令 sth.size(); // 返回容器 sth 的实际长度（包含的元素个数） sth.empty(); // 返回一个 bool 值，表示容器 sth 是否为空 sth.clear(); // 把容器 sth 清空 ","date":"2022-07-23T16:43:28Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-23-oi%E7%AC%94%E8%AE%B0/","title":"STL"},{"content":"类 (class) 与 结构体 (struct) #include \u0026lt;iostream\u0026gt; using namespace std; class Person { private: // Person类私有 只能在 Person 这个类里面调用 int age, height; double money; public: string name; void say() { cout \u0026lt;\u0026lt; \u0026#34;I\u0026#39;m \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } int get_age() { return age; // Person 类中可以调用由 Person 类私有的量 } void add_money(int a){ money += a; } private: // private/public 可以有多个 string books[1000]; }; // 类定义结束要加分号 int main(){ Person pinghigh(); Person persons; // 可以定义一个 Person 类的数组 pinghigh.name = \u0026#34;Tibrella\u0026#34;; // name 是公有变量，外部可以访问 // pinghigh.age = 15; //!错误， age 是私有变量，外部不可访问 pinghigh.add_money(12345); pinghigh.say(); cout \u0026lt;\u0026lt; pinghigh.get_age() \u0026lt;\u0026lt; endl; return 0; } 输出:\nI\u0026#39;m Tibrella 14 class 与 struct的异同 唯一一点不同是 class 中的量默认为 private , struct 中的量默认为 public 其他完全相同\n","date":"2022-07-19T14:34:12Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-19-oi%E7%AC%94%E8%AE%B0/","title":"类、结构体"},{"content":"String类型字符串 可变长的字符序列，需要引入头文件\u0026lt;string\u0026gt;\n赋值 #include \u0026lt;string\u0026gt; using namespace std; int main(){ string s1; // 默认空字符串 string s2 = s1; // string 类型可以互相赋值，无需 memcpy() 或 strcpy() 。 s2 是 s1 的一个副本 string s3 = \u0026#34;hiya\u0026#34;; // s3 是该字符串(\u0026#34;hiya\u0026#34;)字面值的一个副本（我也不知道是什么，总之 s3 的值是\u0026#34;hiya\u0026#34; string s4(5,\u0026#39;T\u0026#39;); // s4 的内容是“TTTTT” return 0; } 输入输出 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string s1, s2; //读入无空格字符串 cin \u0026gt;\u0026gt; s1; // scanf() fgets() 不能读入 string 类型 //读入一行 getline(cin,s2); //输出 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; /* printf() 不能直接输出string类型 需要写成 printf(\u0026#34;%s\u0026#34;,s1.c_str()) 这里 s.c_str() 作用是把 string 类型转化为字符数组 */ // 当然也可以 puts(s1.c_str()) return 0; } 后记 使用 getline(cin,str) 输入时需要注意回车符\n什么意思呢？举个例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string a,b; cin \u0026gt;\u0026gt; a; getline(cin, s); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 这时你输入\nNVIDIA FUCK U 程序会在你输入完第一行后直接输出一个NVIDIA与几个换行符 原因是cin遇到回车停止，此时getline直接把NVIDIA后的部分(空)读入然后再次遇到回车符，停止输入。\n为了避免这种情况，我们需要忽略掉一个回车符，可以使用getchar()。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string a,b; cin \u0026gt;\u0026gt; a; // NVIDIA getchar(); // \\n（跳过一个换行符） getline(cin, s); // FUCK U cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 常用操作 str.empty() 返回一个bool值。 如果string为空返回1，非空返回0。 str.size() 返回string的长度，等价于 s.length() strlen() 需要循环一遍数组，时间复杂度为O(n)。 str.size() 不需要循环，时间复杂度为O(1)。 比较 string 型之间按字典序比较直接 str1 \u0026lt; str2 即可，== != \u0026lt;= \u0026gt;= \u0026lt; \u0026gt;都支持。 相加 string 型之间相加直接 str1 += str2、str3 = str1 + str2 这样写即可。 与其他类型（字符、字符串）相加时会先把这些类型的量转化为 string 对象，可以直接加这些类型的量，如 str += 'a' 、 str1 = str2 + \u0026quot;abc\u0026quot; 相加运算时，必须保证等号两边都有 string 型，str1 = str2 + \u0026quot;hello\u0026quot; + 'a' 、 str1 += \u0026quot;hello\u0026quot; 是可以的， 但是 str1 = \u0026quot;hello\u0026quot; + 'a' 会报错。 注意运算顺序，如 string s1 = s2 + \u0026quot;abc\u0026quot; + 'd' 正确，因为会先将 s2 与 \u0026ldquo;abc\u0026rdquo; 相加得到另一个 string 对象，再继续运算。而 string s1 = \u0026quot;abc\u0026quot; + 'd' + s2 会报错，因为 \u0026ldquo;abc\u0026rdquo; 和 \u0026rsquo;d\u0026rsquo; 不能相加 （\u0026ldquo;abc\u0026quot;和\u0026quot;cde\u0026quot;也不行） 操作单个字符 可以当作字符数组处理，如 str[0] , str[3] 独特的遍历方式 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;So, NVIDIA,\u0026#34; \u0026lt;\u0026lt; endl; string s = \u0026#34;Fuck U\u0026#34;; for (char c : s) { // char c可以写作 auto c cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } return 0; } 输出： So, NVIDIA, F u c k U str.pop_back() 删除string型字符串的最后一个字符 str.substr(int i,int len) 输出字符串str从i开始长度为len的字符串 ","date":"2022-07-18T20:24:48Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-18-oi%E7%AC%94%E8%AE%B0/","title":"字符数组与字符串 2"},{"content":"字符串 输出 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main(){ char str[3]=\u0026#34;ab\u0026#34;; // 以下三种输出方式都是遇到换行或空格不停止，而是遇到\u0026#39;\\0\u0026#39;才停止 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; printf(\u0026#34;%s\\n\u0026#34;,str); puts(str); // 等价于上面的printf语句 return 0; } 读入 分两种情况 1.读入一个字符串，遇到空格/回车停止 使用cin\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ char str[3]; cin \u0026gt;\u0026gt; str; //输入 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 或使用scanf\n#include \u0026lt;cstdio\u0026gt; int main(){ char str[3]; scanf(\u0026#34;%s\u0026#34;,str); //输入 /* 这里注意一点，str 不能写作 \u0026amp;str 数组名实际上是一个指针，存储数组的第一个元素的内存地址（指向数组的第一个元素） scanf(\u0026#34;%s\u0026#34;,__) 这里下划线部分应当是一个内存地址，而整型、浮点、字符等类型变量中存储的不是地址而是它对应的内容，所以需要用‘\u0026amp;’取出它的内存地址，如取出整型（int）变量a的内存地址就是 \u0026amp;a。 而数组名本身就存储着内存地址，所以不需要再用 \u0026amp; 取一遍内存地址 */ printf(\u0026#34;%s\u0026#34;,str); return 0; } 2.读入一行内容，输入空格不停止\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main(){ char str[100]; fgets(str,100,stdin); // gets() 函数在 C11 标准中因为容易溢出而被删除，取而代之的是 fgets() /* \u0026#34;str\u0026#34;为字符串名 “100”是读入的最大字符数（一般使用数组长度即可） “stdin”应该是一个接口，不用管，照着写就行 */ cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 或\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ char str[100]; string str1; cin.getline(str,100); // 字符数组使用 cin.getline() getline(cin,str1); // string 使用 getline() cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; return 0; } 常用函数1 strlen(str) 求字符串长度（不包含\u0026rsquo;\\0\u0026rsquo;） strcmp(a,b) 比较两个字符串大小(ASCII码)， a \u0026lt; b 返回 -1 ，a == b 返回 0， a \u0026gt; b 返回 1（比较方式为字典序2） strcpy(a,b) 将字符串b赋值给从a开始的字符数组 strlen()示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s[100]=\u0026#34;abc\u0026#34;; cout \u0026lt;\u0026lt; strlen(s) \u0026lt;\u0026lt; endl; return 0; } strcmp()示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s[100]; scanf(\u0026#34;%s\u0026#34;,s); cout \u0026lt;\u0026lt; strcmp(s,\u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 此处将输入的字符串与abc进行比较\n输入 #1 bac #2 abc #3 aac 输出 #1 1 #2 0 #3 -1 strcpy示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s1[100]=\u0026#34;abc\u0026#34;,s2[100]; strcpy(s2,s1); // s1 复制到 s2 cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 输出为abc\n以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。 如\nfor (int i = 0; i \u0026lt;= strlen(str); i++) 最好改写成\nfor (int i = 0, len=strlen(str); i \u0026lt;= len; i++) \u0026#160;\u0026#x21a9;\u0026#xfe0e; 字典序：从前向后比，如2与10，比较数字则10大，按字典序比较则是2大（因为2\u0026gt;1）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-17T19:20:54Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-17-oi%E7%AC%94%E8%AE%B0/","title":"字符数组与字符串 1"},{"content":"浮点数比较要容忍误差（精度问题导致后几位出现误差）\n数组 高精度竖式算除法，试商时可以使用二分查找（非重点）\n数组初始化 #include \u0026lt;cstring\u0026gt; int main(){ int a[10]; memset(a,0,40); return 0; } 此处a为数组名，40为赋值范围（int为4byte,数组大小为10，4*10=40）\n不会把每个元素赋值为0，而是把每个字节赋值为0\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; int main(){ int a[10]; memset(a,1,40); return 0; } 此处a中每一个byte赋值为0000 0001，取出a[1]为16843009，即0000 0001 0000 0001 0000 0001 0000 0001。\n为了达到初始化数组的目的，我们也可以把它每一位赋值为1（二进制1111 1111十进制为-1）\n即\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; int main(){ int a[10]; memset(a,-1,40); return 0; } sizeof 输出一个量所占内存byte数\n用法：\nint a; sizeof a; 因此我们可以写作\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; int main(){ int a[10]; memset(a,0,sizeof a); //sizeof a等价于sizeof(a) return 0; } memcpy() #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; int main(){ int a[10],b[10]; memcpy (b,a,sizeof a); //sizeof a等价于sizeof(a) return 0; } 做题要点 1.例题\n这种题可以列表来找规律避免大脑便秘\n如下\ni 左 右 0 1 10 1 2 9 2 3 8 3 4 7 ......... i i+1 10-i 质数筛 埃氏筛 2 3 4 5 6 7 8 9 2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 //筛掉2的倍数 2 3 5 7 ~~9~~ //筛掉3的倍数 例：\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; bool b[100000005]; int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for (int i=2; i \u0026lt;= sqrt(n); i++) { // 注意枚举质数的范围 if (!b[i]){ // b[i]值为0表示i为质数 for (int j = i; j \u0026lt;= n/i; j++) { // 筛掉i的倍数 b[i*j]=1; } } } for (int i = 2; i \u0026lt;= n; i ++) { if (!b[i]){ printf(\u0026#34;%d \u0026#34;,i); } } return 0; } 11 行处为一个小优化：$i$ 的倍数从 $i^2$ 开始枚举 （考虑 $j = k\\cdot i\u0026lt;i\\cdot i$， $j$ 一定会被 $k$ 的质因数筛去）\n举个例子：筛 $2$ 的倍数时，被打标记的数字分别是\n2*2,2*3,2*4......2*n/2 那么我们筛 $i$ 的倍数时，无优化算法被打标记的数分别是\ni*2,i*3,i*4.......i*n/i 可以发现，$2i$ 和 $4i$ (即 $2\\cdot 2i$)在枚举 $2$ 的倍数时已经被打过标记了\n其他任意一个 $k\\cdot i, 2\\leqslant k\u0026lt; i$ 都同理。\n线性筛 (转载) 初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数。如果按照埃氏筛做法枚举每个质数的倍数，会造成重复筛除，影响效率。\n例如 $30=5\\times 3\\times 2$，它被 $2\\times 15$ 筛了一次，又被 $3\\times 10$ 筛了一次，为了解决这个问题，线性筛应运而生：\nint mark[MAXN]; int prime[MAXN]; //判断是否是一个素数 Mark 标记数组 index 素数个数 int Prime(int n){ int index = 0; for(int i = 2; i \u0026lt; n; i++){ //如果未标记则得到一个素数 if(mark[i] == 0) prime[++index] = i; //标记目前得到的素数的i倍为非素数 for(int j = 1; j \u0026lt;= index \u0026amp;\u0026amp; prime[j] * i \u0026lt; n; j++){ mark[i * prime[j]] = 1; if(i % prime[j] == 0) break; } } return index; } 利用了每个合数必有一个最小素因子。每个合数仅被它的最小素因子筛去正好一次。所以为线性时间。\n代码中体现在：\nif(i%prime[j]==0) break; $prime$ 数组中的素数是递增的,当 $i$ 能整除 $prime_j$，那么 $i\\cdot prime_{j+1}$ 这个合数肯定也可以被 $prime_j$ 筛掉，因为 $i$ 中含有 $prime_j$, $prime_j$ 比 $prime_{j+1}$ 小。\n接下去的素数同理，所以不用筛下去了。 在满足 $i\\ % \\ prime_j = 0$这个条件之前以及第一次满足该条件时,$prime_j$ 必定是 $prime_j\\cdot i$ 的最小因子\n版权声明：本文为lyf_018原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_41653433/article/details/88976544 ","date":"2022-07-15T11:36:49Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-15-oi%E7%AC%94%E8%AE%B0/","title":"埃氏筛 \u0026 cstring 部分函数"},{"content":"读入未知数量的数据 #include \u0026lt;stdio.h\u0026gt; int main() { int k,sum=0; while (scanf(\u0026#34;%d\u0026#34;,\u0026amp;k) != EOF) // EOF是读取结束标识 // 又因为 scanf 在读取到 EOF 会返回 -1，所以也可以写成 while (~scanf(\u0026#34;%d\u0026#34;,\u0026amp;k)) { sum += 1; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } 另外一点值得注意的是，关于使用 cin \u0026gt;\u0026gt; x 时的返回值并不是 cin 的返回值，cin 只是一个对象，而实际进行运算的是流运算符 \u0026gt;\u0026gt;。1\nWindows系统输入 2\n1 2 3 ^z GNU/Linux输入\n1 2 3 ^d 输出\n3 查到的，你问我流运算符是啥我也不知道\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n本文中^z、^d都指组合键，^d为Ctrl+D，^z为Ctrl+Z。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-14T22:01:08Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-14-read-unknown-length/","title":"读入未知数量的数据"},{"content":"最大公约数 辗转相除法求最大公约数 例：\n70 % 50 = 20 50 % 20 = 10 20 % 10 = 0 取模到0为止，此时10就是70、50最大公约数\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a,b,r; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; while (a % b != 0){ r = a % b; a = b; b = r; } cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 在实际应用中可以直接用 __gcd() 函数\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; std::__gcd(1,2); return 0; } 更相减损术求最大公约数 54 24 | 除以2（可除可不除，除后方便计算） V 27 12 27-12=15 大减小 ... ... 6-3=3 此处3=3,所以最大公约数为3\n","date":"2022-07-14T11:36:49Z","image":"http://mms1.baidu.com/it/u=1792239625,2233250434\u0026fm=253\u0026app=138\u0026f=JPEG","permalink":"https://blog.tibrella.top/post/2022-7-14-oi%E7%AC%94%E8%AE%B0/","title":"gcd 最大公约数"},{"content":"ArchLinux 添加证书（感谢Marisa） sudo trust anchor --store myCA.crt Grub 提示 /usr/share/grub/grub-mkconfig_lib: 第 237 行：printf: “$”：无效格式字符 在英文环境下 grub-mkconfig 即可\nenv LANG=en_US.UTF-8 sudo grub-mkconfig -o /boot/grub/grub.cfg gcc 编译提示 编译器内部错误：File size limit exceeded signal terminated program as 编译的时候爆内存了\n可能是你用了形如\nbool a[100000010] = {1,1}; 的语句进行初始化。\n这个语句虽然只会给你的 $a_0,a_1$ 赋值，但是在编译预处理和程序运行的过程时，它都会将数组全部展开再进行赋值/初始化\n所以还是老老实实赋值吧\nbool a[100000010]; a[0] = a[1] = 1; gcc 编译提示 relocation truncated to fit: R_X86_64_PC32 against '.bss' 静态数组爆内存了，一般的解决方法是加编译选项\ng++ test.cxx -o test -mcmodel=medium 或者\ng++ test.cxx -o test -mcmodel=large 其实换 clang++ 编译有的时候就能过 但是测评机肯定还是 gcc ，所以应该考虑下自己是不是写错数了\n","date":"2022-05-21T20:35:39Z","image":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F6cc00d86d405946f8ec851cddeb8bf71c41d3f4d.jpg\u0026refer=http%3A%2F%2Fi0.hdslb.com\u0026app=2002\u0026size=f9999,10000\u0026q=a80\u0026n=0\u0026g=0n\u0026fmt=auto?sec=1655907728\u0026t=9e015da9919ed2c610c225e51aa664a1","permalink":"https://blog.tibrella.top/post/%E9%92%9B%E5%90%88%E9%87%91%E4%BC%9E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9C%BA/","title":"钛合金伞的垃圾场"}]