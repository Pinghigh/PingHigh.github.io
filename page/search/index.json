[{"content":"前置知识 二项式反演（以后会补上笔记的！） 状压 DP 符号约定 $\\lor$ 为逻辑或，相当于 C++ 中的 | 运算符。\n题意简化 求 $n$ 的排列 $P$ 的方案数，要求 $\\lvert P_i - i \\rvert \\geqslant X$。\n分析 排列问题有点抽象，于是有套路：把一个排列看成 $n\\times n$ 的棋盘上放车的方案——数字 $p_i$ 在 $i$ 的位置上，相当于棋盘的 $(i,p_i)$ 位置放了一个车。显然 $i,p_i$ 都不会重复，所以正确。\n然后发现是个计数题，给出了不合法的条件，而且条件与位置相关，往二项式反演方向思考。\n按照套路，设 $g_i$ 为钦定 $i$ 个数不合法，其他随便排的方案数，$f_i$ 为恰好 $i$ 个数不合法的方案数。发现每个 $g_i$ 包含 $f_j,j\\in[i,n]$，然后每次选择不同的 $i$ 个数进行钦定，所以一个 $f_j$ 要算 $\\binom ji$ 次。于是有：\n$$ g_i=\\sum_{j=i}^n f_i \\binom ji $$\n脸上都写上二项式反演这五个字了，套一下式子，有：\n$$ f_i = \\sum_{j=i}^n(-1)^{j-i}\\binom ji g_j $$\n答案即为：\n$$ \\begin{aligned} ans \u0026amp;= f_0 \\ \u0026amp;= \\sum_{j=0}^n(-1)^{j-0}\\binom j0 g_j \\ \u0026amp;= \\sum_{j=0}^n(-1)^j g_j \\end{aligned} $$\n考虑怎么求 $g_i$。\n回过头来看不合法的条件：$\\lvert P_i - i \\rvert \u0026lt; X$，转化为 $P_i$ 这个棋子不能放在 $[i-X+1,i+X-1]$ 这些横行上。\n发现 $X\\leqslant 5$，非常小，也许可以状压？结合上面的转化，如果要状压的话，状态可以直接表示 $[i-X+1,i+X-1]$ 中不合法棋子的集合。\n然后 DP 状态设计就有了（这里我们开出来一个新的 $f$ 数组）：$f_{i,j,s}$ 表示棋盘前 $i$ 行，放了 $j$ 个不合法棋子，状态为 $s$ 的方案数量。\n怎么转移？假设当前是 $f_{i,j,s}$，然后分类讨论：\n不放新的不合法棋子。 发现这种情况下转移到 $i+1$ 时，新状态就是 $s$ 右移一位，即 $2^{-1}s$。 为了方便，我们设这个状态为 $ns$，表示什么都不放时转移到 $i+1$ 时的状态。 转移方程也就简单了：$f_{i,j,ns} \\gets (f_{i,j,ns}+f_{i,j,s})$ 放新的不合法棋子。 可以枚举一下这个不合法棋子能放到的位置（就是 $[i-X+1,i+X-1]$ 区间的空位），直接转移即可。但是注意，当前要做的是向后转移，所以应当枚举的是 $ns$ 这个状态的空位。假设 $p$ 是一个空位，则有转移方程：$f_{i,j,(ns\\lor 2^p)} \\gets (f_{i,j,(ns\\lor 2^p)}+f_{i,j,s})$。 对于 $g_i$，由于是钦定了 $i$ 个位置不合法，其他位置随便排，所以我们对 $f_{n,i,s}$ 枚举 $s$ 求和之后，还要乘一个 $(n-i)!$ 满足“剩下位置随便排列”的要求。\n按照前面 $ans$ 的式子求和即可。\n时间复杂度 $\\operatorname\\Theta(4^Xn^2)$。\nCode:\nuse std::io; fn valid(pos: usize, i: usize, n: usize, x: usize) -\u0026gt; bool { ((i + pos + 1 - x) \u0026lt;= n \u0026amp;\u0026amp; (i + pos + 1 - x) \u0026gt; 0) as bool } fn main() { const MD: usize = 998244353; const N: usize = 205; const ST: usize = 600; let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).unwrap(); let mut s = input.trim().split(\u0026#39; \u0026#39;); let n: usize = s.next().unwrap().parse().unwrap(); let x: usize = s.next().unwrap().parse().unwrap(); let mut f = [[[0; ST]; N]; N]; let mxst: usize = (1 \u0026lt;\u0026lt; ((x \u0026lt;\u0026lt; 1) - 2 + 1)) - 1; // 区间长度本来是 (x \u0026lt;\u0026lt; 1) - 2，但是还要包含 i 本身，所以 + 1 f[0][0][0] = 1; for i in 1..=n { for j in 0..=i - 1 { for s in 0..=mxst { let ns: usize = s \u0026gt;\u0026gt; 1; f[i][j][ns] = (f[i][j][ns] + f[i - 1][j][s]) % MD; for p in 0..=(x \u0026lt;\u0026lt; 1) - 2 { if ((1 \u0026lt;\u0026lt; p) \u0026amp; ns) == 0 \u0026amp;\u0026amp; valid(p, i, n, x) { f[i][j + 1][ns | (1 \u0026lt;\u0026lt; p)] = (f[i][j + 1][ns | (1 \u0026lt;\u0026lt; p)] + f[i - 1][j][s]) % MD } } } } } let mut fact = [0; N]; fact[0] = 1; for i in 1..=n { fact[i] = fact[i - 1] * i % MD; } let mut ans: i64 = 0; for i in 0..=n { for s in 0..=mxst { if i \u0026amp; 1 == 1 { ans -= (f[n][i][s] * fact[n - i] % MD) as i64; } else { ans += (f[n][i][s] * fact[n - i] % MD) as i64; } ans %= MD as i64; } } ans = (ans % MD as i64 + MD as i64) % MD as i64; println!(\u0026#34;{}\u0026#34;, ans); } ","date":"2023-07-19T21:06:28.13+08:00","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E9%A2%98%E8%A7%A3/abc309g/","title":"ABC309G Ban Permutation 题解"},{"content":"介绍 amd-pstate 是 AMD CPU 性能扩展驱动程序，它在 Linux 内核的现代 AMD APU 和 CPU 系列上引入了新的 CPU 频率控制机制。新机制基于协作处理器性能控制 (CPPC)，它提供比传统 ACPI 硬件 P-States 更精细的频率管理。当前的 AMD CPU/APU 平台使用 ACPI P-states 驱动程序来管理 CPU 频率和时钟，仅在 3 个 P-states 中切换。 CPPC 取代了 ACPI P-states 控件，并允许 Linux 内核使用灵活、低延迟的接口直接将性能提示传达给硬件 （摘自 Kernel Docs）\n折腾 这玩意支持 AMD ZEN 2 和更新版本，我的荣耀本使用 R7-4800H，理论上可以跑，于是按照 Aya 的博客 添加了内核参数\nzfs set org.zfsbootmenu:commandline=\u0026#34;rw amd_pstate=passive\u0026#34; zroot/ROOT 然后就没管了。\n有一天忘记从哪里又看见了 AMD P-State，然后发现一个验证方法，跑了一下：\ncat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver acpi-cpufreq 我去，这我可忍不了。于是我先检查内核 module 有没有 AMD P-State 存在，结果是没有。但是检查内核 config\nzcat /proc/config.gz | grep PSTATE CONFIG_X86_AMD_PSTATE=y 那得了，这玩意都 built-in 了咋可能不存在？于是检查日志：\njournalctl -b 0 | grep pstate 经过群友提醒，我使用翻译发现第一次设置的 passive 可能出了些幽灵字符导致无法识别，再设置一次才出现了根本问题\n得到\n_CPC object is not present in SBIOS 哈哈荣耀操你妈的，这问题不就一眼顶针了？傻逼厂商的傻逼主板又没有把 CPPC 的选项留给我自己设置捏。\ntg 群里：\n我：好像是硬件的问题，傻逼荣耀。\n群友：试试 Smokeless_UMAF？discussion 里有 CPPC 相关的东西。\n随后我想起来当时用 Smokeless_UMAF 把傻逼荣耀设置的 512M 显存干到 4G 的过程，心想这玩意也能设置？事实上，是的。\n我手上有一个现成的 ventoy 盘，于是直接拿来使用，扔进去 为 ventoy 提前制作好的 img 镜像 就能启动了。\n另外提醒一句，UMAF 基于一个漏洞，这个漏洞貌似联想在去年三月份就修复了，所以不一定能正常启动。蛤蛤，但是傻逼荣耀已经三年没更新过任何驱动了，所以我怕个吊，直接开干。\n同时，这玩意不开源，恶意代码存在可能性待议，但是利用漏洞 Hack 主板设置肯定有变砖的风险存在。因此 USE AT YOUR OWN RISK。有条件的建议备份一下 BIOS（有刷写工具的情况下），或者直接买六七个 BIOS 芯片，坏了直接换上。\n但是我电脑太冷门了，没有卖的，手上还没有刷写工具，但是保修期内，大不了送回去修，我还有机房电脑可以用。\n按照 discussion #29 的做法，进入 Device Manager - AMD CBS - NBIO - SMU page，启用 CPPC，直接一路 esc 出来，它会提醒你选择是否保存，保存后会直接重启。\n再次\ncat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver amd-pstate 就这样，没了，感谢阅读。\n","date":"2023-06-20T14:00:34.041718+08:00","image":"https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg","permalink":"https://blog.tibrella.top/notes/linux/amd-p-state-%E9%A9%B1%E5%8A%A8/","title":"AMD P-STATE 驱动相关问题"},{"content":"真的比 KMP 简单！（指好理解）\n前置知识 trie 树（必会）\nKMP（知道一点思想就行，不用详细学习）\n用途 我们知道 KMP 能够 $\\operatorname{O}(|T|+|S|)$ 匹配单个文本串 $T$ 与模式串 $S$。但是如果有 $n \\leq 10^5$ 个模式串（小串）匹配一个文本串（大串）呢？AC 自动机能够在 $\\operatorname{O}(|T|+\\sum |S|)$ 的复杂度内求出每一个模式串的出现次数。\n核心思想和 KMP 相似，除去多余的匹配，即在当前匹配状态的基础上转移着匹配。（我也不知道我说了啥）\n基本结构 多个模式串，先去重前缀，建立前缀树（即 trie 树）。 假设我们当前有四个模式串：$\\texttt{abc,ac,bc,bd}$\n对每个模式串终止字符记录其出现的次数作为其在 trie 树上对应节点的权值，然后遍历文本串的每一个字符，在 trie 树上向下走，$ans$ 加上当前点的权值，如果走不了了就把文本串的当前指针回跳到上一个有多个子节点的节点，从 trie 树根节点继续匹配。（当然这个不重要，理解不理解无所谓）（理解不了就自己匹配一下试试）\n合并了一些模式串的前缀，于是有了一定优化，但是优化还不够，考虑对后缀优化。\nfail 边 含义 AC 自动机的核心就是 fail 边。\nfail 边的含义：如果 $u$ 点的 fail 边指向 $v$，则 $v$ 点所代表的字符串1是 $u$ 点所代表的字符串的后缀，且前者是除后者自身以外满足要求的最长字符串。\n先不管怎样建 fail 边，按照要求人脑建立一下，如下图：\n然后假设有文本串 $\\texttt{abc}$，进行匹配。\n为什么上一次匹配的时候，我们需要把文本串的指针回跳？因为没有办法除去后缀的影响——一个模式串是另一个模式串的后缀，或前者的一部分是后者的后缀。意味着：后者匹配失败不代表前者也会匹配失败。于是我们可以记录一下合法后缀，如果匹配失败就跳到自己最长后缀所在节点上（没有的话就跳根节点），容易发现这样一直跳下去，能把最开始的串的合法后缀全部跳完！说明后缀的影响已经排除掉了。\n为了方便，我们把没有合法后缀的节点的 fail 边指向根节点。\n实际上此时的 fail 边的含义：无法向下一个子节点匹配（没有子节点或匹配失败）时要走的边。\n动画演示：\n建立 BFS 的过程。\n第一层（根节点为第零层）的 fail 全部指向根节点2，压入队列。\n取出队头，遍历子节点，如果子节点存在，假设这个子节点代表字符 $c$，当前节点 fail 指针指向 $lf$，$lf$ 的子节点集合为 $son$，则将其 fail 指针指向 $son_c$。\n没了。\n优化 我们一般把 trie 树的一个节点的儿子用长度为 26 的数组存下，导致遍历子节点的时候会遍历到傻逼空节点。\n对于当前节点的空子节点指针，可以直接指向当前 fail 指针指向的节点的子节点集合中，对应的子节点。\n参考代码：\nvoid build() { std::queue\u0026lt;i32\u0026gt; q; for (i32 i = 0; i \u0026lt; 26; ++i) if (trie[0].son[i]) q.push(trie[0].son[i]); while (!q.empty()) { i32 nod = q.front(), lfail = trie[q.front()].fail; // 当前节点和当前节点的 fail 节点 q.pop(); for (i32 i = 0; i \u0026lt; 26; ++i) { i32\u0026amp; to = trie[nod].son[i]; if (to) { trie[to].fail = trie[lfail].son[i]; q.push(to); } else to = trie[lfail].son[i]; // 节点为空 } } } 字典树上除根节点外的每一个节点到根的路径都代表一个字符串。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n模拟一下会发现：如果 fail 还按照正常情况定义来建的话会死循环。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-06-07T11:43:04.26+08:00","image":"https://pic.imgdb.cn/item/6481466b1ddac507cc291a6d","permalink":"https://blog.tibrella.top/notes/%E4%B8%B2/ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/","title":"AC 自动机"},{"content":"题意 给定一定数量的石子，两个人抛硬币，抛到正面则拿走一颗石子，否则什么都不做。拿走最后一颗石子的人胜利。\n已知石子数量，假设双方都采用最优方案，两个人分别抛到自己想要的那一面的概率分别为 $0.5 \\leqslant q,p \u0026lt; 1$ 这不唯物，求先手的获胜概率。\n题解 要点：对概率的熟悉程度，对 DP 的熟练程度，奇怪的缩小数据范围的方法\n首先考虑直接硬算，发现希望掷得的面会变化，没法直接算，考虑 DP。\n设计状态 表示出当前到达第几颗石子 表示出当前谁拿石子 于是得到状态：$f_{i,0/1}$ 表示 $i$ 个石子，第 $1$ 或第 $2$ 个人获胜的概率\n显然 $f_{0,0}$ 和 $f_{0,1}$ 是两种确定结果，则概率分别为 $1,0$。于是考虑倒推。\n看概率的取值，说明只要我们希望抛到一个面，抛到这个面概率就会更大。\n由于很容易判断出当前状态下应该希望取得/不取得石子（通过前一个状态的概率大小），所以不用单独表示出希望取得/不取得石子。\n状态是否可行？根据 lzp 大佬的教诲，我们需要判断该状态：\n是否能表示单独状态：显然可以，上面解释过了。 是否可递推：直觉是可以递推，但是需要列柿子看一下 转移方程 开始写柿子：\n希望取得这颗石子（正面）：\n$$ \\begin{aligned} f_{i,0} \u0026amp;= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p) \\\\ f_{i,1} \u0026amp;= f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q) \\end {aligned} $$\n发现这玩意没法递推，但是发现可以运用初中二元一次方程的思路，代入消元。\n$$ \\begin{aligned} f_{i,0} \u0026amp;= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p) \\\\ f_{i,0} \u0026amp;= f_{i-1,1} \\cdot p + (f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q))(1-p) \\\\ f_{i,0} \u0026amp;= f_{i-1,1} \\cdot p + f_{i-1,0}\\cdot (1-p)q + f_{i,0} \\cdot (1-q)(1-p) \\\\ (1-(1-q)(1-p))f_{i,0} \u0026amp;= f_{i-1,1} \\cdot p + f_{i-1,0}\\cdot (1-p)q \\\\ f_{i,0} \u0026amp;= \\frac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,0}}{1-(1-q)(1-p)} \\end{aligned} $$\n发现这玩意就可以递推了，再依照同样的方式能够列出 $f_{i,1}$ 的转移方程和不希望取得这颗石子的两个转移方程。不再赘述过程（基本上和上面完全一样），给出柿子 希望取得：\n$$ \\begin{aligned} f_{i,0} \u0026amp;= \\frac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,0}}{1-(1-q)(1-p)} \\\\ f_{i,1} \u0026amp;= \\frac {q\\cdot f_{i-1,0} + (1-q)p\\cdot f_{i-1,1}}{1-(1-p)(1-q)} \\end {aligned} $$\n不希望取得：\n$$ \\begin{aligned} f_{i,0} = \\frac{p(1-q)\\cdot f_{i-1,0} + (1-p)\\cdot f_{i-1,1}}{1-qp} \\\\ f_{i,1} = \\frac{q(1-p)\\cdot f_{i-1,1} + (1-q)\\cdot f_{i-1,0}}{1-qp} \\end{aligned} $$\n对比一下容易发现：希望取得与不希望取得的转移方程中，区别仅仅是 $p,(1-p)$ 和 $q,(1-q)$。于是，当取石子比不取石子优的时候，把 $p,q$ 把 $1$ 减一下就行了。\n于是 DP 部分解决，复杂度 $\\operatorname{O}(n)$\n优化 但是题目中 $n$ 的范围比较申必，$n \\leqslant 10^9-1$，还有多测，显然过不了。怎么办？开始考虑减少递推次数\n“自身简化专业玄 —— lzp” 矩阵快速幂之类的优化\u0026hellip;不好评价，转移方程貌似有点巨大；单调队列或者斜率？已经线性了，这种方法貌似没啥用。 概率还可以考虑是否会出现趋于稳定的情况。可以打表测一下~~（或者提交试一下）~~，试一下发现确实可以\n$n = \\min(n,100)$ 即可。 易错提示 要确定好自己选择的是正推还是逆推。（从这个状态推到下一个状态还是从上一个状态推到当前状态），换句话说，注意 $i-1,i,i+1$ 的区别。 要确定好自己递推使用的是哪一个柿子，不要写反（谁因为这个调了半天我不说 示例代码 不得不说 rust 某些方面比 C++ 严格，读入也比较麻烦，但是从另一方面来说非常人性化\u0026hellip;\nuse std::io; fn solution() { let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).unwrap(); let mut lis = input.trim().split(\u0026#39; \u0026#39;); let mut n: usize = lis.next().unwrap().parse().unwrap(); let p: f64 = lis.next().unwrap().parse().unwrap(); let q: f64 = lis.next().unwrap().parse().unwrap(); let mut f: [Vec\u0026lt;f64\u0026gt;; 2] = [Vec::new(), Vec::new()]; if n \u0026gt; 100 { // 推到第 100 个石子就够了 n = 100; } f[0].push(0.0); f[1].push(1.0); for i in 1..=n { let mut pnow = p; let mut qnow = q; if f[1][i - 1] \u0026gt; f[0][i - 1] { // 如果上一颗石子不应当让自己取 // 这里取不取等号无所谓 pnow = 1.0 - p; qnow = 1.0 - q; } f[0].push( (pnow * (1.0 - qnow) * f[0][i - 1] + (1.0 - pnow) * f[1][i - 1]) / (1.0 - pnow * qnow), ); f[1].push( (qnow * (1.0 - pnow) * f[1][i - 1] + (1.0 - qnow) * f[0][i - 1]) / (1.0 - pnow * qnow), ); } println!(\u0026#34;{}\u0026#34;, f[0][n]); } fn main() { let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).unwrap(); let mut s = input.trim().split(\u0026#39; \u0026#39;); let mut t: i32 = s.next().unwrap().parse().unwrap(); while t != 0 { solution(); t -= 1; } } ","date":"2023-05-30T17:25:03.57+08:00","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E9%A2%98%E8%A7%A3/spoj-4060-%E9%A2%98%E8%A7%A3/","title":"SPOJ 4060 题解"},{"content":"P4562 [JXOI2018]游戏 给定区间 $[l,r]$，每次选择一个未选择过的数，将这个数以及它的所有倍数标记，每一种方案全部标记所用次数记为 $t$，求所有可能 $t$ 的和。\n首先想到每次将所有点标记的实质，就是将 $\\left[l,r\\right]$ 中没有在此区间内的非自身的因数的数标记完。称这样的数为关键数，设关键数有 $k$ 个，则实际上标记次数就是最后一个关键数的位置。\n最后一个关键数的位置\u0026hellip;不沾头不沾尾，所以换个方向考虑——最后一个关键数的位置可以替换为它后面的非关键数的数量。\n实际上，$k$ 个关键数把整个区间分成了 $k+1$ 份。设区间长度为 $1$，则一个非关键数在最后一段区间上的期望就是 $\\cfrac 1 {k+1}$（$k+1$ 种情况，每种情况都在段区间上，只有一种情况在目标区间上），$n-k$ 个非关键点在最后一段区间上的期望就是 $\\cfrac{n-k}{k+1}$。（注意这里概率到期望的转换，要想想为什么期望成了求解目标）\n于是，最后一个点的位置的期望，即 $t$ 的期望为下式\n$$ \\begin{aligned} \u0026amp;\\ \\ \\ \\ \\ n-\\cfrac{n-k}{k+1} \\\\ \u0026amp;= \\cfrac{nk+n-n+k}{k+1} \\\\ \u0026amp;= \\cfrac{(n+1)k}{k+1} \\end{aligned} $$\n求所有可能的 $t$ 的值的和，乘一个阶乘就好了。\n$$ \\begin{aligned} \u0026amp;\\ \\ \\ \\ \\ \\cfrac{(n+1)k}{k+1}n! \\\\ \u0026amp;= \\cfrac{k}{k+1}(n+1)! \\end{aligned} $$\n取模的话，求完阶乘 $\\times k$ 再乘个 逆元 就行了。\nP4284 [SHOI2014] 概率充电器 给定一棵树，每条边能导电的概率为 $p_i$，每个点自己带电的概率为 $q_i$，求带电点个数的期望。\n根据期望的线性性，考虑求每个点有电的期望。因为只有 $0,1$ 两种情况，因此求概率就行了。\n考虑单个点有电的情况：\n自己有电 儿子有电，和儿子连边导电 父亲有电，和父亲连边导电 设 $f_u$ 为点 $u$ 带电的期望：\n第一种情况的概率就是 $q_u$，所以直接 $f_u = q_u$ 就行。 第二种情况非常像树形 DP 的样子，容易想到从叶子节点向上推就行。 考虑两个独立事件发生其中一件即可的概率： $P(A+B)=P(A)+(1-P(A))P(B)$，即 $A$ 事件的概率 $+$ $(B$ 事件 $+$ $A$ 事件未发生 $)$ 的概率。 进行 dfs，回溯的时候统计： 设当前点为 $u$，儿子为 $v$，则有 $f_u = f_u + (1-f_u)p_{u,v}f_v$ 第三种情况实际上也是树形 DP，只不过变成了正推，从 $u$ 计算对 $v$ 的贡献。 假设当前到达 $u$，且 $f_u$ 已经算好了，考虑如何把贡献传给 $f_v$。 容易想到 $u$ 能贡献给 $v$ 电流的那部分概率，实际上是 $f_u$ 扔掉 $v$ 这棵子树的部分。 换句话说，贡献 $=$ $u$ 有电的概率 $-$ $u$ 不考虑 $v$ 的有电的概率，再乘边的概率之类的常数即可。 设 $\\langle u,v \\rangle=e$，$u$ 不考虑 $v$ 的有电的概率为 $g_u$，$v$ 只考虑下方来电有电的概率为 $l_v$，有柿子： $$ \\begin{aligned} f_u \u0026amp;= g_u + l_vp_e(1-g_u) \\\\ f_u \u0026amp;= g_u + l_vp_e-l_vp_eg_u \\\\ f_u - l_vp_e \u0026amp;= g_u(1-l_vp_e) \\\\ g_u \u0026amp;= \\cfrac {f_u-l_vp_e}{1-l_vp_e} \\\\ f_u - g_u \u0026amp;= f_u - \\cfrac {f_u-l_vp_e}{1-l_vp_e} \\end{aligned} $$ 考虑完 $u$ 有电的贡献，乘一下边的概率和 $v$ 没电的概率就行了 $$ f_v = f_v + (1-f_v)\\cdot p_e \\cdot(f_u - \\cfrac {f_u-l_vp_e}{1-l_vp_e}) $$ 柿子推完了，写两个 dfs 算答案即可。\nSPOJ 4060 KPGAME - A game with probability 给定一定数量的石子，两个人抛硬币，抛到正面则拿走一颗石子，否则什么都不做。拿走最后一颗石子的人胜利。\n已知石子数量，假设双方都采用最优方案，两个人分别抛到自己想要的那一面的概率 $q,p \\geqslant 0.5$ 这不唯物，求先手的获胜概率。\n练习推式子的能力。\n发现对于每一颗石子都能独立计算，考虑 DP。\n设计状态：\n表示出当前到达第几颗石子 表示出当前谁拿石子 于是得到状态：$f_{i,0/1}$ 表示 $i$ 个石子，第 $1$ 或第 $2$ 个人获胜的概率 显然 $f_{0,0}$ 和 $f_{0,1}$ 是两种确定结果，则概率分别为 $1,0$ 。于是考虑倒推。\n看概率的取值，说明只要我们希望抛到一个面，抛到这个面概率就会更大。\n由于很容易判断出当前状态下应该希望取得/不取得石子（通过前一个状态的概率大小），所以不用单独表示出希望取得/不取得石子。\n列式子： 希望取得这颗石子（正面）：\n$$ \\begin{aligned} f_{i,0} \u0026amp;= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p) \\\\ f_{i,1} \u0026amp;= f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q) \\end {aligned} $$\n发现这玩意没法递推，运用初中二元一次方程的思路，代入消元。\n$$ \\begin{aligned} f_{i,0} \u0026amp;= f_{i-1,1}\\cdot p + f_{i,1} \\cdot (1-p) \\\\ f_{i,0} \u0026amp;= f_{i-1,1} \\cdot p + (f_{i-1,0}\\cdot q + f_{i,0} \\cdot (1-q))(1-p) \\\\ \\dots \\\\ f_{i,0} \u0026amp;= \\cfrac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,1}}{1-(1-q)(1-p)} \\end{aligned} $$\n发现这玩意就可以递推了，再依照同样的方式能够列出 $f_{i,1}$ 的转移方程和不希望取得这颗石子的两个转移方程。不写过程了，给出柿子 希望取得：\n$$ \\begin{aligned} f_{i,0} \u0026amp;= \\cfrac {p\\cdot f_{i-1,1} + (1-p)q\\cdot f_{i-1,1}}{1-(1-q)(1-p)} \\\\ f_{i,1} \u0026amp;= \\cfrac {q\\cdot f_{i-1,0} + (1-q)p\\cdot f_{i-1,0}}{1-(1-p)(1-q)} \\end {aligned} $$\n不希望取得：\n$$ \\begin{aligned} f_{i,0} = \\cfrac{p(1-q)\\cdot f_{i-1,0} + (1-p)\\cdot f_{i-1,1}}{1-qp} \\\\ f_{i,1} = \\cfrac{q(1-p)\\cdot f_{i-1,1} + (1-q)\\cdot f_{i-1,0}}{1-qp} \\end{aligned} $$\n对比一下容易发现：希望取得与不希望取得的转移方程中，区别仅仅是 $p,(1-p)$ 和 $q,(1-q)$。于是，当取石子比不取石子优的时候，把 $p,q$ 把 $1$ 减一下就行了。\n但是题目中 $n$ 的范围比较申必，$n \\leqslant 1e9-1$，这东西怎么办？对于概率题，我们常有两种思路：\n矩阵快速幂：\u0026hellip;不好评价，转移方程貌似有点巨大 概率变化逐渐趋于稳定。可以打表测一下~~（或者提交试一下）~~，我试出来 100 次左右就能过 $n = \\min(n,100)$ 即可。 ","date":"2023-05-22T21:06:14.29+08:00","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E9%A2%98%E8%A7%A3/%E6%A6%82%E7%8E%87%E6%9D%82%E9%A2%98/","title":"概率杂题"},{"content":"什么是最大流问题 总体是一张有向图，定一个源点，一个汇点。单位时间内源点能流出无限水，汇点能接受无限水。图中每条边相当于一个单位时间流量有限的管道。\n最大流问题：单位时间内汇点最多能接收到多少水流？\n解法 考虑贪心去做：反复 dfs 找到仍能流水的一条从源点到汇点的路径，路径中每个边的容量减去路径的最小容量（水管模型能流多少显然受最小容量限制吧\u0026hellip;）。\n但是好像不太对，有可能当前的一个流让它从另一个路径流出去更合适，借鉴反悔贪心的思想，我们可以给每条边加一条反向边。当一条边的容量被占据了 $f$ 时，其容量减去 $f$，然后给它的反向边加上 $f$。\n上面只是简单介绍了一下增广路的主要思想，下面是三种具体的求法。\nOI 中网络流貌似不需要去管他的复杂度之类，尤其是最大流，卡 Dinic 的题可能只有 HLPP 模板题那一道。\n主要是感性理解，重点都在建模。\nEK 不会，上界 $\\operatorname{O}(nm^2)$，懒得学了\nDinic 推荐结合这个博客看：https://www.cnblogs.com/SYCstudio/p/7260613.html\n继续上面的贪心想法\n每一次 dfs 可能得遍历整张图，只找到 1 条增广路，感觉不太值。\n考虑多路增广。\ndfs 每次传入两个参数：当前点编号和流过来了多少流量\n原来的 dfs 过程：\n判断当前是否到达汇点，如果到达汇点，返回当前流量。 否则枚举有流量的边，继续 dfs。 dfs 如果返回正数，说明找到一条增广路，返回。 我们实际上可以在第 3 步找到增广路时不立即停止，而是将当前流量减去 dfs 返回的流量，表示有这么多的水已经流出去了。然后继续枚举边，枚举完毕/当前流量减到 0 则停止。\n貌似会死循环，我们可以用 bfs 分层。每次 bfs 从源点开始，只走有流量的边，一个点的深度为到源点的最短距离。如果图不连通，说明找不到增广路了。\n如果图连通，则反复 dfs。向下一个点搜索的前提是下一个点的深度 -1 等于当前点深度。\n然后加一个当前弧优化：dfs 可能反复到达同一个点，而这个点的某些边可能已经被增广过了。因此在第一次到达该点的过程中，可以把链式前向星的 fir[nod] 修改为当前增广过但是还可能继续增广的边——之前的边增广过，流量没跑完，说明走那条边已经找不到增广路了。\n每次分层情况都不一样，所以开一个 cur 数组当 fir 数组用，每次分层将 cur 数组的每个值都初始化成原 fir 数组的值。\n示例代码：\nstruct edge { i64 u, v; edge *nex, *opp; i64 w; } graph[M]; edge* tot = graph; edge *fir[N], *cur[N]; i64 depth[N]; i64 n, m, s, t; // 点数，边数，源点，汇点 queue\u0026lt;i64\u0026gt; q; void add(i64 a, i64 b, i64 c) { ++tot; tot-\u0026gt;u = a; tot-\u0026gt;v = b; tot-\u0026gt;w = c; tot-\u0026gt;opp = tot + 1; tot-\u0026gt;nex = fir[a]; fir[a] = tot; // 反向边 ++tot; tot-\u0026gt;u = b; tot-\u0026gt;v = a; tot-\u0026gt;w = 0; tot-\u0026gt;opp = tot - 1; tot-\u0026gt;nex = fir[b]; fir[b] = tot; }; bool bfs() { while (q.size()) q.pop(); // memset(depth, 0, sizeof depth); cur[s] = fir[s]; for (int i = 1; i \u0026lt;= n; ++i) depth[i] = 0; depth[s] = 1; q.push(s); while (q.size()) { i64 idx = q.front(); q.pop(); for (edge* e = fir[idx]; e; e = e-\u0026gt;nex) { if (e-\u0026gt;w \u0026gt; 0 \u0026amp;\u0026amp; !depth[e-\u0026gt;v]) { // 该边容量大于零且还没有被设置深度 depth[e-\u0026gt;v] = depth[idx] + 1; q.push(e-\u0026gt;v); cur[e-\u0026gt;v] = fir[e-\u0026gt;v]; // 当前弧优化 } } } if (!depth[t]) return false; return true; } i64 dfs(i64 nod, i64 val) { if (nod == t) return val; // 边界即到达汇点 i64 res = 0; for (edge* e = cur[nod]; e \u0026amp;\u0026amp; val; e = e-\u0026gt;nex) { cur[nod] = e; if (depth[nod] + 1 == depth[e-\u0026gt;v] \u0026amp;\u0026amp; e-\u0026gt;w) { // 第一个条件判断分层图，第二个条件判断边的残量 i64 tmp = dfs(e-\u0026gt;v, min(val, e-\u0026gt;w)); if (tmp \u0026gt; 0) { // 找到增广路 e-\u0026gt;w -= tmp; e-\u0026gt;opp-\u0026gt;w += tmp; res += tmp; val -= tmp; // return res; } else if (!tmp) depth[e-\u0026gt;v] = -1; } } return res; } i64 dinic() { i64 res = 0; i64 d = 0; while () { while (d = dfs(s, (i64)LLONG_MAX)) { res += d; } } return res; } ISAP TODO\n","date":"2023-05-20T17:23:16Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E5%A2%9E%E5%B9%BF%E8%B7%AF%E6%9C%80%E5%A4%A7%E6%B5%81/","title":"最大流要点"},{"content":"飞快的可并堆\n时间复杂度 还没有完全严格的证明，但一般认为配对堆时间复杂度如下：\n删除堆顶均摊 $\\operatorname{O}(\\log n)$\n插入元素 $\\operatorname{O}(1)$ 合并 $\\operatorname{O}(1)$\n貌似这个可能比斐波那契堆快（\n节点存储 配对堆不是一个二叉树，一般采用“左儿子右兄弟”表示法，一个节点存储自己第一个儿子与右侧第一个兄弟。\n有点抽象？实际上相当于每一个节点的儿子使用链表维护，然后该节点连着第一个子节点。\n代码就非常好写了\nstruct Node { int val; Node *child, *nex; // 第一个儿子，下一个兄弟 }; 合并两个堆 比较根节点大小，把根节点大的堆直接改成根节点小的堆根节点的儿子即可。\n图示中还是使用树本身形态。\nNode* meld(Node* x, Node* y) { // 传入两个根节点 if (x == null) // null 为空节点 return y; else if (y == null) return x; if (x-\u0026gt;val \u0026lt; y-\u0026gt;val) { // x 比 y 小，y 当 x 的儿子 y-\u0026gt;nex = x-\u0026gt;child; // 旧儿子是新儿子的兄弟 x-\u0026gt;child = y; // 新儿子是第一个儿子 return x; } else { x-\u0026gt;nex = y-\u0026gt;child; y-\u0026gt;child = x; return y; } } 插入新节点 新建节点，然后当成两个堆合并即可。\nvoid push(int x) { Node* y = new_node(); // 获取新节点 y-\u0026gt;val = x; if (root == null) // 当前堆为空的话，新节点为根 root = y; else root = meld(root, y); // 否则当成两个堆合并 } 弹出堆顶 貌似要写完了，但是前面几个操作都没有对堆的性质进行维护，因此重头戏在这个部分\u0026hellip;\n删除根节点之后，遇到的是原来的子节点们组成的森林，想办法把它们合并到一起。\n有了上面的合并操作，很容易想到将这些森林里的树一棵一棵合并的方法，但是这样时间复杂度就奔 $\\operatorname{O}(n)$ 去了，因为每次删除根节点都只是单纯地把子节点比较一遍，非常缓慢。\n于是说到了该数据结构名称的由来——“配对”。\n我们把这个森林两两配对之后再合并成一个新堆，于是理想状态下，多次删除根结点，新根节点的子节点数量将为 $2$，均摊时间复杂度大约是 $\\operatorname{O}(\\log n)$ 的。\n图示过程：\n首先实现一个用于配对的函数。\nNode* merges(Node* x) { if (x \u0026lt;mark\u0026gt; null || x-\u0026gt;nex \u0026lt;/mark\u0026gt; null) return x; // x 为空或者 x 没有下一个兄弟节点 Node* y = x-\u0026gt;nex; // y 是 x 的下一个兄弟 Node* c = y-\u0026gt;nex; // c 是再下一个兄弟 x-\u0026gt;nex = y-\u0026gt;nex = null; // 拆散 return meld(merges(c), meld(x, y)); // x 与 y 配对在一起，剩下的继续配对 } 然后弹出堆顶的操作就很好写了。\nvoid pop() { Node* t = merges(root-\u0026gt;child); remove(root); root = t; } 模板 using i64 = long long; #define __SIZ 2000006 struct Node { i64 val; Node *child, *nex; } tree[__SIZ], *rubbish_bin[__SIZ]; // 提早分配内存，new 太慢了 Node *null = tree, *tot = tree; i64 bintop; class pairing_heap { Node* root; Node* new_node() { Node* nod; if (bintop) nod = rubbish_bin[bintop--]; // 垃圾回收 else nod = ++tot; nod-\u0026gt;child = null; nod-\u0026gt;nex = null; return nod; } void remove(Node* x) { rubbish_bin[++bintop] = x; } Node* meld(Node* x, Node* y) { // 合并两个堆 if (x == null) return y; else if (y == null) return x; if (x-\u0026gt;val \u0026lt; y-\u0026gt;val) { y-\u0026gt;nex = x-\u0026gt;child; x-\u0026gt;child = y; return x; } else { x-\u0026gt;nex = y-\u0026gt;child; y-\u0026gt;child = x; return y; } } Node* merges(Node* x) { if (x \u0026lt;mark\u0026gt; null || x-\u0026gt;nex \u0026lt;/mark\u0026gt; null) return x; // x 为空或者 x 没有下一个兄弟节点 Node* y = x-\u0026gt;nex; // y 是 x 的下一个兄弟 Node* c = y-\u0026gt;nex; // c 是下一个兄弟 x-\u0026gt;nex = y-\u0026gt;nex = null; // 拆散 return meld(merges(c), meld(x, y)); // x 与 y 配对在一起，剩下的继续配对 } public: pairing_heap() { root = null; } void push(i64 x) { Node* y = new_node(); y-\u0026gt;val = x; if (root == null) root = y; else root = meld(root, y); } i64 top() { return root-\u0026gt;val; } void pop() { Node* t = merges(root-\u0026gt;child); remove(root); root = t; } } q; ","date":"2023-05-20T19:42:35+08:00","image":"https://pic1.imgdb.cn/item/64688db3e03e90d874e6d98a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%85%8D%E5%AF%B9%E5%A0%86/","title":"配对堆"},{"content":"长期坑，一点点来吧\u0026hellip;\n为什么要使用 Arch Linux 众所周知，Ubuntu 是目前使用基本上最广的 Linux 操作系统，同时国内 UOS、优麒麟此类都是 Ubuntu 魔改，那为什么不用它呢？\n实际上，用的人多不代表他多牛逼，Windows 用的人也非常多，但是不可否认的是它很烂。Ubuntu/Debian 系的 Linux 发行版实际上正在脱离 Linux 大部分发行版的“包管理器”的独特优势，在向着复杂和难以维护发展，这使我在 Linux 使用的初期碰了很多次壁。\n那 RedHat 系呢？Fedora 不也很好吗？它确实很好，但是我认为 Arch Linux 更加符合 \u0026ldquo;KISS\u0026rdquo; 的哲学，它更加简单，更加容易理解，更加友好。虽然它需要相对繁琐的命令行安装，但是它的稳定性要比大多数滚动更新发行版好，也比大多数桌面发行版容易维护。\n总之，如上，Arch Linux 易于维护，稳定性好，扩展性强，生态好，社区非常完善（可以说是拥有最完善的社区和维基），我认为它是非常适合用于 Linux 入门的发行版。\n制作安装盘 需要你手里有一个 U 盘。 不需要 U 盘的安装方法有点困难，如果你不是新手请换一篇博客看\u0026hellip;.\n","date":"2023-05-13T20:42:41Z","image":"https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg","permalink":"https://blog.tibrella.top/notes/linux/%E9%9D%A2%E5%90%91%E6%96%B0%E6%89%8B%E7%9A%84-arch-linux-%E4%BD%9C%E4%B8%BA%E7%AC%AC%E4%BA%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"面向新手的 Arch Linux 作为第二系统的安装指南"},{"content":"向量 类比一维数组 —— zzz\n分为行向量与列向量。\n行向量形如 $\\left[ 1,2,3 \\right]$\n列向量形如 $\\left[ \\begin{array} \\\\ 1 \\\\ 2\\\\ 3\\\\ 4 \\end{array} \\right]$\n实际上高中 whk 里面的向量是二维向量，OI 中用的向量大部分为多维向量，数组中每一个元素就是一维的坐标。\n运算的前提很容易想到：同维度，也就是“数组”长度得一样长。\n加法：分量分别相加 $[a,b,c]+[a,b,c]=[2a,2b,2c]$\n减法：加法逆运算。\n数乘：把系数乘到分量上 $3[a,b,c]=[3a,3b,3c]$\n数量积（内积/点乘）：分量分别相乘并相加，顾名思义，得到一个数值 $[a,b] \\cdot [c,d] = ac+bd$\n向量积（外积/叉乘）：实际上没卵用，所以我不会\n线性基 线性代数中的定义：$\\mathbf V$ 中的极小线性无关向量集合 ${\\mathbf a,\\mathbf b,\\mathbf c\\dots }$ 能够表示出 $\\mathbf V$ 中所有向量。\n在 OI 中使用的线性基与上面定义略有不同：\n异或意义上的线性基 给定一数列 $a$，其线性基 $s$ 是满足以下性质的数列：\n$a$ 中任意一个数都可以用 $s$ 中的数异或得到 $s$ 中任意一些数异或和不为 $0$ $s$ 里面的数个数一定，并且在满足性质 $1$ 的条件下数最少 如果还是不能理解，别忘了线性基不一定是原数列的子集。 ","date":"2023-05-02T00:00:00Z","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/","title":"线性代数"},{"content":"基本概念 事件运算 $A+B:=A\\cup B$ ，相当于或运算\n$AB:=A\\cap B$ ，同时发生\n条件概率 条件概率：$A$ 发生的前提下 $B$ 发生的概率，表示为 $P(B\\mid A):=\\cfrac{P(AB)}{P(A)}$\n全概率公式：$B$ 依赖于一堆事件 $A_1\\dots A_n$ 的其中一个，则 $P(B)=\\sum^n_{i=1} P(A_i)P(B\\mid A_i)$\n贝叶斯公式：$P(A\\mid B) = \\cfrac{P(B\\mid A)P(A)}{P(B)}$ 实际上就是一个条件概率的推导 $$ \\begin{aligned} \\frac{P(B\\mid A)P(A)}{P(B)} \u0026amp;= \\cfrac{\\cfrac{P(AB)}{P(A)} P(A)}{P(B)} \\\\ \u0026amp;= \\frac{P(AB)}{P(B)} \\\\ \u0026amp;= P(A\\mid B) \\end{aligned} $$\n若 $P(AB) = P(A)P(B)$ 则 $A,B$ 互为独立事件，于是 $P(B\\mid A) = P(B)$\n随机变量 只介绍离散型随机变量。\n离散型随机变量 $X$，可以理解为 $X$ 有有限种取值，且每个取值都有一个概率。换句话说，$X$ 的取值是一个有限的集合，集合里面每一个值都有一个概率，$X$ 按照概率取值。\n随机变量独立性：对于两个独立变量 $X Y$，有 $P(X=x_i, Y=y_i) = P(X=x_i)P(Y=y_i)$ （$,$ 表示且） 倒过来也是正确的。\n期望 一个随机变量取值对概率的加权平均数。\n$E(X) = \\sum_i x_ip_i$，$x_i$ 代表可能的取值，$p_i$ 代表取值对应的概率。\n期望的线性性：$E(aX+b)=aE(X)+b$\n我们可以设 $X$ 的意义为均匀骰子可能掷出的点数，于是上面的东西就可以轻松感性理解了~\n随机独立变量的乘积：$E(XY)=E(X)E(Y)$\n条件期望 $Y = y$ 的条件下 $X$ 的期望：$E(X\\mid Y = y)$\n$E(X\\mid Y)$ ：取值与 $Y$ 相关的随机变量\n","date":"2023-04-30T23:51:12Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/","title":"概率论基础"},{"content":"基础排列组合 实际上主要还是组合\n常用记号 $n \\in \\mathbb N,n!:= 1\\times 2\\times 3\\times \\dots \\times (n-1) \\times n$ 称为非负整数 $n$ 的阶乘，特殊地，$0! =1$。 $n,m\\in \\mathbb N,n\\geqslant m, \\binom{n}{m}=\\frac{n!}{m!(n-m)!} \\text{ a.k.a } C^m_n$ 表示 $n$ 个数中无序地选 $m$ 个数的方案数。 $n,m\\in \\mathbb N,n\\geqslant m, {n \\brack m} \\text{ a.k.a } s(n,m),s_u(n,m)$ 称作第一类无符号斯特林数，表示 $n$ 个数中排成 $m$ 个圆排列的方案数不知道什么是圆排列 $n,m\\in \\mathbb N,n\\geqslant m, {n \\brace m} \\text{ a.k.a } S(n,m)$ 称作第二类斯特林数，即 $n$ 个两两不同的数分成 $m$ 个互不区分的非空集合的方案数 预处理组合数 递推法 组合数递推：$\\tbinom{n}{m} = \\tbinom{n-1}{m-1} + \\tbinom{n-1}{m}$\n证明：对于还需要选 $j$ 个，还剩 $i$ 个没选的情况，则对于一个苹果来说，不选它的方案数为 $\\tbinom{i-1}{j}$，选它的方案数为 $\\tbinom{i-1}{j-1}$。\n阶乘法 问题：给定 $p$ 与多组 $a,b$ ，求 $\\tbinom{a}{b} \\bmod p$。\n设 $fact_i = i! \\bmod p,infact_i = fact_i^{-1}\\pmod p$，根据逆元的性质可得\n$$ \\begin{aligned} \\binom{a}{b} \u0026amp;= \\frac{a!}{b!(a-b)!}\\\\ \u0026amp;= \\frac{form_a \\cdot inform_b}{(a-b)!}\\\\ \u0026amp;= form_a \\cdot inform_b \\cdot inform_{a-b} \\end{aligned} $$\n二项式定理 二项式就是只有两个项的多项式，如 $a+b$\n二项式定理如下：\n$$ (x+y)^n = \\sum^n_{k=0} \\binom nk x^{n-k}y^k $$\n可以利用组合方法证明：\n假设有 $n$ 个 $(x+y)$ 相乘，由多项式乘法的法则可以知道，对于 $x^ky^{n-k}$ 这一项来说（容易想到 $x,y$ 的指数和为 $n$），它来自于 $n$ 个括号中的 $k$ 个 $x$ 与剩下 $n-k$ 个括号中的 $n-k$ 个 $y$，也就是说“$n$ 个括号中选 $k$ 个 $x$ 的方案数”就是该项的系数，即 $\\binom nk$。\n卢卡斯定理 下方 $p$ 均为质数\n$$ \\binom nm \\bmod p = \\binom { \\lfloor n/p \\rfloor } {\\lfloor m/p \\rfloor} \\binom {n\\bmod p}{m \\bmod p}\\bmod p $$\n引理 1 $$ (a+b)^p \\equiv a^p+b^p \\pmod p $$\n证明：考虑 $\\tbinom pk$ ，易得到$\\binom pk = \\frac{p!}{n!(p-n)!}$，这玩意 $\\bmod p$ 基本上是 $0$ ，于是我们开始把它扔到上面 #二项式定理 里面想。\n分两种情况\n$n \\neq p$ 且 $n\\neq1$ 此时 $p$ 没法被分母任何一个因数整除，因此一定会在值中被保留下来，则该式被 $p$ 整除 $n=p$ 或 $n=1$ 容易得到此时该式值为 $1$ 于是我们就把二项式定理中的所有项讨论完了。\n$$ (x+y)^p = \\binom p 0 x^p + \\binom p1 x^{p-1}y^1 + \\dots + \\binom {p}{p-1}x^{p-(p-1)}y^{p-1} + \\binom pp y^p $$\n根据上面的讨论，左右两边的两项系数为 $1$，其余被 $p$ 整除，也就是被模掉了，于是最后剩下：\n$$ (x+y)^p=x^p+y^p $$\n证明 #引理 1 推导的过程中没有任何限制，于是我们可以把它用在多项式身上\n考虑一个二项式 $(1+x)^n \\bmod p$，设 $n = kp+r$，则在 $\\bmod p$ 意义下有：\n$$ \\begin{aligned} (1+x)^n \u0026amp;= (1+x)^{kp}(1+x)^r \\\\ \u0026amp;= (1+x^p)^k(1+x)^r \\\\ \u0026amp;= (1+x^p)^{\\lfloor n/p \\rfloor}(1+x)^{n\\bmod p} \\end{aligned} $$\n用二项式定理拆开的话，可以观察一下这个式子的内部结构\n$$ (1+x)^n = \\binom n0 x^1 + \\binom{n}{1}x^2+\\dots+\\binom n{n-1}x^{n-1} + \\binom nn x^n $$\n现在我们的目标是求 $\\binom nm$，实际上在上面的式子里就是 $x^m$ 的系数。\n想办法从前面推导出来的东西表示 $x^m$ 的系数，这里采用类似的办法，把 $m$ 拆开为 $\\lfloor m/p \\rfloor p + (m \\bmod p)$，于是目标转化为如何在最上面的式子中找到 $x$ 相乘表示出左侧的次数。\n分开考虑贡献，$\\lfloor m/p \\rfloor p$ 只能从 $(1+x^p)^{\\lfloor n/p \\rfloor}$ 处得到贡献，因为这玩意显然是个 $p$ 的倍数，而另外半边式子中 $n \\bmod p$ 绝对小于 $p$。\n于是我们也就考虑到了 $m\\bmod p$ 的贡献应当从 $n \\bmod p$ 中来，因为 $\\lfloor n/p \\rfloor \u0026gt; p$。\n这样就找到了对 $\\binom nm$ 的总贡献，从 $n \\bmod p$ 中选 $m \\bmod p$ 个，另外半边同理，则为\n$$ \\binom nm \\bmod p = \\binom { \\lfloor n/p \\rfloor } {\\lfloor m/p \\rfloor} \\binom {n\\bmod p}{m \\bmod p}\\bmod p $$\n","date":"2023-04-30T18:29:32Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","title":"组合数学基础"},{"content":"自学逆元\u0026hellip;\n定义 OI 中常用“逆元”作“模意义下的乘法逆元”。 $$ ax\\equiv 1 \\pmod b $$ 则 $x$ 为模 $b$ 意义下的 $a$ 的逆元，记作 $a^{-1}$ 。\n通俗来讲，$a\\cdot a^{-1} \\bmod b = 1$\n用途 先讲用途再说求法？\n对于 $\\frac ab$，想要对结果取模，但是实际上 $\\frac ab \\bmod p \\neq \\frac {a\\bmod p}{b \\bmod p}$\n难道没有办法了吗？\n并不是。\n设 $b^{-1}$ 为 $b \\bmod p$ 意义下的逆元，则有 $$ \\frac ab \\bmod p = a\\cdot b^{-1} $$\n求单个逆元 扩展欧几里得算法 此法相对于快速幂来说，限制少，常数小，因此比较优，不再写快速幂法。实际上是我不会快速幂法\n容易发现乘法逆元定义式就是一个普普通通的同余方程\n于是可以轻松使用扩欧求解\n详见 同余方程与二元一次不定方程\n线性求逆元 由于线性求任意多个数逆元过于简单，所以直接记录这个解法。\n考虑逆元的定义，容易想到对于 $a^{-1}b^{-1}$ 来说，乘 $a$ 即可消除 $a^{-1}$ 的影响，即 $$ a\\cdot a^{-1}b^{-1} \\bmod p = (a\\cdot a^{-1} \\bmod p)b^{-1} = b^{-1} $$ 与此同时，两个数积的逆元等于两个数逆元的积\n证明： $$ \\begin{aligned} aa^{-1} \\bmod p \u0026amp;= 1\\\\ bb^{-1} \\bmod p \u0026amp;= 1\\\\ aa^{-1} \\cdot bb^{-1} \\bmod p \u0026amp;= 1 \\\\ ab \\cdot a^{-1}b^{-1} \\bmod p \u0026amp;= 1 \\\\ \\therefore (ab)^{-1} = a^{-1}b^{-1} \\end{aligned} $$ 因此对于任意数列 $a_1 \\dots a_n$ ，可以先求出其前缀积 $s_i$ ，然后利用扩展欧几里得求累积的逆元 $f_n = s_n^{-1}$，然后从后往前线性复杂度求出前缀积的逆元 $f_{i-1} = f_ia_i \\bmod p$ ，最后从前往后扫一遍求出每个数的逆元 $inv_i = s_{i-1}f_i$ 即可。\ni32 tmp; void exgcd(i32 a, i32 b, i32\u0026amp; x, i64\u0026amp; y) { if (!b) { x = 1, y = 0; return; } exgcd(b, a % b, x, y); tmp = x; x = y; y = tmp - (a / b) * y; } #define N 5000001 i32 a[N], s[N], f[N]; i64 n, p, k, ans, ktmp, y; int main() { read(n, p, k); s[0] = 1; for (i32 i = 1; i \u0026lt;= n; ++i) read(a[i]), s[i] = s[i - 1] % p * a[i] % p; exgcd(s[n], p, f[n], y); // write(p, \u0026#39;\\n\u0026#39;); for (i32 i = n - 1; i; --i) { f[i] = f[i + 1] % p * a[i + 1] % p; } f[1] %= p; ans = k * f[1] % p; ktmp = k % p; for (i32 i = 2; i \u0026lt;= n; ++i) { f[i] = s[i - 1] % p * f[i] % p; ktmp = (ktmp * k) % p; ans = ((ans % p + ktmp * f[i]) % p + p) % p; } write(ans, \u0026#39;\\n\u0026#39;); return 0; } ","date":"2023-04-29T19:24:23Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E9%80%86%E5%85%83/","title":"模意义下的乘法逆元"},{"content":"同余方程组形式如下： $$ \\begin{cases} x \\equiv a_1 \\pmod {n_1} \\\\ x \\equiv a_2 \\pmod {n_2} \\\\ \\dots \\\\ x \\equiv a_k \\pmod {n_k} \\end{cases} $$\n中国剩余定理 原理 本算法用于所有 $n_i$ 两两互质的情况。\n实际上类似构造，先把 $n_1$ 累积起来 $$ M = \\prod_{i=1}^k n_i $$ $$ M_i = \\frac M{n_i} $$\n先考虑如何构造出一个同余方程的特解，设 $M_i ^{-1}$ 为 $M_i$ 在 $\\bmod n_i$ 意义下的逆元,想到 $M_iM_i^{-1} = 1\\pmod {n_i}$，于是有 $x = a_i M_i M_i^{-1}$ 满足方程 $x \\equiv a_i \\pmod {n_i}$ 。\n这实际上就是上面定义 $M_i$ 为质数的原因：需要保证有逆元存在。\n至于解的合并，把 $x$ 相加即可。即 $\\sum_{i=1}^k a_iM_iM_i^{-1}$。通解即为 $nM+ \\sum_{i=1}^k a_iM_iM_i^{-1}, n\\in \\mathbf Z$ 。为什么能这样合并？因为对于 $i,j,i\\neq j$ 来说，必然存在 $n_j \\mid M_i$，因为 $n_i$ 两两互质，$M_i$ 的因子包含 $n_j$，因此不会对已经推出来的解造成任何影响。\n通解方面：容易想到，加减 $nM$ 也不会对解的可行性造成任何影响。\n实现 llint ex_gcd(llint u, llint v, llint\u0026amp; x, llint\u0026amp; y) { if (!v) { x = 1, y = 0; return u; } llint g = ex_gcd(v, u % v, x, y); llint temp = x; x = y; y = temp - u / v * y; return g; } llint crt() { llint tmp = 1, ans = 0; for (int i = 1; i \u0026lt;= n; ++ i) tmp *= b[i]; for (int i = 1; i \u0026lt;= n; ++ i) { llint m = tmp / b[i], x, y; ex_gcd(m, a[i], x, y); ans = (ans + n[i] * m * x % tmp) % tmp; } return (ans % tmp + tmp) % tmp; } 扩展中国剩余定理/同余方程合并 原理 当 $n_i$ 不互质的时候，上面做法就不再适用（不能保证逆元存在），此时我们考虑逐一合并同余方程组。\n方法是使用 $\\operatorname{ex_gcd}$\n假设方程组只有两个方程\n$$ \\begin{cases} x \\equiv a_1 \\pmod{n_1} \\\\ x \\equiv a_2 \\pmod{n_2} \\\\ \\end{cases} $$\n可以写作\n$$ \\begin{cases} x = a_1 + k_1n_1 \\\\ x = a_2 + k_2n_2 \\end{cases} $$ 则 $a_1 + k_1n_1 = a_2 + k_2n_2$。\n移项，得 $k_1n_1 - k_2n_2 = a_2-a_1$ ，接下来按照扩展欧几里得的思路推导。\n设 $g = \\gcd(n_1,n_2)$，若使用扩展欧几里得算法，可以求出 $n_1k_1 + n_2(-k_2) = \\gcd(n_1,n_2)$ 的一组特解 $k_1, k_2$，即 $$ \\begin{aligned} n_1k_1 + n_2(-k_2) \u0026amp;= g \\\\ (k_1 \\cdot \\frac{a_2-a_1}{g})n_1 + (-k_2 \\cdot \\frac{a_2-a_1}{g})n_2 \u0026amp;= a_2-a_1 \\end{aligned} $$ 抽出刚才表示 $x$ 的方程组的一条，得到 $x_0 = a_1 + k_1n_1$，$k_1$ 的通解为 $k_1 + \\cfrac{n_2}gp, p\\in \\mathbf Z$，则 $$ \\begin{aligned} x \u0026amp;= a_1 + (k_1+\\cfrac{n_2}gp)n_1 \\\\ \u0026amp;= n_1k_1 + a_1 + \\cfrac{n_1n_2}gp \\\\ \u0026amp;= n_1k_1 + a_1 + \\operatorname{lcm}(n_1,n_2)\\cdot p \\end{aligned} $$ 显然我们可以把这个等式写成同余式的形式（没必要）\n$$ \\begin{aligned} x_0 \u0026amp;\\equiv x \\pmod {\\operatorname{lcm}(n_1,n_2)} \\\\ x\u0026amp;\\equiv n_1k_1 + a_1 \\pmod {\\operatorname{lcm}(n_1,n_2)} \\end{aligned} $$ $\\operatorname{lcm}(n_1,n_2),n_1k_1+a_1$ 都是已知的，因此方程可解，合并完成。\n实现 #define N 100005 i128 ex_gcd(i128 a, i128 b, i128\u0026amp; x, i128\u0026amp; y) { if (b) { i128 tmp; i128 g = ex_gcd(b, a % b, x, y); tmp = x; x = y; y = tmp - a / b * y; return g; } else { x = 1, y = 0; return a; } } i64 n; i128 a[N], m[N]; // a === x (mod m) i128 ex_crt() { i128 k1, k2, a1, m1, a2, m2, c, gc, g; a1 = a[1], m1 = m[1]; for (i64 i = 2; i \u0026lt;= n; ++i) { a2 = a[i], m2 = m[i], c = ((a2 - a1) % m2 + m2) % m2; g = ex_gcd(m1, m2, k1, k2); gc = m2 / g; k1 = k1 % gc * ((c / g) % gc) % gc; a1 = k1 * m1 + a1; m1 *= gc; a1 = (a1 % m1 + m1) % m1; } return a1; } int main() { read(n); for (i64 i = 1; i \u0026lt;= n; ++i) { read(m[i], a[i]); } write(ex_crt(), \u0026#39;\\n\u0026#39;); return 0; } ","date":"2023-04-29T11:54:32Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%BB%84/","title":"同余方程组"},{"content":"离散对数问题，即已知 $a,b,p$，求方程 $a^x \\equiv b \\pmod p$ 最小非负整数解。\nBSGS 算法 原理 思考暴力做法，即枚举 $x$ 直到满足方程，复杂度 $\\operatorname{O}(p)$\nBSGS 类似一种分块思想，也有点像折半搜索（\n首先把 $x$ 拆开，拆成 $km - r$ ，然后进行变换： $$ \\begin{aligned} a^x \u0026amp;\\equiv b \\pmod p \\\\ a^{km-r} \u0026amp;\\equiv b \\pmod p \\\\ \\frac {a^{km}}{a^r} \u0026amp; \\equiv b \\pmod p \\\\ a^{km} \u0026amp; \\equiv ba^r \\pmod p \\end{aligned} $$ 这里的 $m$ 我们设为一个固定值，然后分别枚举等式两边的 $k,r$，存哈希表（映射），然后匹配即可，其中 $k \\in [0, \\cfrac pm], r \\in [0,m]$ ，复杂度 $\\operatorname{O}(\\max(m,\\cfrac pm))$ ，则 $m=\\sqrt p$ 时最优，复杂度是一个根号。\n实现 read(n, p); b = 10; n = n * 9 + 1; b = (b % p + p) % p; n = (n % p + p) % p; if (b == 0) { if (n == 0) output(1); failed(); } if (n == 1) { output(0); } if (b == 1) { failed(); } i128 m = sqrt(p), z = n; for (i128 i = 0; i \u0026lt; m; ++i) { mp[z] = i; // 存储的实际上是模数所对应的最大 r（从小到大枚举，挨个覆盖） z = z * b % p; } z = binpow(b, m); for (i128 i = 1, pian = z; i \u0026lt;= p / m + 10; ++i) { auto it = mp.find(z); if (it != mp.end()) { output(m * i - it-\u0026gt;second); } z = z * pian % p; } failed(); ","date":"2023-04-28T18:12:32Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/","title":"离散对数"},{"content":"前言 现今 Windows 作为国外闭源系统随时可能被美方禁止使用却大行其道占据大陆巨额市场，可能操作系统真的引不起重视，就像光刻机一样，事情到了无可挽回的地步才开始用力建设吗？\n写本文的起因是我一同学（实际上不止一个）并不会 NOI Linux 的基本使用，而这玩意是中国大陆 OI 中比较重要的环境之一，因此写一份基础教程\n从终端开始 什么是终端？ 对于一个计算机来说，输入输出设备显然不是必需品（脱离使用的范畴，没有输入输出设备它也能通电成为一个吉祥物），而最初人们为了与计算机互动，发明了终端，即人类用户与计算机交互的设备。\n对于一个计算机操作系统，其运行过程中本身并没有显示任何东西，所谓桌面环境之类在显示器上显示的东西都是后话，最简单的输入输出方式即“我输入文字，计算机输出文字”，于是引入今天我们所要遇到的第一个概念，我称其为“文字终端”，即你输入文字，计算机输出文字的地方。\n对于现在来说，以往奢侈的图形显示现在已经满地都是，但是为了还能用上简单快捷的文字终端的功能，出现了“终端模拟器”，实际上就是开一个小黑窗口，里面能够输入输出（类比 CMD）。\n打开终端 在桌面或者文件管理器中右键，点击“在终端中打开”\n于是出现了一个如上的窗口，这就是一个终端模拟器，里面运行一个被称为“Shell”的进程，这里不多作介绍，理解它能够输入输出文字就行。\n在这里你可以输入命令，做到创建文件，修改文件，删除文件等基本上你在图形界面下能做的所有事情。\n先\u0026hellip;管理文件？ 在 Shell 中，. 表示当前目录，.. 表示当前目录的父目录，/ 表示根目录\nLinux 下只有一个根目录，不会像 Windows 一样不同的盘有不同的根目录\n也就是如下\nWindows: C:- |- Windows |- Program Files |_ Users D:- |- Software |- Documents |_ Steam Linux: / - |- usr |- bin |- home |- dev |- etc |..... 绝对路径：能唯一确定的路径，也就是说从根目录表示的确定的位置，比如 /usr/local/bin\n相对路径：相对于某一目录的位置，比如当前目录是 /usr/local/， 则上面的路径可以表示为 bin 或 ./bin\n先提供相应的命令：\n# 这是一条注释，SHELL 中使用井号做单行注释 # 创建文件夹 mkdir folder_name # 创建一个 modmodwhr 文件夹 mkdir modmodwhr # 创建空文件 touch filename # 创建一个名为 whrakioi 的空文件 touch whrakioi # 进入一个目录 cd folder_name # 如果当前目录下有一个 hhyakioi 文件夹，则可以通过这个命令进入该文件夹 cd hhyakioi # 或者 . 代表当前目录，./hhyakioi 相当于进入当前目录下的 hhyakioi 文件夹 cd ./hhyakioi # 进入上一级文件夹 cd .. # 进入根目录 cd / # 进入某绝对路径 cd /usr/share # 最后一个杠加不加无所谓 cd /usr/share/ # 复制一个文件到另一个位置 cp /path/to/file /path/to/direction # 把 1.cpp 复制到 gjxakioi 文件夹 cp 1.cpp gjxakioi/1.cpp # 复制文件夹需要添加 -r 参数 cp folder_name gjxakioi/folder_name -r # 移动一个文件到另一个位置，同时可以当重命名用 mv path1 path2 # 重命名 1.cpp 为 2.cpp mv 1.cpp 2.cpp # 移动 2.cpp 到 gjxakioi 文件夹 mv 1.cpp gjxakioi/1.cpp NOI Linux 2 的比赛环境下默认给你挂载 noip 文件夹并在 Linux 桌面上创建快捷方式，因此如果你在桌面上进入终端，则可以通过下面的命令进入 noip 文件夹\ncd noip 或者\ncd ./noip 开始写代码吧！ 想编辑下文件？ 如果你在 Windows 下写好了代码想要粘贴到 Linux 的文件里，则可以\n# 新建 a.cpp 文件 touch a.cpp # 使用 nano 编辑器编辑 a.cpp 文件 nano a.cpp nano 是 GNU 的一款简易终端文本编辑器，相对于 Vi/Vim 来说更适合新手使用\n复制了 Windows 的代码之后，确保 VMware 的共享剪贴板已经打开，然后按下 Ctrl + Shift + V 粘贴，然后按下 Ctrl + S 保存，Ctrl + X 退出。\n当然，有图形化编辑器供你使用\n# 使用闭源 Visual Studio Code 编辑 a.cpp code a.cpp 在此之后你可以通过 cat 命令1验证文件内容\ncat a.cpp 编译 C++ 源码 GNU 编译套件 GNU Compile Collection 是 GNU 开发的一套编译器，在这里我们只使用 GNU C 编译器部分。\n另：GNU 计划的目标是开发出一款完全自由的操作系统和软件生态，自由软件运动致力于推进全部软件的隐私保护以及自由化，自由软件属于全人类，自由软件开发者们留下的作品与学习资料是不朽的！如果你对自由软件运动有疑问或有兴趣，可前往 www.gnu.org 了解更多相关内容。\n开始编译 g++ grainrainisgod.cpp 这个命令会在当前目录下编译 grainrainisgod.cpp 文件，然后默认输出一个 a.out 可执行文件2。\n可是我懒得重命名文件，所以如何执行输出可执行文件的位置和名称呢？只需要加 -o /path/to/direction 即可\ng++ grainrainisgod.cpp -o grainrainisgod 当然，你也可以加入其他比赛要求的编译选项，比如说吸个氧（加 -O2 参数）\ng++ grainrainisgod.cpp -o grainrainisgod -O2 开启编译警告 编译警告在编译的编译阶段和警告阶段发出，能帮你发现一些低级问题和简单 UB，比如著名 UB（但是萌妹 OPTIM 还是犯了这个问题）\na = a++ + ++a; 编译器会发出警告\nwarning: multiple unsequenced modifications to \u0026#39;a\u0026#39; [-Wunsequenced] cout \u0026lt;\u0026lt; a++ + ++a \u0026lt;\u0026lt; endl; 这样的警告对于比赛选手来说肯定是越多越好越全越好，所以需要开启全部警告，即添加 -Wall 参数\ng++ grainrainisgod.cpp -o grainrainisgod -O2 -Wall 检查内存错误以及未定义行为 Sanitizer 是谷歌开发的一个检测程序问题的开源套件，一般集成在 gcc 以及 clang 编译器中。相应的，MinGW-W64 并没有为 Sanitizer 做 Windows 兼容，因而无法在比赛环境 Windows 使用（LLVM/Clang 编译器包含的 Sanitizer 支持 Windows，MSVC 的也支持但是只有 AddressSanitizer）（但是显然比赛环境没有这两个编译器），所以显得 Linux 环境非常重要。\nAddress Sanitizer 用于检测程序的内存错误，比如爆栈等问题。使用方法是添加 -fsanitize=address 选项\nUndefined Behaviour Sanitizer 用于检测程序的未定义行为，比如访问空指针，数组越界访问等问题，使用方法是添加 -fsanitize=undefined 选项。\n值得注意的是，这两个 Sanitizer 会显著拖慢程序运行速度，所以添加这两个编译选项编译出来的程序在运行时间和内存占用上参考意义不大。同时如果动态分配内存过多可能 Address Sanitizer 会抽风，UBSanitizer 倒是问题不大。所以酌情使用。\n总结： g++ grainrainisgod.cpp -o grainrainisgod -O2 -Wall -fsanitize=address -fsanitize=undefined 如上是我赛时经常使用的编译命令。\n执行可执行文件 ./grainrainisgod . （当前目录）+ / （目录分隔符）+ grainrainisgod 可执行文件名称\n然后就可以快乐地输入了。\n注意：在这个终端中复制使用 Ctrl+Shift+ C，粘贴使用 Ctrl+Shift+ V\nCtrl + C 用于终止当前正在运行的程序，也可以在输入命令打错字时 Ctrl + C 重开一行。\ncat filename 即输出 filename 文件的内容\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLinux 下文件类型的判断与 Windows/DOS 略有不同。众所周知，Windows 下操作系统通过扩展名判断文件类型，也就是说无论你把什么文件改成 .docx 扩展名，Windows 都会用 Word 打开它。但是 Linux 一般通过文件头判断文件类型，也就是说无论你把可执行文件命名成 a.out 还是 a.docx 还是 a.jpg 甚至没有扩展名，输入 .\\a.jpg 或相应命令之后终端都会把它当作可执行文件执行。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-03-28T22:12:58+08:00","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/linux/noi-linux-%E7%9B%B8%E5%85%B3/","title":"NOI Linux 指北"},{"content":"分层图 相当于一个建图的技巧，对于一个图求解时按照题目加入一个特殊操作，通过这个特殊操作能进入下一层图。\n建议配合例题理解\n又是一道琪露诺的题目捏\n给定 $n$ 点 $m$ 边的有向带权图，可以使用一张符卡 「完美冻结」 使你通过一条边时只需要一半时间，一共有 $k$ 张符卡，求最短路。\n只需要建立 $k-1$ 层原图，对于每一层原图中间使用一半边权的边连接在一起，然后直接求最短路即可。\n显然时间复杂度较高，但是本题数据较小 $k,n \\leqslant 50, m\\leqslant 1000$ ，所以问题不大，足够切掉本题。\n同余最短路 题型大概是若干个正整数（无限次使用次数）拼凑出某个数\n匹配 定义 给定一张图，选定一个边的集合使得其包含的边最大，要求每个点只出现一次\nTODO ","date":"2023-03-12T19:00:58+08:00","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%9D%82%E8%B0%88/","title":"杂基础图论（1）"},{"content":"定义 分量相关 分量：一个图的子图\n连通分量：在一个分量中对于任意两点 $u,v$ 均能互相到达\n强连通分量：再加入母图的任意分量外一点都会导致强连通分量不再是连通分量\n如上图，红线圈住的部分是强连通分量，因为很显然该子图中再加入 $0,5,4,6$ 任意一个点都会导致它不能再做到任意两点互相到达。\n边相关 如上图是张有向连通图\n上图标注出了该图的 DFS 搜索树（即按照深度优先遍历所走过的边）\n图中的每一条红边都被称作树枝边\n上图中新标出的的黄 蓝 绿三个边明显与红边的性质不同\n黄边：搜到黄边时发现下一个点是之前搜索的其他子树的点，该边称为横叉边\n蓝边：搜完 2-\u0026gt;5-\u0026gt;8 后搜蓝边，发现 8 点已经被标记过，该边称为前向边\n绿边：指向了当前子树之前搜索过的点，称为后向边\n这些概念用处不大，有点印象即可\nKosaraju 求强连通分量 ","date":"2023-02-27T19:52:58+08:00","permalink":"https://blog.tibrella.top/notes/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","title":"有向图中的强连通分量"},{"content":"最近因为原来 我的 butterfly 主题 fork 实在改不动了（实际上因为我水平太差），对于 pug 什么的也不太懂，同时由于界面过于花哨看腻了，想换点动态效果少的而又相对简单的博客主题。 又因为之前就观察过 hugo 的主题列表，hugo 的特点是快，大部分的 hugo 主题也非常简洁（比如 c4096 的博客所采用的主题），因此我又双叒叕去 hugo theme 列表挑了个非常符合我审美（大概）的主题，即 stack。\n最一开始用 test 界面测试主题功能的时候 hugo 的速度就惊艳我了，实在是过于迅速，和我之前所用的 hexo+butterfly 的速度相比，hugo 让我感觉到构建了又好像没构建的构建过程。同时它的即时修改即时预览功能也很好用（但是有的时候并不能做到完全应用新修改）。 但是一起到来的问题也很多，比如 stack 主题的文档并不是很完善，相对于我看过的大部分 hexo 主题来说可能是最不完善的（中英文倒是无所谓），因此我需要一边看文档一边看源码，还得看主题的示例站点的配置文件才让我的博客跑出正常的样子。\n主题配置问题还算好解决，对于我这个啥都不懂还贼挑的人来说，改动主题是必须有的部分，但是 hugo 的编写修改维护主题的文档和教程更是少之又少了\u0026hellip;因此研究了好久也没研究出来怎么改代码块样式，改配色也没成功，但是把深浅色代码块背景宽度不统一的问题倒是解决了，还得对这个进行进一步更改。当然，主题克隆下来的第一步就是 copyright-\u0026gt;copyleft，然后给 \u0026amp;copy 掉个头，文章许可证改为 FDL 1.3 才继续做接下来的修改。\n关于写配置，我最开始采用的是网上得到大部分好评的 toml 格式，据说比 yaml 新还好用，在此之前因为 yaml 的缩进问题我痛苦了很长时间，但是折腾了好久 toml 之后感觉 toml 更不容易被人类理解（可能只有我不理解），然后用工具回到了 yaml 的怀抱，在此之前为了研究 toml 的 map 映射语法之类的东西已经折腾不动了\u0026hellip;\n关于换行，由于之前的 butterfly 主题能够自动换行，但是 stack 主题默认用的是 markdown 的换行规则，即行尾双空格或回车两次为一个换行，于是我博文基本上都炸了，会找时间修（逃\n","date":"2023-02-24T21:40:29Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E8%BF%81%E7%A7%BB%E8%87%B3-hugo-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A0%B4%E4%BA%8B/","title":"更改博客主题之后的一些破事"},{"content":"ArchLinux 添加证书（感谢 Marisa） sudo trust anchor --store myCA.crt Grub 提示 /usr/share/grub/grub-mkconfig_lib: 第 237 行：printf: “$”：无效格式字符 在英文环境下 grub-mkconfig 即可\nenv LANG=en_US.UTF-8 sudo grub-mkconfig -o /boot/grub/grub.cfg gcc 编译提示 编译器内部错误：File size limit exceeded signal terminated program as 编译的时候爆内存了\n可能是你用了形如\nbool a[100000010] = {1,1}; 的语句进行初始化。\n这个语句虽然只会给你的 $a_0, a_1$ 赋值，但是在编译预处理和程序运行的过程时，它都会将数组全部展开再进行赋值/初始化\n所以还是老老实实赋值吧\nbool a[100000010]; a[0] = a[1] = 1; gcc 编译提示 relocation truncated to fit: R_X86_64_PC32 against '.bss' 静态数组爆内存了，一般的解决方法是加编译选项\ng++ test.cxx -o test -mcmodel=medium 或者\ng++ test.cxx -o test -mcmodel=large 其实换 clang++ 编译有的时候就能过 但是测评机肯定还是 gcc ，所以应该考虑下自己是不是写错数了\n","date":"2023-02-24T21:40:29Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E9%92%9B%E5%90%88%E9%87%91%E4%BC%9E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9C%BA/","title":"钛合金伞的垃圾场"},{"content":"模拟退火不是模拟题意，也不会让你退火（可能会让你上火），顾名思义，这个算法模拟的是“退火” 的过程。\n基本原理 退火即晶体冷却的过程，将一个物体加热到一定温度后使其逐渐降温。而在物理中，物体内能越高，其粒子随机运动就更剧烈，状态也就越不稳定。物体温度高时，状态最不稳定。使降温，粒子运动变慢，状态就趋于稳定。当降温速度过快，会导致粒子来不及排列成稳定的原有的结构，从而形成能量高不稳定的非晶体。相对的，如果降温速度足够慢，粒子会渐趋有序，直至内能减为最小，此时物体呈现为晶体。\n上面两段所说的“非晶体”可以看作“局部最优解”，而变回原有结构的晶体则可以看作“最优解”。\n大体来说，模拟退火就是随机跳解，接受更优的解，同时为了防止局部最优解的陷阱，概率性接受不优的解，后者相当于物理过程中粒子的随机跳动，它带来了晶体降温结果的随机性。而跳随机解的次数多少，则相当于降温的速度，降温的速度越慢，晶体回到原有结构的可能性更高，也就相当于跳解的次数越多，跑出最优解的可能性更高。\n先放一张图感性理解一下\n有一个比较有趣的比喻\n爬山算法：一个兔子从一个点往高爬，爬到了一个山顶，但是不知道这个山顶是不是珠穆朗玛峰\n模拟退火：一个兔子喝醉了乱跳，跳到了某个山顶也要继续跳到别的山坡，但是它逐渐清醒，向最高点跳去\n感性理解后我们详细讲解一下算法过程。\n算法过程 设定好“初始解”，“初始温度”与“下降速度”，每一次“降温”都得到一个新解，于是出现两种情况，即新解优于旧解或不优于旧解。优于旧解显然是要接受的，但是只接受优解可能只能找到局部最优，与爬山算法无异，因而我们对于一个不优的解还需要进一步处理。\n而这一步处理（可能是）模拟退火的精髓所在，是把这个随机化算法和热力学/统计力学等连接起来的部分，即接受这个不优解的概率。\n摘自维基百科\n玻尔兹曼分布是状态能量与系统温度的概率分布函数，给出了粒子处于特定状态下的概率\n公式即为\n$$ p_i = \\frac{1}{Q} e^{\\frac{-\\epsilon_i}{kT}} $$\n此处 $p_i$ 是状态 $i$ 的概率，$\\epsilon_i$ 为状态 $i$ 的能量，$k$ 为 Boltzmann 常数，$T$ 为温度\n啊当然这个并不是我们接下来需要用到的准则，只是引入一个热力学常量，即 Boltzmann 常数。同时下面的准则很大程度基于上面的玻尔兹曼分布（可能是，我目测的\n1953 年 Metropolis 提出了这样一个重要性采样的方法，即设从当前状态 $i$ 生成新状态 $j$，若新状态的内能小于状态 $i$ 的内能，即 $E_j\u0026lt;E_i$，则接受新状态 $j$ 作为新的当前状态；否则，以概率 $\\exp(\\frac{-(E_j-E_i)}{kT})$ 接受状态 $j$，其中 $k$ 为 Boltzmann 常数。\n上面的概率公式中 $\\exp$ 即 $e$ 的指数函数，同时两个状态能量的差 $E_j - E_i$ 可以表示为 $\\Delta E$，则可以写出一个（我）更容易理解的表达方式，即\n$$ p_j = e^\\frac{-\\Delta E}{kT} $$\n总的来说，概率 $p_{new}$ 可以表示为\n$$ p_{new} = \\begin{cases} 1, \u0026amp; \\text{if } \\operatorname{E}(x_{new}) \u0026lt; \\operatorname{E}(x_{old}) \\\\ e^\\frac{-\\Delta E}{kT} \u0026amp; \\text{if } \\operatorname{E}(x_{new}) \\geqslant \\operatorname{E}(x_{old}) \\end{cases} $$\n概率处理完了，主要算法部分也基本上结束了，下面我们引入一道例题。\n例题 [TJOI2010]分金币 题目描述 现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n输入格式 本题单个测试点内有多组测试数据。\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n对于每组测试数据的格式为：\n每组测试数据占两行。\n第一行是一个整数 $n$，表示金币的个数。\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。\n输出格式 对于每组数据输出一行一个整数表示答案。\n样例 #1 样例输入 #1 2 3 2 2 4 4 1 2 3 6 样例输出 #1 0 2 提示 数据规模与约定 对 $30%$ 的数据，保证 $1 \\leq v_i \\leq 1000$ 对于 $100%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。 TODO\n","date":"2023-02-23T14:11:18Z","image":"https://pic.imgdb.cn/item/63f76817f144a01007c05a60.jpg","permalink":"https://blog.tibrella.top/notes/%E6%9D%82%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","title":"模拟退火"},{"content":"题意 一张有向无环带权图，有一个初始值 $k$，从入口进入后每过一条边 $i$ 则 $k = k \\times 2+w_i$（$w_i$ 为边权，有正有负），要求从入口到出口的过程中始终 $k\u0026gt;0$，求使方案存在的最小初始值 $k$。\n思路 之前什么答辩题面\n先忽略 $k$ 经过一条边时翻倍，只考虑加边权，如何求出答案？由于图带边权，保证不出现环，同时判断一个 $k$ 值是否合法的方式实际上是计算一条路径边权和并与 $k$ 比较，联想到最短/长路。\n新题面中提到只需存在一种方案能让出口 $k\u0026gt;0$ 即可，显然是最短路。但是如果从起点求最短路还要考虑 $k$ 的影响，因此反向建图，终点初始值设为 $1$，从终点跑即可。\n由于边权有正有负，只能跑 SPFA。\n再考虑 $k$ 的变换还有一个 $\\times 2$，因此跑反向的 SPFA 松弛边时需要把新算出的 $dist_i$ 值除以 $2$。\n代码 #include \u0026lt;bitset\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; // 模板函数可以参考博文 https://blog.tibrella.top/post/2023-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%9D%82%E8%B0%88%E4%B8%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/ template \u0026lt;typename Type\u0026gt; void read(Type\u0026amp; _x) { _x = 0; bool f; char ch; f = 0; do { ch = getchar(); if (ch == \u0026#39;-\u0026#39;) f = 1; } while (ch \u0026lt; 48 || ch \u0026gt; 57); do { _x = (_x \u0026lt;\u0026lt; 3) + (_x \u0026lt;\u0026lt; 1) + (ch ^ 48); ch = getchar(); } while (ch \u0026gt; 47 \u0026amp;\u0026amp; ch \u0026lt; 58); _x = f ? -_x : _x; } template \u0026lt;typename Type\u0026gt; Type max(Type _a, Type _b) { return _a \u0026gt; _b ? _a : _b; } using std::bitset; using std::queue; #define N 105 struct edge { edge* nex; int u, v, w; } graph[N * N]; edge* fir[N]; int dis[N]; edge* idx = graph; int n; queue\u0026lt;int\u0026gt; q; bitset\u0026lt;N\u0026gt; st; void add(int u, int v, int w) { ++idx; idx-\u0026gt;u = u; idx-\u0026gt;v = v; idx-\u0026gt;w = w; idx-\u0026gt;nex = fir[u]; fir[u] = idx; } void spfa(int nod); int t1; int main() { read(n); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { read(t1); // 中转变量 if (t1) add(j, i, -t1); // 反向存图 } } spfa(n); printf(\u0026#34;%d\u0026#34;, dis[1]); return 0; } void spfa(int nod) { st.reset(); memset(dis, 0x3f, sizeof dis); dis[nod] = 1; st[nod] = 1; q.push(nod); while (!q.empty()) { nod = q.front(); q.pop(); st[nod] = 0; for (edge* e = fir[nod]; e; e = e-\u0026gt;nex) { if (dis[e-\u0026gt;v] \u0026gt; max(1, (dis[nod] + e-\u0026gt;w + 1) / 2)) { // +1 防止除法向下取整造成错误 dis[e-\u0026gt;v] = max(1, (dis[nod] + e-\u0026gt;w + 1) / 2); if (!st[e-\u0026gt;v]) { q.push(e-\u0026gt;v); st[e-\u0026gt;v] = 0; } } } } } ","date":"2023-02-23T14:11:18Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E9%A2%98%E8%A7%A3/%E7%BB%86%E8%8F%8C-%E9%A2%98%E8%A7%A3/","title":"细菌 题解"},{"content":"倍增求 LCA 是一种高效的求 LCA 算法，时间复杂度为 $\\operatorname{O}(\\log{n})$\n原理 初始 维护一个 $fa_{i,x}$ 表示 $x$ 往根节点走 $2^i$ 步到达的节点。\n初始化时 $fa_{0,x} = father_x$ 更新为 $fa_{i,x} = fa_{i-1,fa_{i-1,x}}$ 查询 中心思想是利用二进制向上跳。\n假设目前要查询 a 号节点和 b 号节点的 LCA，将较深节点设为a，较浅设为b，即：\n首先将 a 向上跳到和 b 同一高度，若此时 a = b，直接返回 b 即可，即 b 为 a 的一个直接父亲，LCA 也一定是 b。 否则将两个节点同时往上跳，$i$ 从大到小，每次跳 $2^i$，规则如下： 如果跳完两个节点相同，即找到了一个共同祖先，则不跳，因为此时不能确定这个共同祖先是不是最近的。 否则就继续同时往上跳，最终返回 $fa_{0,a}$ 即可。 ","date":"2023-02-02T21:27:12Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E5%9B%BE%E8%AE%BA/%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82-lca/","title":"倍增求LCA/最近共同祖先"},{"content":"起因是发现很多同学对常数优化和语句的执行效率有误解（我肯定也有，但是我尽量把我知道的正确的写出来），因此写一篇杂谈做一个说明，同时介绍一些比较新的好用的语言特性（C++14）\ntemplate 模板关键字 函数 template 顾名思义是用来做模板的，那是做什么的模板呢？ 举个例子，一般来说我们写 max 函数替代 std::max 来优化的时候，写出来的大概长下面这样：\nint max(int a, int b) { return a \u0026gt; b ? a : b; } 在这三行代码中，第一行定义了 max 的返回值和参数 a b 的类型为 int，显然意味着这个函数只能比较 int 类型的量。\n那么如果既想要比较 int 又想要比较 long long 还想比较 char 等等，如果按传统的写法，就是 Ctrl+C Ctrl+V 写好几个比较函数，还得重新命名，甚是麻烦。\n观察写出来的几个函数，肉眼可见他们的本质区别只有返回值与参数的类型。那么有没有一种类似模板的东西，写一个函数的主要部分作为模板，返回值、变量的类型由编译器决定呢？\n这就是 template 的一大作用，也是 OI 中最常用的方面。\n使用起来也很简单，在函数声明前面加上 template \u0026lt;typename T\u0026gt;，此处 T 可以是随便一个字母或者单词，后面写函数的时候把 int 替换成 T 即可。\ntemplate \u0026lt;typename T\u0026gt; T max(T a, T b) { return a \u0026gt; b ? a : b; } 此时的 T 相当于一个变量类型，如果这个函数被调用，编译器会给你生成一个符合传入参数的类型的 max 函数。\n当然了，如果是一个没有传参的函数，我们也能指定其类型。\n这样写会报错：\ntemplate \u0026lt;typename T\u0026gt; T read() { T a; cin \u0026gt;\u0026gt; a; return a; } int a = read(); 原因是没有传参进去，编译器无法推断模板函数的类型。\n类比 STL 容器 中的使用方法，能不能用尖括号带一个类型名称进去呢？可以的。\ntemplate \u0026lt;typename T\u0026gt; T read() { T a; cin \u0026gt;\u0026gt; a; return a; } int a = read\u0026lt;int\u0026gt;(); 这样写就不会报错了\n模板类 和模板函数类似，我们可以泛化结构体中的类型。\nstruct qwq { int age }; 存紫妈的年龄可能会爆 int，存阿求的年龄可能浪费 long long 的空间，于是可以：\ntemplate \u0026lt;class T\u0026gt; struct qwq { T age; }; qwq\u0026lt;int8_t\u0026gt; akyuu; qwq\u0026lt;__int128\u0026gt; yukari; 这样，akyuu.age 的类型即是 int8_t，yukari.age 的类型即是 __int128。\nTODO: ... 关键字 基于范围的循环 不过多介绍了，主要在 STL 里用\nfor (auto i : container) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } container 为容器的名称，auto 是 C++11 以后的类型名称，编译时由编译器推断。\n此处 auto 的效果就是把 i 的类型设置为 container 的元素的类型。如果 container 是 vector\u0026lt;int\u0026gt; ，则上面语句的效果就是遍历 container 的所有元素并输出。\n此外，如果想遍历的同时修改容器中的元素，可以在 i 前加取址符 \u0026amp; 表示引用，如下\nfor (auto \u0026amp;i : container) { i = 0; } 该段代码的效果即为遍历容器 container，同时把其中所有元素赋值为 0;\n函数相关 Lambda 表达式 实际上就是定义了一个函数。\n基本语法：\n[捕获](参数){ // some code... } 捕获一般没啥用，留空就好。\nLambda 表达式在 C++ 中是一个类型，但是不能用类型名定义，所以用 auto 声明。\n举个例子，编写 max 函数：\n原来是这样的\nint max(int a, int b) { return a \u0026gt; b ? a : b; } 用 Lambda 表达式长这样：\nauto max = [](int a, int b) { // 捕获部分留空，传参和内部实现不变 return a \u0026gt; b ? a : b; }; 看起来这两种方式没有什么区别，确实是这样，但是 Lambda 还有一个重要性质——匿名。\n显然，原来写函数的时候必须要声明，声明这个函数的名称，返回值类型，传参类型，内部实现。\n但是观察到上面声明 Lambda 表达式 max 的时候，使用的是类似变量赋值的方法。那是不是只留下等式右边的部分也可以当函数使用？实际上是可以的，这就是 Lambda 函数的匿名性质。即引入 Lambda 表达式之后，就可以随时随地定义函数而不给它起名字。\n听起来有点抽象，再举个例子：std::sort 原来我们想要自定义比较函数，只能这样：\nbool cmp(int a, int b) { return a \u0026gt; b; } ... std::sort(a.begin(), a.end(), cmp); 引入 Lambda 表达式之后：\nstd::sort(a.begin(), a.end(), [](int a, int b){return a \u0026gt; b;}); 在这里，我们并没有给比较函数起名字，就直接扔到了 std::sort 里面，这样做方便很多~\n读者可能有疑问：这样做效率如何？事实上，Lambda 表达式和下面的函数对象的效率都是比较高的，比第一种方式中 cmp 这种函数指针效率高。\n函数对象 假定你已经学会了类/结构体的运算符重载。\n观察函数组成 function()，它是不是非常像一个类型 function 搭配上了 () 这个运算符？太像了！\n那我们是不是可以这样做：开一个对象，重载 () 这个运算符再当函数用？当然可以。\n还是用 max 举例：\nstruct qwq { int operator() (int a, int b){ return a \u0026gt; b ? a : b; } }; qwq max; ... a = max(a, b); 非常自然，非常易懂。\n效率 懒得测了。\n可以参考下 这个博客\n利用如上链接内方式测试的结果是：差不多。\n","date":"2023-02-02T21:06:12Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/c++-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E6%9D%82%E8%B0%88%E4%B8%8E%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/","title":"C++ 语言特性杂谈与常数优化"},{"content":"update: 2023/6/7 重画图片（全部由 Krita + 鼠标 完成）\n求一个字符串最长的回文子串。 字面意思，回文就是一个串正着读倒着读一样，子串就是一个连续的子序列。\n预处理 不难发现对于一个回文字串，有两种情况：\n$\\texttt{ABBA}$ 即长度为偶数，没有中心字符，半径为 $2$，长度为 $4$ $\\texttt{ABCBA}$ 即长度为奇数，有中心字符，半径为 $3$，长度为 $5$ 懒得给他们处理两种情况，怎么办？只需要插入一些其他字符即可。\n比如说我们可以在头部插入一个 $\\texttt?$ 代表串开始，$\\texttt^$ 代表串结束，然后在新串的每一个字符之间插入一个 $\\texttt#$ 号，得到的新串就能达到简化情况的目的。\n按照上面的方法处理之后，原来的两个串会变为：\n（只观察回文子串）\n$\\texttt{?#A#B#B#A#^}$ 长度变为奇数，有中心字符，半径为 $5$，长度为 $9$ $\\texttt{?#A#B#C#B#A#^}$ 长度为奇数不变，有中心字符，半径为 $6$，长度为 $11$ 情况被简化成一种，即长度为奇数。与此同时我们发现，新串的回文子串的 半径 $-1$ 就是原串回文子串的 长度\n与此同时，问题不变，还是求串的最长回文子串。\nvoid init(std::string\u0026amp; b) { b += \u0026#39;$\u0026#39;; b += \u0026#39;#\u0026#39;; for (int i = 0; i \u0026lt; n; ++i) { b += a[i]; b += \u0026#39;#\u0026#39;; } b += \u0026#39;^\u0026#39;; n = b.size(); } Manacher 基本思想 抽象来说就是对于字符串的每一个位置，维护以这个位置为中心的最长回文串长度同时算出这个回文串的右边界，再通过这个右边界来更新下一个位置的最长回文串长度与右边界。\n具体来说，对于一个字符串 $S$，开一个数组 $P_i$ 记录以 $i$ 为中心的最长回文串半径（含 $S_i$），变量 $mid$ 为在 $i$ 之前边界最靠右的回文子串的中心，$mr$（也就是 $maxright$）记录这个回文子串的右边界，通过这些更新下一个位置的这些值。\n为了方便说明，以 $i$ 为中心的最长回文子串称为 $T_i$\n继承对称点的数据 当前状态：\n枚举到 $i$ 后，对于 $mr$ 和 $i$ 来说有两种情况：$i$ 在 $mr$ 内或在 $mr$ 外\n$i$ 在左侧 即 $i$ 被 $T_{mid}$ 包含。\n显然 $i$ 之前的 $P_k, k \u0026lt; i$ 都是已知的，$i$ 在 $mid$ 为中心的回文子串内，那么一定存在 $j$ 是 $i$ 关于 $mid$ 的对称点，想办法从 $P_j$ 推出 $P_i$，则\n那么 $P_j$ 已知，对于以 $j$ 为中心的最长回文子串 $T_j$ 来说有两种情况\n$T_j$ 被 $T_{mid}$ 严格包含，由 $T_{mid}$ 的回文性质可知，此时 $P_i$ 可以继承 $P_j$ 的值，剩下的后续再推。 $T_j$ 未被 $T_{mid}$ 严格包含 容易发现，两个青色串一定对称（$T_{mid}$ 的回文性质），又因为 $T_j$ 的回文性质，得到两个青色串，左青色串和橙色串分别对称。 此时 $T_i$ 一定被 $T_{mid}$ 严格包含。因为如果不被严格包含，则 $P_{mid}$ 的值仍可以增大，如下图\n图中蓝色块通过 $T_{mid}$ 串回文的性质已知相等，每个蓝色块均可以通过自身所在回文串推出其外侧橙色块也是相等的。\n显然这种情况不会出现，因为这种情况下 $P_{mid}$ 是一个假值，而以上递推过程的前提是前面的值保证正确。 $i$ 在右侧\n没有可以继承的值则可以直接重新推，不需要过多考虑。\nif (i \u0026lt; mr) { p[i] = min(p[(mid \u0026lt;\u0026lt; 1) - i], mr - i); } else { p[i] = 1; } 更新 $P_i$ 直接从当前记录的半径向外继续枚举，直到遇到两个不相同的字符为止（边界上有 $ ^，枚举到一定会停止，所以不用考虑边界问题）。\nwhile (b[i - p[i]] == b[i + p[i]]) { ++ p[i]; } 更新 $mr$ 和 $mid$ 前文说过 $mr$ $mid$ 都是边界最靠右的回文子串的属性，那么只需要判断新找到的回文子串右边界是否大于 $mr$ 即可。\nif (i + p[i] \u0026gt; mr) { mr = i + p[i]; mid = i; } 至此 Manacher 算法主要过程结束。\n实现 void init(std::string\u0026amp; b) { b += \u0026#39;$\u0026#39;; b += \u0026#39;#\u0026#39;; for (int i = 0; i \u0026lt; n; ++i) { b += a[i]; b += \u0026#39;#\u0026#39;; } b += \u0026#39;^\u0026#39;; n = b.size(); } void manacher() { int mr = 0, mid; for (int i = 1; i \u0026lt; n; ++i) { if (i \u0026lt; mr) { p[i] = min(p[(mid \u0026lt;\u0026lt; 1) - i], mr - i); } else { p[i] = 1; } while (b[i - p[i]] == b[i + p[i]]) { ++p[i]; } if (i + p[i] \u0026gt; mr) { mr = i + p[i]; mid = i; } } } 时间复杂度1 当 $P_j$ 左侧取到左边界及以外时，$P_i$ 才需要更新（其他情况都因为不满足条件而不用进循环），而右端点是单调递增且严格小于等于 $n$ 的，因此总时间复杂度为 $\\operatorname{O}(n)$\n参考谷雨的笔记\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-31T20:27:12Z","image":"https://pic.imgdb.cn/item/648050fa1ddac507ccea1002","permalink":"https://blog.tibrella.top/notes/%E4%B8%B2/manacher/","title":"Manacher"},{"content":" 树状数组代替线段树。 —— zzz《常数优化与 NOILinux》\n顾名思义，树状数组是一种树形结构，但是因为他独特的结构和拆分方式（二进制你又来了是吧），可以直接用数组存储。\n用途是解决大部分区间修改查询问题，复杂度一般是 $\\operatorname{O}(\\log n)$ ，同时常数小（暗示 线段树 不行），同时码量小，好理解（暗示 * 2），但是复杂的区间修改查询问题不能解决，同时区间最大最小值也不能用它处理（后文会说）\nUpdate on 2023/6/7 本质上就是能够以极小的常数且严格 $\\operatorname{O}(\\log n)$ 的时间复杂度进行单点修改与前缀和的维护，不过这个前缀和可以玩得比较花。\n实际上原理看看就得了，这玩意板子写完了半年过去都不带忘的\u0026hellip;\n关于常数差距到底多大？S2 的同学们可以看看 S2OJ # 786，使用普通快读仅 2.60s（现在最快的我的提交记录是卡常版的），线段树解法貌似最快的是 lyq 学长的 6.69s。\n基本树状数组 原理 来自学长的一张图\n注意下文基本上所有东西都可以/需要搭配这个图进行理解\n以求区间和的树状数组为例，树中每一个节点存储一段区间的和，询问时进行前缀和加减即可得出任意区间的和。\n分区间的方法即利用二进制，对于第 $i$ 节点来说，$i$ 的二进制形式中最低一位 1 的位置为 $x$，那么 $tree_i$ 就存储了 $[i-2^x+1,i]$ 区间的和。\n注意此处 $x$ 从 0 开始算\n以 $3$ 为例，$3$ 的二进制为 0000 0011，最低一位 1 的位置是 0，则 $tree_3$ 存储 $[3-1+1,3]$ 即 $[3,3]$ 的区间和。\n再以 $8$ 为例，$8$ 的二进制为 0000 1000，最低一位 1 的位置是 3，则 $tree_8$ 存储 $[8-8+1,8]$ 即 $[1,8]$ 的区间和。\n实现 建立 实际上不用特意处理建立，直接在输入过程中每输入一个数就修改即可。\nfor (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; t1; // tmp modify(i,t1); } lowbit 本函数实现查找一个数最后一位 $1$ 的位置。\n首先声明一个冷知识（大概冷），位运算是针对内存中存储的原数据的运算，换句话说，进行位运算的是补码而不是原码。\n原码即一个数本身的二进制表示，反码即在原码的基础上符号位不变其他位取反。\n补码分类来说，正数的补码是它的原码，负数的补码为其反码$+1$。\n在这里我们只考虑最后一位 1 及它后面的 0。\n比如 0011 0100 这个二进制数，我们先把它变成负数，即按位取反后加一（易证这就是他的相反数），变为 11001011 再变为 11001100。\n发现了一件神奇的事情，原来最低一位 1 竟然回来了！\n显然，这位 1 前面的所有数字因为被取反所以和原数完全不同；后面的所有数字原来一定是 0 取反后变成一排 1，负数的补码是反码$+1$，从而一直进位到原来最后一位 1 这里，而它们本身变回了 0 ；又因为这位 1 被取反后是 0 所以无论如何都不会再向前进位。\n从而保证对于任意一个正数 $x$，$-x$ 与 $x$ 的存储只有 $x$ 本身最后一位 1 是相同的。\n因此 lowbit() 的实现就非常简单了，直接用 x\u0026amp;-x，得到的结果就是原理中所说的 $2^x$，又快又好想，用着还方便。\nint lowbit(int x) { return (x\u0026amp;-x); } 单点修改 假设修改为给第 $x$ 个数增加 $v$，那我们就需要修改所有包含第 $x$ 个元素的节点，则从第 $x$ 个节点寻找父亲节点直到根节点为止（参考上图）。\n$x$ 节点的直接父亲是 $x+\\operatorname{lowbit}(x)$，因此直接一层循环实现 $\\operatorname{O}(\\log n)$ 修改。\nvoid modify(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) { tree[i] += v; } } 区间查询 查询区间为 $[l,r]$ 时，将问题转化为求 $[1,r] - [1,l-1]$ 的值（前缀和知识），因此我们只需要实现查询前缀和的功能即可。\n因为 $i$ 节点存储的是一段长度为 $\\operatorname{lowbit}(i)$ 的区间的和，因此取完 $i$ 号点的值后再取 $i-\\operatorname{lowbit}(i)$ 号节点的值，直到位置变为 $0$（到头）即可（看不懂就结合上面图）\nint query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) { res += tree[i]; } return res; } ans = query(r) - query(l-1); 改区间查单点 上文我们解决了求前缀和的问题，本次需要查询单点，那么很容易联想到差分。更改区间对应改差分数组上的两个点，查询单点对应查询差分数组的前缀和。\n区间加区间求和 发现树状数组好快于是回来补一下（2023.6.23）\n对原数组进行差分，易得：\n$$ d_i = a_i - a_{i-1} \\\\ a_i = \\sum_{j=1}^i d_i \\\\ $$\n取 $[1,x]$ 的区间和，即为：\n$$ \\begin{aligned} ans \u0026amp;= \\sum_{i=1}^x a_i \\\\ \u0026amp;= \\sum_{i=1}^x\\sum_{j=1}^{i} d_i \\\\ \u0026amp;= \\sum_{i=1}^x d_i(x-i+1) \\\\ \u0026amp;= \\sum_{i=1}^x(1+x)d_i-\\sum_{i=1}^x i\\cdot d_i \\end{aligned} $$\n第二行到第三行那里不知道怎么推出来的话，观察每个 $d_i$ 出现的次数，显然 $d_1$ 出现 $x$ 次，$d_2$ 出现 $x-1$ 次（除了 $i=1$ 的时候都出现了），于是轻松推出来。\n因此我们只需要维护两个树状数组，一个维护 $d_i$ 即差分数组，另一个维护 $i\\cdot d_i$ 即可。\n注意：此处树状数组维护的仍然是前缀和，$i\\cdot d_i$ 中的 $i$ 就是修改的位置，而不是树状数组修改时循环的 $i$。\n核心代码：\n#define N 100005 i64 id[N], d[N]; i32 n; inline void mod(i32 pos, i64 val) { for (i32 i = pos; i \u0026lt;= n; i += lowbit(i)) { id[i] += pos * val; d[i] += val; } } inline i64 que(i32 pos) { i64 res = 0; for (i32 i = pos; i; i -= lowbit(i)) { res += d[i] * (pos + 1) - id[i]; } return res; } inline void modify(i32 l, i32 r, i64 val) { mod(l, val); mod(r + 1, -val); } inline i64 query(i32 l, i32 r) { return que(r) - que(l - 1); } ","date":"2023-01-29T14:12:27Z","image":"https://pic.imgdb.cn/item/63d613b2face21e9ef36c9df.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","title":"树状数组"},{"content":"目标是解决 RMQ 问题，即对于一个大区间，短时间内查询一个小区间的最大最小值\n下文以最大值为例说明\nST 表本质上是一个动态规划（倍增的）\n先利用倍增（二进制拆分）预处理然后 $\\operatorname{O}(1)$ 查询，比线段树快，但是只支持静态区间\n原理 预处理 $f_{i,j}$ 表示从 $i$ 开始，长度为 $2^j$ 的区间中的最大值\n预处理阶段，对于 $f_{i,j}$ 来说，直接 $$ \\max{ f_{i,{j-1}},f_{i+2^{j-1},j-1} } $$ 递推即可，非常容易想，时间复杂度为 $\\operatorname{O}(n\\log n)$\n查询 对于一个区间 $[L,R]$ 来说，假设他的长度为 $len$\n很容易能找到一个 $k$ 使得 $$ \\frac{len}{2} \u0026lt; 2^k \\leqslant len $$\n显然 $[L,R]$ 被 $[L,2^k],[R-2^k-1,k]$ 严格包含，因此 ST 表中查询最大最小值的时间复杂度是常数级别的，而不是线段树的 $\\log$ 级别\n查询结果就是 $\\max {f_{L,2^k},f_{R-2^k-1k,k}}$\n至于 $k$，肉眼可见 $k=\\lfloor\\log _2 (len)\\rfloor$\n此处可以直接使用 cmath 库中的 log() 函数，它是用来求以 10 为底的对数的 根据换底公式1可知 $$k=\\lfloor\\log_2(len)\\rfloor=\\lfloor \\frac{\\lg(len)}{\\lg2} \\rfloor$$\n实现 首先是初始化\nfor (int j = 0; j \u0026lt; M; ++j) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; ++i) { if (!j) { f[i][j] = w[i]; // 从 i 开始长度为 2^0=1 的区间最大值为 i 本身 } else { f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } } } 然后是查询\nint query(int l, int r) { int len = r - l + 1; int k = log(len) / log(2); return max(f[l][k], f[r - (1 \u0026lt;\u0026lt; k) + 1][k]); } 动态修改 这个标题比较诡异，因为我提到过\n只支持静态区间\n但是实际上我们可以用一些小 trick 实现在 st 表的尾部增加值。（前提是题目要求比较少，比如目前这道题只需要在尾部增加数，同时只需要查询尾部某长度区间的最值）\n显然对于 st 表的每一个 $f_{i,j}$ 来说，他只会用到 $f_{k,j}$,$k\u0026gt;i$ 的值而不会用到前面的值，因此我们给他做一个倒转。\n换句话说，现在 $ f_{i,j} $ 表示从 $ i $ 开始，向前长度为 $ 2^j $ 的区间中的最大值。\n代码如下\nvoid add(int a) { a += t; a %= d; ori[++tail] = a; for (int j = 0; tail - (1 \u0026lt;\u0026lt; j) + 1 \u0026gt; 0; ++j) { if (!j) { f[tail][j] = a; } else { f[tail][j] = max(f[tail][j - 1], f[tail - (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } } } void query(int len) { int l = tail - len + 1; int k = log2(len); t = max(f[tail][k], f[l + (1 \u0026lt;\u0026lt; k) - 1][k]); } $ \\log_xy=\\frac{\\log_cy}{\\log_cx} $\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-27T14:22:33Z","image":"https://pic.imgdb.cn/item/63d4c785face21e9efa61b8e.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/rmq-%E9%97%AE%E9%A2%98/","title":"RMQ/ST表"},{"content":"今天讲的最短路啥的感觉有点费劲，先把并查集的东西写了\n用途 基本上用来处理 关系\n什么是关系？比如一个人和他的表弟是亲戚，亲戚的关系可以人为理清， 但是毒瘤的出题人会给这个人安上 114514 个表弟这些表弟的 1919810 个其他亲戚以及 1145141919810 个其他无关的人，然后问你这个序列里面第 $a$ 个人和第 $b$ 个人是不是亲戚，一般的方法显然处理不了，而并查集就是专门用来解决这种东西用的。\n实现 “并查集”的操作就是前两个字，即合并与查询。\n此处默认以树实现并查集。\n合并 合并的操作即把两棵树的根节点连接在一起，文字解释不清楚，但是直接用树结构实现就比较清楚了。\n这里我们只需要开一个数组 $F$ 存储每一个节点的祖先，每次更改 $i$ 节点的祖先只需要修改 $F_i$ 的值\n比如目前我们有五个点\n然后由输入数据可知，1 和 3，2 和 4，5 和 4，4 和 1 是亲戚，于是我们把 1 设为 5 的祖先来表示他们的关系， 2 4 同理，相当于把这四个集合（或者说树）两两合并\n下一步\n以及把以 4 为根的这棵树合并到 1 上，连接他们的根节点\n这样我们就基本完成了这个集合的初始化，我们只需要再把根节点 1 的祖先设置为自己，来表示它是这棵树的根节点（应该在合并之前初始化每一个结点的祖先为自己，因为图可能会不太清楚所以改到这里了）\n代码实现思路就很清楚了\nvoid uni(int x, int y) { // 查询两个节点所在树的根 xx = find(u); yy = find(v); if (xx != yy) f[xx] = yy; //连接根节点 } /* ... int main() { ..... cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; // m 为人数，n 为关系数 int f[m+10], u, v; int p,q; memset(f,0,sizeof 0); for (int i = 1; i \u0026lt;= m; ++i) { f[i] = i; } ... } */ 查找 假如我们需要查找上一张图里面 2 3 是否是亲戚，如何操作呢？\n很容易发现，2 3两个节点在同一棵树中，也就是说我们可以直接查找这两个节点的根节点，如果相同则是亲戚。查找的实现也很简单，直接递归寻找上一级的父亲节点，如果一个节点的祖先是自己，就直接输出这个节点即可\n// 查询 pos 的根 int find(int pos) { if (f[pos] == pos) return pos; // 边界 return find(father[pos]); } 优化 由上文可以发现，在并查集中查找一个节点的祖先最坏情况下的时间复杂度是 $O(h)$ 的（$h$ 为树的最大深度），那么就可以通过减小最大深度来优化并查集。\n按树的大小合并 假如说我们有这样两棵树\n现在 1 5两个节点是亲戚，那么把 5 的祖先设为 1 合适还是反过来合适呢？\n显然是前者\n如果按照前者合并，结果就是\n最大深度是 3\n如果按照后者合并，最大深度为 4\n也就是说，为了让 $h$ 尽可能地小，需要把深度/体积小的树合并到深度大的树上，作为大深度/体积树的子树\n此处定义一个 $R$ 数组记录以 $i$ 为根节点的树的最大深度为 $R_i$ （$R$ 的修改在初始化/添加关系时修改）\nvoid uni(int x, int y) { int xx = find(x); int yy = find(y); if (xx == yy) return; // 在同一棵树中不需要合并 if (r[xx] \u0026gt;= r[yy]) { f[yy] = xx; r[xx] = max(r[xx],r[yy]+1); // 可能合并后 y 树深度 +1 大于 x 树最大深度 } else { f[xx] = yy; r[yy] = max(r[yy],r[xx]+1); } } 路径压缩 以上两棵树显然右侧的树更优，因为它的最大深度更小\n并查集的查询方式为“查询根节点”，这意味着我们查询时只需要关注查询最终的根节点，而不用关心查询途中经过的节点，这就是路径压缩的原理。路径压缩即把一个没有连着根的节点（如上图左侧的4 5 6 7），“跳过”所有中间节点，直接把它连到根节点上。\n对于上图来说，就是把 4 5 6 7 摘出来连接到 2 3 的父节点上，即 1，于是形成了右图，最大深度从 2 降到了 1。 由于并查集相关的题目中可能初始化之后仍然有需要增删的元素，同时路径压缩也需要耗费时间，所以我们只在查询需要的点时优化。\nint find(int x) { if (x != f[x]) { // 如果 x 不是根节点 f[x] = find(f[x]); } return f[x]; } 新的查询函数可以结合上图理解。\n","date":"2023-01-17T15:11:36Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"并查集"},{"content":"图论是嗜血分支1，相应的，图论基础并没有什么太多需要思考的东西，只有一堆该死的概念等着记，有如绳之以法抽象了\n基本概念 图 由顶点（点）（Vertex）的集合和边（Edge）的集合组成，记为 $\\mathbb{G} = (\\mathbb{V}+\\mathbb{E})$\n点的集合用 $\\mathbb{V(G)}$ 表示，点用 $u,v$ 等符号表示\n顶点的数量称为图的“阶”，用 $n$ 表示\n边的集合用 $\\mathbb{E(G)}$ 表示，边用 $e$ 等符号表示\n边的个数称为图的“边数” 感觉说了和没说一样，用 $m$ 表示 分量：一个图的子图（涉及：强连通分量）\n图的种类 从 $u$ 到 $v$ 的无向边： $(u,v)$\n从 $u$ 到 $v$ 的有向边：$\\langle u,v \\rangle$\n有向图：图的所有边都是有向边\n无向图：图的所有边都是无向边\n完全图：每个点都与其他所有顶点连接；对于有向图来说，任意顶点 $u,v$ 都有边 $\\langle u,v \\rangle \\langle v,u \\rangle$\n稀疏图/稠密图：边少/多的图\n平凡图：一个点的图\n零图：没有边的图\n度 对于顶点 $v$ 来说\n入度 $ID(v)$：以 $v$ 为终点的边的个数\n出度 $OD(v)$：以 $v$ 为起点的边的个数\n度 $D(v)$ = 入度 + 出度\n度为奇数的点为奇点，度为偶数的顶点为偶点\n于是可得：对于图 $\\mathbb{G}$ 中所有顶点的度=边数的两倍\n以及推论：一个图中的奇点数量为偶数\n简短证明：\n每条边一定贡献一个出度一个入度共两个度 度一定是偶数所以奇点的数量为偶数（奇$\\times$偶$=$偶） 存图 无向图可以看作有向图但是两个点之间互相有一条有向边，所以只需要考虑有向图存图\n邻接矩阵 基本思想是存两个点之间的边权（不连接即为 0 或 -1）\n比如当前图有四个点，则开数组 g[5][5]，初始化为 0。\n1 2 3 4 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4 0 0 0 0 然后 1 到 2，3 到 1 有一条有向边，边权为 1，则修改 g[1][2] g[3][1] 为 1\n1 2 3 4 1 0 1 0 0 2 0 0 0 0 3 1 0 0 0 4 0 0 0 0 非常容易理解，缺点也显而易见，如果有 $114514$ 个点但是只有 $1$ 条边，那就需要开 $114514^2$ 的空间但是只有一个位置有数据，显然造成了巨大的浪费（空间早就炸了）\n因此需要寻找一个只存边的存图方案，从而诞生邻接表\n邻接表 考虑一件事情，对于一个图来说，有两个元素：点、边，而点的相关要素可以通过数组来以点为单位存储。\n考虑存边：边的要素有三个，即起点、终点以及边权。考虑把边看作一个对象存储。\n链式前向星 用链表实现的邻接表\n先说链表，顾名思义，链状链接的列表，在这里我们把同一个起点边存到一个链表里。\n开一个结构体存链的每一个元素\nstruct edge { int data; int to; edge *nex; }; 显然，把链表每一个部分连接起来的东西就是指针 nex，nex 指向当前元素的下一个元素的地址。 当然，如果开一个数组存储所有的元素，地址可以改为存储下标，即 nex 可以是一个整数，存储下一个元素在数组里的下标。\n数学，来自 GrainRain谷神\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-15T14:05:20Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/","title":"图论基础"},{"content":"ZFSBootMenu 基础使用 和这篇文章的最后部分相同。 本方案已经被实际测试过，完全可用，但是建议在有 Linux 基础的情况下折腾 ZFS，因为没准有某个地方我会忘记修改\u0026hellip;\n总览 分区大概长这样\n分区1 300M FAT16 EFI 分区2 128G ZFS ArchLinux 分区3 128G NTFS Windows 分区N **G **FS DATA // 其他分区 然后 ZFS 池里面长这样\nzroot ├─ROOT | ├─voidlinux // 实际上可以在这个池里安装多个 Linux，本处计划把所有 Linux 根分区数据集放在 zroot/ROOT/ 里 | └─archlinux └─data └─home // 存放 /home ZFS池那块看不懂没关系，只需要跟着文章做就行\n安装前 准备一个有 ZFS 支持的 archiso，这里我们提供两个方案\nCachyOS LiveCD（推荐） 从 CachyOS 的 Sourceforge 界面 下载带 GUI 的 LiveCD（它的 CLI 安装器没 ZFS 支持），然后扔进 U 盘重启进入即可\nsudo modprobe zfs # 加载 ZFS 模块 sudo su # 切换到 root 用户 timedatectl set-ntp true # 同步时间 vim /etc/pacman.d/mirrorlist # 改镜像站 # 开头添加 Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch archiso-zfs 此处使用 eoli3n 的 archiso-zfs 项目\n首先下载一个官方的 ArchLinux LiveCD，然后重启进入\n联网 iwctl # 进入 iwctl 命令行界面 下面的命令在 iwctl 中输入\ndevice list # 列出可用设备 # 假设上面列出的设备是 wlan0 station wlan0 scan station wlan0 connect SSID # 连接名为 SSID 的网络 exit 验证联网\nping www.baidu.com timedatectl set-ntp true # 同步时间 加载 ZFS 模块 curl -s https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x 如果连接 github 有问题，则运行下面的命令替代\ncurl -s https://ghproxy.com/https://raw.githubusercontent.com/eoli3n/archiso-zfs/master/init | bash -x 执行过程因为网络原因会比较慢\n改镜像站 vim /etc/pacman.d/mirrorlist # 开头添加 Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch 至此，环境准备完毕，下面的操作不受 livecd 影响\n格式化 此处认为你已经分好区了，总体需要三个分区\nESP（EFI） 分区，300M，打了 ESP 标签（可以用 cfdisk 打），此处举例为 /dev/nvme0n1p1 Linux 分区（ZFS池），30+G，此处举例为 /dev/nvme0n1p2 Windows 分区（如果不需要安装 Windows 就不用建），40+G，此处举例为 /dev/nvme0n1p3 创建 ZFS 池 ashift = 12 代表 4096 字节扇区大小，9 代表 512 扇区大小，13 代表 8192 字节扇区大小，在 4096/8192 扇区大小的 SSD 上设置 9 会导致性能损失，在 512 字节扇区大小的硬盘上设置 12/13会导致容量损失，扇区大小可以通过 fdisk -l（不准）或者 diskgenius 这类工具查看\ndedup=on 为去重功能，可能会占用较大 RAM，低配机子可以把这行删掉\ncompression=zstd 为压缩功能，zstd 目前来看压缩率和性能损失比较平衡，在意性能可以改为快速压缩算法 lz4（gzip 压缩率和性能都比不上 zstd）\n其他照做即可\nzpool create -f -o ashift=12 \\ -O acltype=posixacl \\ -O relatime=on \\ -O xattr=sa \\ -O dnodesize=legacy \\ -O normalization=formD \\ -O mountpoint=none \\ -O canmount=off \\ -O devices=off \\ -O compression=zstd \\ -O dedup=on \\ -R /mnt \\ zroot /dev/nvme0n1p2 创建数据集\nzfs create -o mountpoint=none zroot/data zfs create -o mountpoint=none zroot/ROOT zfs create -o mountpoint=/ -o canmount=noauto zroot/ROOT/archlinux zfs create -o mountpoint=/home zroot/data/home 测试zpool是否能够导入导出\nzpool export zroot zpool import zroot -R /mnt 挂载zpool\nzfs mount zroot/ROOT/archlinux zfs mount -a 设置启动数据集\nzpool set bootfs=zroot/ROOT/archlinux zroot 设置zpool缓存\nzpool set cachefile=/etc/zfs/zpool.cache zroot mkdir /mnt/etc mkdir /mnt/etc/zfs cp /etc/zfs/zpool.cache /mnt/etc/zfs/zpool.cache 查看是否有挂载上\ndf -h 输出\nzroot/ROOT/archlinux 30G 128K 30G 1% /mnt 格式化 EFI 分区 注意此处挂载点不可以设置成 /boot！1\nmkfs.vfat /dev/nvme0n1p1 mkdir /mnt/efi mount /dev/nvme0n1p1 /mnt/efi 安装 这部分需要你在 /etc/pacman.conf 里添加 archzfs 源或者按照一刀斩的博客配置 CachyOS 源，此处不再赘述\n安装基本软件包 如果是 Intel 的 CPU 就把 amd-ucode 换成 intel-ucode\n此处使用 zfs-linux 包有可能会因为版本不相同然后挂掉，所以如果你添加了 CachyOS 的软件源，那么我推荐你使用 CachyOS 的自定义内核（它的内核和 zfs 模块同时编译打包，就不会出现版本不统一的问题）（最主要还是因为安装 zfs-linux 还得启用 v3 源），有多种任务调度器可选，比如 BMQ PDS TT 等，还有 LLVM LTO 编译的版本\n使用 CachyOS 内核的话直接改包即可，比如我想用 linux-cachyos-pds，那么把下面 linux linux-headers zfs-linux 换成 linux-cachyos-pds linux-cachyos-pds-headers linux-cachyos-pds-zfs 即可\n如果你不想用 CachyOS 的内核，也不想因为 zfs 模块和 linux 内核版本不统一而滚挂，那么可以使用 dkms 模块，把 zfs-linux 替换为 zfs-dkms 即可，这个的缺点是构建 dkms 模块时会风扇狂转（理论上任何内核都可以用这个当 zfs 内核模块）\npacstrap /mnt base linux-firmware linux linux-headers zfs-linux base-devel neovim os-prober amd-ucode openssh wget networkmanager zfs-utils 基础安装 # 配置 /etc/fstab genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab # 验证 /etc/fstab cat /mnt/etc/fstab # chroot 进 ArchLinux arch-chroot /mnt # 设置zpool缓存 zpool set cachefile=/etc/zfs/zpool.cache zroot # 设置时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc date # 设置语言 echo -e \u0026#34;\\nen_US.UTF-8 UTF-8\\nzh_CN.UTF-8 UTF-8\\nzh_TW.UTF-8 UTF-8\u0026#34; \u0026gt;\u0026gt; /etc/locale.gen # 应用配置 locale-gen # 设置默认语言 echo -e \u0026#34;\\nLANG=en_US.UTF-8\\n\u0026#34; \u0026gt;\u0026gt; /etc/locale.conf # 设置root密码 passwd # 添加非 root 用户 pacman -S fish # 如果不想用 fish 可以跳过这一步并把下一步的 fish 字段换成 bash useradd -m -G wheel -s /bin/fish user # user 替换为你的用户名 passwd user # 设置密码 sed -i \u0026#34;s|#%wheel ALL=(ALL) ALL|%wheel ALL=(ALL) ALL|g\u0026#34; /etc/sudoers # 添加 sudo 权限 # 添加 multilib 和 archlinuxcn 仓库 arch=\u0026#39;$arch\u0026#39; echo -e \u0026#34;\\n[multilib]\\nInclude = /etc/pacman.d/mirrorlist\\n\\n[archlinuxcn]\\nServer = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch\u0026#34; \u0026gt;\u0026gt; /etc/pacman.conf 配置内核钩子 重点部分！ 编辑 /etc/mkinitcpio.conf，直接在 HOOKS=(......) 里面加上 zfs\nnvim /etc/mkinitcpio.conf HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck) 编辑完直接借用 ArchLinux 的极为人性化的脚本生成即可\nmkinitcpio -P 设置 zfs 服务以及网络管理服务 systemctl enable zfs.target systemctl enable zfs-import-cache systemctl enable zfs-mount systemctl enable zfs-import.target systemctl enable sshd systemctl enable NetworkManager 配置 ZFSBootMenu 引导 （需要在 chroot 中完成）\n重点部分！\n详细了解可以看我之前那篇在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）\n在这里我们使用预构建好的 EFI 文件因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核\n首先下载预构建好的 ZBM efi 引导文件 （访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/）\nmkdir /efi/EFI mkdir /efi/EFI/ZBM wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi 再进行一个简单的配置\nzfs set org.zfsbootmenu:commandline=\u0026#34;rw\u0026#34; zroot/ROOT 这样就做到了启动（如果没有双启动的需求没必要进行下一步了）\n配置 rEFInd 以实现与 Windows 双启动 安装 refind\npacman -Sy refind git refind-install 这样重启之后就能双启动了\n但是你还可以美化一下，安装 nord 主题（非必要）\npacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst 结束 退出 chroot\nexit 解挂载\numount /mnt/efi zfs umount zroot/ROOT/archlinux zfs umount -a 导出 zfs 池\nzpool export zroot （导出没成功也没关系，直接重启即可） 重启\nreboot 然后你的 archlinux 就可以正常使用了\n后记 还是在年前完成了虚拟机上的测试，能够完美安装，原来写的还是有点低级错误的\nHyper-V 上安装可能会涉及到 pacman 检测不到架构之类的问题，因此启用 archlinuxcn 源需要你在 /etc/pacman.conf 改 Architecture = auto 中的 auto 为你的架构，如 x86_64 x86_64-v3\n另外不启用 CachyOS-v3 源，只启用 CachyOS 源也可以安装 CachyOS 的优化内核，但是没有 lto 版本\n以及我个人宣布，这是本博客 2022 年的最佳博文\n原因是 ZFSBootMenu 需要从 /boot 加载内核，而 ZBM 的 initramfs 启动时大概不会挂载 ESP 分区（我之前这么干寄了\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-15T19:46:43Z","image":"https://pic.imgdb.cn/item/639b2768b1fccdcd36e13360.jpg","permalink":"https://blog.tibrella.top/notes/linux/%E5%9C%A8%E5%90%AF%E7%94%A8-zstd-%E5%8E%8B%E7%BC%A9%E7%9A%84-zfs-%E6%A0%B9%E5%88%86%E5%8C%BA%E4%B8%8A%E5%AE%89%E8%A3%85-archlinux-%E5%B9%B6%E9%85%8D%E7%BD%AE-windows-%E5%8F%8C%E5%90%AF%E5%8A%A8/","title":"在启用 ZSTD 压缩的 ZFS 根分区上安装 ArchLinux 并配置 Windows 双启动"},{"content":"前言 写这篇博客的缘由挺简单的，当时 ClearArch 开发组讨论文件系统应当使用 ZFS 还是 F2FS，由于使用过 F2FS 作为根文件系统（它没有 Windows 下的驱动，透明压缩也不会提供额外的空间），同时查到企鹅大大的一篇文章，看到近 2x 的压缩率不禁心动，随后走上了 ZFS+zstd 作为根文件系统的折腾之路\n企鹅大大使用 SysLinux 引导，我在服务器尝试安装结果无法启动；看到 CachyOS 的仓库中有一个打了 ZFS+zstd 支持补丁的 grub，尝试，启动不了（后来询问了 CachyOS 的开发团队得知那个补丁是不起效果的），随后，我遇到了一个完美的解决方式（指 eoli3n 的使用 ZFSBootMenu 的安装脚本）（如果想实机全盘单系统可以直接用他的安装脚本）\n本文的目的是用 ZFSBootMenu 引导 zstd 压缩的 ZFS 文件系统根目录，同时附带双启动教程\nZFSBootMenu 介绍 官方仓库 介绍：\nZFSBootMenu 是用于 root-on-ZFS 系统的 ZFS 引导加载程序，支持快照和本机全盘加密\n其原理比较容易理解，总的来说：\n引导 ZFSBootMenu，他是一个 initramfs 映像 找到并导入所有的 ZFS 存储池，然后挂载用户选择的根数据集 用 kexec1 将系统内核、initramfs 映像加载到内存中 卸载所有 ZFS 数据集 启动最终内核 总之，它能启动以 ZFS 为根目录的 Linux，速度不慢，适用环境广，是作为本文环境下引导器的不二之选\n准备 确保你的电脑为 UEFI 启动，且已经分区完成，建立了根分区相应的子数据集\n[ -d /sys/firmware/efi] \u0026amp;\u0026amp; echo UEFI || echo BIOS 输入该命令，若输出 UEFI，则可以进行下一步，否则退出本教程。\n挂载 ESP 分区 ESP 分区一般是磁盘头部 300M 左右的 FAT16/32 分区，同时有 EFI System 标记，可以通过 fdisk -l 查看各个分区的标记\n此处挂载点绝对不可以是 /boot，一般来说有两个其他选择：/boot/efi 和 /efi，我在这里选择了 /efi\n例如我的 ESP 分区是 /dev/nvme0n1p1 则\nmkdir /mnt/efi mount /dev/nvme0n1p1 /mnt/efi 设置 ZFS Hook # 先 arch-chroot arch-chroot /mnt # 进入后编辑 /etc/mkinitcpio 加入 zfs 支持，在 HOOKS=(.......) 中加入 zfs vim /etc/mkinitcpio # 比如正常安装的 arch 修改后应该长这样，确保其中有 zfs 即可 HOOKS=(base udev autodetect modconf block zfs filesystems keyboard fsck) # 编辑后加载 mkinitcpio -P 安装 ZFSBootMenu 在这里我们使用预构建好的 EFI 文件因为我没玩明白ZFSBootMenu，经常出现换内核再构建就会炸引导的问题，同时不能做到启动时换内核\n# /efi 换成你的 ESP 挂载目录 mkdir /efi/EFI mkdir /efi/EFI/ZBM wget https://github.com/zbm-dev/zfsbootmenu/releases/download/v2.0.0/zfsbootmenu-release-vmlinuz-x86_64-v2.0.0.EFI -O /efi/EFI/ZBM/zfsbootmenu.efi # 访问不了可以把 https://github.com/ 换成 https://ghproxy.com/https://github.com/ # 配置 # 此处假设你的根目录的数据集为 zroot/ROOT/arch # 这样可以引导 zroot/ROOT 下的任意子数据集，比如 zroot/ROOT/arch 上安装 arch，zroot/ROOT/void 上安装 voidlinux，这就实现了 Linux 的双启动 zfs set org.zfsbootmenu:commandline=\u0026#34;rw\u0026#34; zroot/ROOT 配置 rEFInd rEFInd 能够每次开机都搜索 EFI 分区下的 efi 文件，这样就不用更新引导文件了，同时插启动盘的时候也不需要进 bios 里调启动顺序，rEFInd 会自动搜索到\n# 假设当前还在 chroot 里 pacman -Sy refind refind-install 非常简单，这样就实现了 Windows/macOS(HFS+) 与 Linux on ZFS 的双启动\n# 安装 nord 主题 pacman -U https://mirror.cachyos.org/repo/x86_64/cachyos/refind-theme-nord-1.1.0-1-any.pkg.tar.zst TODO 实验并整理整个安装流程\nkexec 是 Linux 内核的一种机制，它允许从当前运行的内核启动新内核。kexec 会跳过由系统固件（BIOS 或 UEFI）执行的引导加载程序阶段和硬件初始化阶段，直接将新内核加载到主内存并立即开始执行。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-11-28T16:32:35Z","image":"https://pic.imgdb.cn/item/63a8671208b683016397a5d0.jpg","permalink":"https://blog.tibrella.top/notes/linux/zfsbootmenu-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","title":"在 UEFI ArchLinux 下使用 ZFSBootMenu 作为引导器（可双启动）"},{"content":"闪击线段树\n基本线段树 操作 push_up() 通过子区间计算父区间的数据\nbuild() 将一段区间初始化成线段树\nmodify()\n修改单点数据 修改区间数据 (即 push_down()) query() 查询\npush_down() 修改区间数据并递归修改子区间的数据\n原理 还是用图理解\n简单来说就是把一个区间整成类似上图的完全二叉树，父节点（区间）的数据可以由子节点（区间）的数据推出（如区间最大值，区间和等），同时父节点的更改可以推到子节点里。\n可能有点抽象，但是把操作挨个解释就比较易懂了。\n存储节点 使用结构体感觉比较清晰，配上指针就能脱离中括号的束缚了\nstruct Node { int u; int v; Node *lc, *rc; int l, r, mid; int lazy; // 懒标记 void init(int L, int R) { l = L; r = R; mid = l + r \u0026gt;\u0026gt; 1; } } tr[N * 4]; 同时 mid 是需要用到的变量，我这里选择直接存在里面，同时写一个初始化函数，直接传进去区间的左右端点，非常方便。\n建立线段树 第一层区间为 $[l,r]$\n取 $mid = \\lfloor \\frac{l+r}{2} \\rfloor $\n则第二层的区间分别是 $[l,mid], [mid+1,r]$\n目前节点为 $u$，线段树数组为 $tr$，build() 函数如下\nvoid build(Node* nod, int L, int R) { nod-\u0026gt;init(L, R); // 记录区间范围 if (L == R) { // 到达叶子节点就回溯 nod-\u0026gt;v = ori[L]; nod-\u0026gt;lc = nod-\u0026gt;rc = tr; // 防止空指针，左右儿子指向第一个空节点 return; } nod-\u0026gt;lc = ++tail; // tail 是一个指向最后创建的节点的指针，这样是一个类似动态开点的操作 nod-\u0026gt;rc = ++tail; build(nod-\u0026gt;lc, L, nod-\u0026gt;mid); build(nod-\u0026gt;rc, nod-\u0026gt;mid + 1, R); push_up(nod); } 查询 以区间和为例\n设查询的区间为 $[l,r]$，目前节点区间为 $[T_l,T_r]$\n则有二种情况\n$[l,r] \\ni [T_l,T_r]$ 查询区间包含目前节点区间（因为每次查询都可能把查询区间切割开再下传，所以这种情况可视为严格包含） $[l,r]\\cap[T_l,T_r] \\neq \\varnothing$ $[l,r]\\not\\ni[T_l,T_r]$ （不存在） 把第二种情况还需要再分开成三种情况\n$[l,r] \\in [lc_l,lc_r]$ 即被左儿子区间包含 $[l,r] \\in [rc_l,rc_r]$ 即被右儿子区间包含 $l \\leqslant mid , r \u0026gt; mid$ 即左右区间都不能单独覆盖查询区间，这种情况把查询区间从 mid 劈成两半再分别在左右儿子区间查询即可。 所以只用处理相应的情况就可以了\n这里直接给出一个维护区间最大值的查询函数\nint query(Node* nod, int L, int R) { push_down(nod); if (nod-\u0026gt;r \u0026lt;mark\u0026gt; R \u0026amp;\u0026amp; nod-\u0026gt;l \u0026lt;/mark\u0026gt; L) { // 严格覆盖 return nod-\u0026gt;v; } if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { return query(nod-\u0026gt;lc, L, R); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { return query(nod-\u0026gt;rc, L, R); } else { return query(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r) + query(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R); } } 从子节点推出父节点数据 还是以区间和为例，父区间最大值为两个子区间最大值中的最大值。\nvoid push_up(Node* nod) { nod-\u0026gt;v = nod-\u0026gt;lc-\u0026gt;v + nod-\u0026gt;rc-\u0026gt;v; } 修改区间值 理解起来其实挺简单的，比如给区间 $[L,R]$ 都加一个数 $x$，朴素写法直接用类似查询的方法递归到底部回溯的时候一个一个更新即可。\n但是显然这样做效率很低，对于长度为 $n$ 的一个区间，最坏情况下它对应 $\\log n$ 个极大区间（这些区间不存在可以合并的两个）；对于每一个极大区间来说修改它和它所有子区间的值的时间复杂度显然是他的长度，即 $\\operatorname{O}(len)$。则如上朴素写法每次修改的时间复杂度最坏为 $\\operatorname{O}(n\\log n)$，属于是飞慢了。\n优化的方式很容易想到，就是每次修改只需要保证需要用到的节点是正确的，其他节点先不管，需要用到的时候再更改。这种方式很像前端里面的一个优化“懒加载”，即一个网页如果有很多元素，一次全部加载完可能会缓慢，所以设备显示到哪里就只加载哪里的元素，看不到的元素能不加载就不加载。同样的，这种优化方式需要打标记，同时能不下放就不下放，子节点能不修改就不修改，被称为“懒标记”。\n也就是说若一个节点拥有懒标记，那么该节点的子节点们都不知道这个懒标记的存在，同时也就表明该节点的叶子节点存储的信息均不是真实信息。如果需要用到当前拥有懒标记的节点的真实信息，就需要把懒标记下放到子节点，通过懒标记更改子节点数据，然后处理子节点更改造成的数据更改即可（直接 push_up）\n假设目前要求维护区间和的同时处理区间加的操作，对于每一个节点来说，我们需要维护一个懒标记 $lazy$ ，代表“当前区间的子区间需要加一个 $lazy$ ”。\nvoid modify(Node* nod, int L, int R, int v) { // 给 [L,R] 每个数加 v if (L \u0026lt;mark\u0026gt; nod-\u0026gt;l \u0026amp;\u0026amp; R \u0026lt;/mark\u0026gt; nod-\u0026gt;r) { // 包含了 nod-\u0026gt;lazy += v; // 该区间的每个子区间都需要加 v nod-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;l + 1) * v; // 当前区间一共有 R-L+1 个元素（因为严格包含所以 L 和 R 就是区间的左右端点） // 用不上子区间的数据，不下传懒标记直接结束 } else { push_down(nod); /* 判断三种情况 */ if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { modify(nod-\u0026gt;lc, L, R, v); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { modify(nod-\u0026gt;rc, L, R, v); } else { modify(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r, v); modify(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R, v); } push_down(nod); push_up(nod); } } void push_down(Node* nod) { if (nod-\u0026gt;lazy == 0) return; if (nod-\u0026gt;lc) nod-\u0026gt;lc-\u0026gt;lazy += nod-\u0026gt;lazy; if (nod-\u0026gt;rc) nod-\u0026gt;rc-\u0026gt;lazy += nod-\u0026gt;lazy; nod-\u0026gt;lc-\u0026gt;v += (nod-\u0026gt;mid - nod-\u0026gt;l + 1) * nod-\u0026gt;lazy; nod-\u0026gt;rc-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;mid) * nod-\u0026gt;lazy; nod-\u0026gt;lazy = 0; } 值得注意的是，加上懒标记之后，为了保证查询时访问的节点数据正确，需要在查询时添加 push_down() 操作（上文已加）。\n完整实现 区间加修改\u0026amp;求区间和\n#include \u0026lt;iostream\u0026gt; using namespace std; #define N 1000150 struct Node { int u; int v; Node *lc, *rc; int l, r, mid; int lazy; // 懒标记 void init(int L, int R) { l = L; r = R; mid = l + r \u0026gt;\u0026gt; 1; } } tr[N * 4]; int n, m; int x, y, k; int ori[N]; char beh; int t1, t2, t3; int cnt = 1; Node* tail = tr; void push_up(Node* nod) { nod-\u0026gt;v = nod-\u0026gt;lc-\u0026gt;v + nod-\u0026gt;rc-\u0026gt;v; } void build(Node* nod, int L, int R) { nod-\u0026gt;init(L, R); if (L == R) { nod-\u0026gt;v = ori[L]; nod-\u0026gt;lc = nod-\u0026gt;rc = tr; return; } nod-\u0026gt;lc = ++tail; nod-\u0026gt;rc = ++tail; build(nod-\u0026gt;lc, L, nod-\u0026gt;mid); build(nod-\u0026gt;rc, nod-\u0026gt;mid + 1, R); push_up(nod); } void push_down(Node* nod) { if (nod-\u0026gt;lazy == 0) return; if (nod-\u0026gt;lc) nod-\u0026gt;lc-\u0026gt;lazy += nod-\u0026gt;lazy; if (nod-\u0026gt;rc) nod-\u0026gt;rc-\u0026gt;lazy += nod-\u0026gt;lazy; nod-\u0026gt;lc-\u0026gt;v += (nod-\u0026gt;mid - nod-\u0026gt;l + 1) * nod-\u0026gt;lazy; nod-\u0026gt;rc-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;mid) * nod-\u0026gt;lazy; nod-\u0026gt;lazy = 0; } void modify(Node* nod, int L, int R, int v) { if (L \u0026lt;mark\u0026gt; nod-\u0026gt;l \u0026amp;\u0026amp; R \u0026lt;/mark\u0026gt; nod-\u0026gt;r) { nod-\u0026gt;lazy += v; nod-\u0026gt;v += (nod-\u0026gt;r - nod-\u0026gt;l + 1) * v; } else { push_down(nod); if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { modify(nod-\u0026gt;lc, L, R, v); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { modify(nod-\u0026gt;rc, L, R, v); } else { modify(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r, v); modify(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R, v); } push_down(nod); push_up(nod); } } int query(Node* nod, int L, int R) { push_down(nod); if (nod-\u0026gt;r \u0026lt;mark\u0026gt; R \u0026amp;\u0026amp; nod-\u0026gt;l \u0026lt;/mark\u0026gt; L) { return nod-\u0026gt;v; } if (nod-\u0026gt;lc-\u0026gt;r \u0026gt;= R) { return query(nod-\u0026gt;lc, L, R); } else if (nod-\u0026gt;rc-\u0026gt;l \u0026lt;= L) { return query(nod-\u0026gt;rc, L, R); } else { return query(nod-\u0026gt;lc, L, nod-\u0026gt;lc-\u0026gt;r) + query(nod-\u0026gt;rc, nod-\u0026gt;rc-\u0026gt;l, R); } } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; ori[i]; } build(++tail, 1, n); while (m--) { cin \u0026gt;\u0026gt; beh; if (beh == \u0026#39;1\u0026#39;) { cin \u0026gt;\u0026gt; t1 \u0026gt;\u0026gt; t2 \u0026gt;\u0026gt; t3; modify(tr + 1, t1, t2, t3); } else { cin \u0026gt;\u0026gt; t1 \u0026gt;\u0026gt; t2; cout \u0026lt;\u0026lt; query(tr + 1, t1, t2) \u0026lt;\u0026lt; endl; } } return 0; } 区间加乘同时存在 上文介绍了加法的懒标记，如果是单独乘法的懒标记也很好实现。但是如果需要同时处理加法、乘法两个区间操作该怎么办捏？\n只需要使用一下分配律即可。\n$(nod_cnod_v + nod_a) \\cdot d=d \\cdot nod_cnod_v+d \\cdot nod_a$\n$nod_c$ 即乘法懒标记， $nod_a$ 即加法懒标记，$d$ 是需要乘的数（操作数）\n","date":"2022-10-27T14:22:33Z","image":"https://pic1.imgdb.cn/item/646ca3800d2dde5777c812ff.webp","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/","title":"线段树"},{"content":"质数相关 质数即一个数的因数只包含 $1$ 和自己。\n筛法请见：质数筛法\n模运算相关 首先，存在唯一的整数 $q,r$ 满足 $n=qm+r, 0\\leqslant r\u0026lt;m$，$q$ 就是商，$r$ 就是余数。 C++ 中模运算可能结果是负数。当 $n\u0026lt;0$ 时，模运算结果满足 $-m\u0026lt;r \\leqslant 0$。 因此可以使用\n(n % m + m) % m 进行取余操作。\n求最大公约数 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a,b,r; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; while (a % b) { r = a % b; a = b; b = r; } cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 同余方程相关 同余方程与二元一次不定方程\n","date":"2022-10-24T09:10:49Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/","title":"初级数论"},{"content":"同余 定义 $a\\bmod m = b \\bmod m$ 则称 $a,b$ 对于模 $m$ 同余，记为 $a \\equiv b \\pmod m$\n等价于 $m$ 整除 $(a-b)$，即 $m\\mid(a-b)$\n同余方程 $ax \\equiv b \\pmod m$\n已知 $a,b,n$，求解 $x$。\n当且仅当 $b$ 能被 $a$ 和 $n$ 的最大公约数整除时此方程有解\n若 $x_0$ 是方程的一个解，解集即为 ${ x_0+km /\\gcd(a,m) | k\\in \\mathbf{Z} }$\n有解证明：\n对于线性同余方程 $ax \\equiv b\\pmod m$ 可以转换为 $ax+km=b,k\\in \\mathbf{Z}$\n设 $d=\\gcd(a,m)$，若方程有解为 $c$， 则 $m \\mid (ac-b)$ ，从而 $d\\mid(ac-b)$，又因为 $d\\mid a$，即 $d\\mid ac$，于是有 $d\\mid b$，即 $\\gcd(a,m)\\mid b$\n扩展欧几里得算法 前置知识 裴蜀定理 $$ \\forall a,b, \\exists x,y,ax+by=\\gcd(a,b) $$\n即 $ax\\equiv \\gcd(a,b)\\pmod b$\n用途 求解同余方程 $ax \\equiv \\gcd(a,n) \\pmod n$ $\\forall a,b,\\exists x,y,ax+by=\\gcd(a,b)$ (裴蜀定理)\n即 $ax\\equiv \\gcd(a,b) \\pmod b$。而 $x,y$ 可以用扩展欧几里得算法求出 同时,逆元的定义也是一个同余方程,也就是说该法可以求模意义下的逆元\n原理 对于方程 $ax_1+by_1=\\gcd (a,b)$，由裴蜀定理可得一定存在一组 $x_1,y_1$ 使得等式成立\n于是分两类讨论\n$b = 0$ 时，$ax_1+by_1=a$，显然 $x_1 = 1, y_1 \\in \\mathbf R$\n$b \\neq 0$ 时，利用四个未知量 $x_1,y_1,x_2,y_2$ 列出两个方程 $$ \\begin{cases} ax_1+by_1 = \\gcd(a,b) = \\gcd(b, a\\bmod b) ① \\\\ bx_2+(a\\bmod b)y_2 = \\gcd(b, a \\bmod b) = \\gcd(a,b) = ax_1+by_1 ② \\end{cases} $$ 易得 $$ a \\bmod b = a-\\lfloor\\frac{a}{b}\\rfloor b $$ 由此我们可以继续展开推导 $②$ 式 $$ \\begin{aligned} bx_2+(a\\bmod b)y_2 \u0026amp;= ax_1+by_1 \\\\ bx_2+(a-\\lfloor \\dfrac{a}{b}\\rfloor b)y_2 \u0026amp;= ax_1+by_1 \\\\ ay_2+b(x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2) \u0026amp;= ax_1+by_1 \\end{aligned} $$\n因此 $$ \\begin{cases} x_1 = y_2 \\\\ y_1 = x_2-\\lfloor \\dfrac{a}{b} \\rfloor y_2 \\end{cases} $$\n实现 运算符 $\\operatorname{exgcd}(a,b,x,y)$ 采用递归实现，因此先判定递归边界，则 $b=0$ 时到达边界，此时 $x = 1, y = 0$\n未到边界，则先继续调用 $\\operatorname{exgcd}(b, a\\bmod b, x, y)$ ，然后根据递归回溯得到的 $x,y$ 得到 $x_1, y_1$，即\n$$ \\begin{cases} x_1 = y \\\\ y_1 = x-\\lfloor \\dfrac{a}{b} \\rfloor y \\end{cases} $$\n返回到头为止。\n求解 $ax + by = c$ ，即 $a \\equiv c \\pmod b$ 先判断是否有解，若 $\\gcd(a,b) \\mid c$ 则有解（#裴蜀定理） 然后利用 $\\operatorname{exgcd}$ 求解 $ax_1 + by_1 = \\gcd (a,b)$ 即得到一份特解 $x = x_1 \\times \\frac{c}{\\gcd(a,b)}, y = y_1 \\times \\frac{c}{\\gcd(a,b)}$\n求通解，实质上是使 $x,y$ 进行一定变换但等式依然成立。 易想到 $x$ 下降时 $y$ 上升，因此设：$g = \\gcd(a,b), i\u0026gt;j$\n$$ \\begin{aligned} ax_i+by_i\u0026amp;=c \\\\ ax_j + by_j \u0026amp;= c \\end{aligned} \\\\ $$\n导一下式子，得\n$$ \\begin{aligned} ax_i+by_i \u0026amp;= ax_j + by_j \\\\ a(x_i - x_j) \u0026amp;= b(y_j - y_i) \\\\ \\frac ag (x_i - x_j) \u0026amp;= \\frac bg (y_j - y_i) \\end{aligned} \\\\ $$\n因为 $g$ 是最大公因数，所以 $\\frac ag$ 与 $\\frac bg$ 互质。又因为方程中每一个字母都是整数，所以易得：$\\frac bg$ 是 $x_i-x_j$ 的倍数，而 $\\frac ag$ 是 $y_j - y_i$ 的倍数（即 $- \\frac ag$ 是 $y_i - y_j$ 的倍数）\n于是通解就推出来了\n$$ \\begin{cases} \\mathbf X = {x+\\cfrac bg k \\mid k\\in\\mathbf Z} \\\\ \\mathbf Y = {y-\\cfrac ag k \\mid k\\in\\mathbf Z} \\end{cases} $$\n关于最小正整数 $x$，求法如下：\n情况 1：$\\gcd(a,b) = 1$ 此时 $\\frac bg = 1$ ，则 $x_{min} = x \\bmod b$ 情况 2：$\\gcd(a,b)=g\\neq 1$ 想办法列出新方程（$x,y$ 不变）$a_1x+b_1y=c_1,\\gcd(a_1,b_1)=1$，即 $a_1,b_1$ 互质 容易想到 $a_1 = \\frac ag, b_1 = \\frac bg$，然后为了保证等式成立，$c_1 = \\frac cg$ 显然直接化为了第一种情况，于是 $x_{min} = x \\bmod \\frac b{\\gcd(a,b)}$ 代码 题目描述 给定不定方程 $$ax+by=c$$ 若该方程无整数解，输出 $-1$。\n若该方程有整数解，且有正整数解，则输出其正整数解的数量，所有正整数解中 $x$ 的最小值，所有正整数解中 $y$ 的最小值，所有正整数解中 $x$ 的最大值，以及所有正整数解中 $y$ 的最大值。\n若方程有整数解，但没有正整数解，你需要输出所有整数解中 $x$ 的最小正整数值， $y$ 的最小正整数值。\n正整数解即为 $x, y$ 均为正整数的解，$\\boldsymbol{0}$ 不是正整数。\n整数解即为 $x,y$ 均为整数的解。\n$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。\n输入格式 第一行一个正整数 $T$，代表数据组数。\n接下来 $T$ 行，每行三个由空格隔开的正整数 $a, b, c$。\n输出格式 $T$ 行。\n若该行对应的询问无整数解，一个数字 $-1$。\n若该行对应的询问有整数解但无正整数解，包含 $2$ 个由空格隔开的数字，依次代表整数解中，$x$ 的最小正整数值，$y$ 的最小正整数值。\n否则包含 $5$ 个由空格隔开的数字，依次代表正整数解的数量，正整数解中，$x$ 的最小值，$y$ 的最小值，$x$ 的最大值，$y$ 的最大值。\n实现 i64 ex_gcd(i64 u, i64 v, i64\u0026amp; x, i64\u0026amp; y) { if (!v) { x = 1, y = 0; return u; } i64 g = ex_gcd(v, u % v, x, y); i64 temp = x; x = y; y = temp - u / v * y; return g; } i64 a, b, c, g, x, y, ga, gb, maxx, maxy, minx, miny; i64 t; i64 k; int main() { read(t); while (t--) { read(a, b, c); // if (a \u0026lt; b) std::swap(a, b); g = ex_gcd(a, b, x, y); x *= c / g, y *= c / g; if (c % g) { puts(\u0026#34;-1\u0026#34;); } else { ga = a / g; gb = b / g; /* 此处先把 x 的最小正整数值求出来，容易想到 x 最小时 y 最大 x \u0026gt; 1 时，直接往小取就行 x \u0026lt;= 1 时，求 1 和 x 的差值然后把差值向上取整地消掉即可 y 同理 */ if (x \u0026gt; 1) { k = (x - 1) / gb; minx = x - k * gb; maxy = y + k * ga; } else { k = ceil((1.0 - x) / gb); minx = x + k * gb; maxy = y - k * ga; } if (y \u0026gt; 1) { k = (y - 1) / ga; miny = y - k * ga; maxx = x + k * gb; } else { k = ceil((1.0 - y) / ga); miny = y + k * ga; maxx = x - k * gb; } // 如果 x, y 的最大值不是正整数，那么无正整数解，最小正整数 x, y 就是上面所求 if (maxy \u0026lt;= 0 || maxx \u0026lt;= 0) { write(minx, \u0026#39; \u0026#39;, miny, \u0026#39;\\n\u0026#39;); } else { // 此处算个数的时候需要注意要算自身，所以 + 1 write((i64)ceil(maxy - 1.0) / ga + 1, \u0026#39; \u0026#39;, minx, \u0026#39; \u0026#39;, miny, \u0026#39; \u0026#39;, maxx, \u0026#39; \u0026#39;, maxy, \u0026#39;\\n\u0026#39;); } } } return 0; } ","date":"2022-10-24T09:10:49Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E4%B8%8E%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/","title":"同余方程与二元一次不定方程"},{"content":"第一次使用 $\\LaTeX$\n01背包 朴素 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAXN 1010 using namespace std; int n, m; int v[MAXN], w[MAXN]; int f[MAXN][MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) { for (int j = 1; j \u0026lt;= m; j ++) { f[i][j] = f[i - 1][j]; if (j \u0026gt;= v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[n][m]; return 0; } 一维优化 #include \u0026lt;iostream\u0026gt; #define MAXN 1010 using namespace std; int n,m; int v[MAXN],w[MAXN]; int f[MAXN]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) { // 按照物品从头到尾枚举 for (int j = m; j \u0026gt;= v[i]; j --) { // 按照体积从最大体积到当前（第 i 个）物品枚举 f[j] = max( f[j], // 此时未更新的 f[j] 是上一次（i-1）枚举的数据，即 f[j] 是不选第 i 个物品的 f[j] f[j - v[i]] + w[i] ); } } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; return 0; } 完全背包 朴素做法 即 3 维做法\n先考虑状态，容易想到选到某个位置后，其特征有空间，物品种类和价值。价值是要求的，所以我们可以开二维状态，分别表示空间和物品种类。即 $f_{i,j}$ 表示从前 $i$ 种物品里选，占了 $j$ 单位空间的最大收益。\n参考 lzp 大佬博客中的要求，这个状态是否能保证唯一且可递推呢？\n唯一：选物品的范围确定，所占用的空间确定，在所有方案中存储最大收益的方案。由于空间确定，因此不会影响后面决策，此时一定能保证最优且唯一。 可递推：前面最优，容易想到通过枚举新拿的物品数量求得当前最优方案（后面讲） 接下来讲递推过程：\n前面 0/1 背包我们只需要考虑一个物品是否选，但是现在还需要考虑选多少。\n考虑是否选择时，我们直接枚举当前物品的状态，即 0/1，选或不选。 放到现在这个题目中，把刚才 0/1 背包枚举选或不选的过程看作枚举物品数量，即选 $1$ 个或选 $0$ 个，这启发我们可以通过枚举物品数量来解决选多少的问题。\n状态转移方程就自然而然地出来了： $$ f_{i,j} - \\max { f_{i-1,j-v_ik} + w_ik } $$\nint backpack() { #define MAXN 1010 using namespace std; int n,m; //! 应当定义在函数外部，原因我不说，因为没人看 int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = 0; j \u0026lt;= m; j ++) { for (int k = 0; k * v[i] \u0026lt;= j; k ++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; } 2 维优化 上面的转移有三维！太慢了！想办法如何减去一个维度。\n状态方面，没有办法再降了，因为去掉任意一维都会导致无法表示唯一的状态。\n那就考虑优化递推的过程。想一想是否有哪些状态能够转移到当前状态但是没考虑到？答案是有的。\n考虑递推过程的第二层、第三层循环，对于每一个体积 $j$，$k$ 都需要从 $1$ 枚举到 $j/v_ik$ ，形象点来说大概长这样\n1 2 3 4 xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx 显然，$k = 1,2,3$ 时都重复地枚举了待转移状态，想办法把这些冗余的东西去掉——直接从算过 $k=1,2,3$ 的状态转移过来。\n这意味着我们不能再单纯的用物品数量进行递推。观察第一行到第二行，容易发现在满体积的时候，第二行只是比第一行多了一个物品 $i$ 而已。\n讨论单个物品是否选择，于是新的递推方式就显而易见了，设当前状态为 $f_{i,j}$，我既可以选一个物品 $i$，也可以不选一个物品 $i$，从 $f_{i-1,j}$ 转移过来。\n状态转移方程： $$ f_{i,j} = \\max \\begin{cases} f_{i-1,j} \\\\ f_{i,j-v_i} + w_i,\\ j\\geqslant v_i \\end{cases} $$\n代码如下\n#define MAXN 1010 using namespace std; int n,m; int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = 0; j \u0026lt;= m; j ++) { // 原做法 // for (int k = 0; k *v[i] \u0026lt;= j; k ++) // f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); f[i][j] = f[i - 1][j]; if (j \u0026gt;= v[i]) f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]); } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; 滚动数组优化\n#define MAXN 1010 using namespace std; int n,m; int v[MAXN],w[MAXN]; int f[MAXN][MAXN]; int backpack() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i ++) { cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for (int i = 1; i \u0026lt;= n; i ++) for (int j = v[i]; j \u0026lt;= m; j ++) { // f[i][j] = f[i - 1][j]; 恒等式直接删除 // if (j \u0026gt;= v[i]) 直接从 v[i] 开始循环就完事了 f[j] = max(f[j], f[j-v[i]] + w[i]); } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; } 多重背包 朴素 $N$ 种物品，背包容量为 $V$，第 $i$ 件物品最多能选 $C_i$ 个，每件物品占空间 $v_i$，价值为 $w_i$\n第一种容易想到的解法是把完全背包的方法拿来用，因为多重背包只是加了 $k$ 的限制。 状态转移方程： $$ f_{i,j} = \\max{f_{i,j}, f_{i-1,j - C_ik} + w_ik} $$\n考虑多重背包和完全背包的区别可以发现，多重背包虽然每种物品不只一种，但是有确定的数量，而完全背包没有数量限制，则可以轻松地在忽略时间复杂度的情况下把多重背包拆分成 01 背包，即把 $M_i$ 件第 $i$ 件物品挨个算单个物品再按照 01 背包的方式处理。\nfor (int i = 1; i \u0026lt;= n; ++ i) { for (int j = 0; j \u0026lt;= m; ++ j) { for (int k = 0; k \u0026lt;= min(c[i],j/w[i])/* 数量和体积两个都限制数量 */; ++ k) { f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); } } } 二进制优化 这种暴力方式求解比较慢，容易发现，在求解过程中，每个同种物品是按照不同种物品进行处理的，换句话说，我选第一个 a 物品与选第二个 a 物品，实际上效果都是选 1 个 a 物品，但是这样的情况在上文解法中做了两次决策，显然有一种是多余的。\n也就是说，接下来的优化方向是减少每次决策所遇到的同数量同种物品，那会联想到什么呢？\n想办法把物品分为多个组，使这些组的不同组合能表示出所有数量，于是想到进制，这里采用二进制拆分。\n易证，使用 $2^0, 2^1, 2^2, 2^3\u0026hellip; 2^{k-1}$ 能够表示出 $0$ 到 $2^{k-1}$ 之间的所有的数，即二进制计数。也就是说，如果把物品的数量 $C_i$ 拆分成 $2^0, 2^1, 2^2\u0026hellip;2^{k-1} + p,0 \\leq p \u0026lt; 2^{k-1}$，由 $p$ 的范围可得，其中 $2^0+\u0026hellip;2^{k-1}$ 能够表示出 $[0,p]$ 的所有整数，然后也能轻松得出 $2^0+\u0026hellip;+2^{k-1}$ 选出若干与 $p$ 相加能表示出 $[p,p+2^k-1]$ 之间所有整数，两个合并即是 $[0,C_i]$\n因此可以将 $C_i$ 拆分为 $k+1$ 种新的物品，每种新物品的体积和价值分别为： $$ \\begin{aligned} \u0026amp;2^0 \\cdot w_i,2^1 \\cdot w_i,2^2 \\cdot w_i,\\dots,2^{k-1} \\cdot w_i,p \\cdot w_i \\\\ \u0026amp;2^0 \\cdot v_i,2^1 \\cdot v_i,2^2 \\cdot v_i,\\dots,2^{k-1} \\cdot v_i,p \\cdot v_i \\end{aligned} $$ 拆分完再进行 01 背包即可。\n代码来自 GrainRain \u0026rsquo;s Blog\nconst int N = 25000; // 一共有 1000 项，每项最多拆分成 log s 项 const int M = 2010; int n, m; int v[N], w[N]; int f[N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int cnt = 0; for (int i = 1; i \u0026lt;= n; i ++) { int a, b, s; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; s; for (int k = 1; k \u0026lt;= s; k *= 2) { // 从2^0 开始枚举 2 的次幂 s -= k; v[++ cnt] = a * k; w[cnt] = b * k; } if (s \u0026gt; 0) { v[++ cnt] = a * s; w[cnt] = b * s; } } n = cnt; // 二进制拆分读入 for (int i = 1; i \u0026lt;= n; i ++) for(int j = m; j \u0026gt;= v[i]; j --) f[j] = max(f[j], f[j - v[i]] + w[i]); cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; // 01背包解题过程 分组背包 $N$ 组物品，第 $i$ 组有 $C_i$ 个物品，第 $i$ 组的第 $j$ 个物品的价值是 $w_{i,j}$，体积为 $v_{i,j}$，背包体积为 $M$，每组物品只能选择 $1$ 个\n直接枚举组时挨个枚举物品就行了。\n按照组划分阶段，第 $i$ 组不选则 $f_{i,j} = f_{i-1,j}$，第 $i$ 组选第 $k$ 个则 $f_{i,j} = f_{i-1,j-v_{i,k}} + w_{i,k}$\n这里直接给出数组删维优化过的代码\nfor (int i = 1; i \u0026lt;= n; ++ i) { for (int j = m; j \u0026gt;= m; -- j) { for (int k = 1; k \u0026lt;= c[i]; ++ k) { f[i][j] = max(f[j], f[j-v[i][k]] + w[i][k]); } } } 依赖背包 我的 Windows 盘还剩 5 个 G，新买的东方冰之勇者记占 2G,LLVM 依赖于 MSVC 生成工具，MSVC 占用 2G 磁盘，LLVM 占用 2G 磁盘，问我应该怎么安装收益最大\nreboot to archlinux!\nA 物品依赖于 B，选 B 物品之前需要先选 A 物品，问最大价值\n容易发现对于任意有依赖关系的物品 A B 来说，一共有以下三种可能的决策 （A 依赖 B）\nA B 都不选 选 B 不选 A A B 都选 因为这三种情况只会出现一个，联想分组背包的特征，将这三种情况每个看成一个组里的物品，即转化为了分组背包。\n这东西是树形 DP\u0026hellip;\n","date":"2022-10-23T18:49:29Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85-dp/","title":"背包 DP"},{"content":"埃氏筛 2 3 4 5 6 7 8 9 2 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 //筛掉2的倍数 2 3 5 7 ~~9~~ //筛掉3的倍数 例：\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; bool b[100000005]; int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for (int i=2; i \u0026lt;= sqrt(n); i++) { // 注意枚举质数的范围 if (!b[i]){ // b[i]值为0表示i为质数 for (int j = i; j \u0026lt;= n/i; j++) { // 筛掉i的倍数 b[i*j]=1; } } } for (int i = 2; i \u0026lt;= n; i ++) { if (!b[i]){ printf(\u0026#34;%d \u0026#34;,i); } } return 0; } 11 行处为一个小优化：$i$ 的倍数从 $i^2$ 开始枚举 （考虑 $j = k\\cdot i\u0026lt;i\\cdot i$， $j$ 一定会被 $k$ 的质因数筛去）\n举个例子：筛 $2$ 的倍数时，被打标记的数字分别是\n2*2,2*3,2*4......2*n/2 那么我们筛 $i$ 的倍数时，无优化算法被打标记的数分别是\ni*2,i*3,i*4.......i*n/i 可以发现，$2i$ 和 $4i$ (即 $2\\cdot 2i$)在枚举 $2$ 的倍数时已经被打过标记了\n其他任意一个 $k\\cdot i, 2\\leqslant k\u0026lt; i$ 都同理。\n线性筛 (转载) 初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数。如果按照埃氏筛做法枚举每个质数的倍数，会造成重复筛除，影响效率。\n例如 $30=5\\times 3\\times 2$，它被 $2\\times 15$ 筛了一次，又被 $3\\times 10$ 筛了一次，为了解决这个问题，线性筛应运而生：\nint mark[MAXN]; int prime[MAXN]; //判断是否是一个素数 Mark 标记数组 index 素数个数 int Prime(int n){ int index = 0; for(int i = 2; i \u0026lt; n; i++){ //如果未标记则得到一个素数 if(mark[i] == 0) prime[++index] = i; //标记目前得到的素数的i倍为非素数 for(int j = 1; j \u0026lt;= index \u0026amp;\u0026amp; prime[j] * i \u0026lt; n; j++){ mark[i * prime[j]] = 1; if(i % prime[j] == 0) break; } } return index; } 利用了每个合数必有一个最小素因子。每个合数仅被它的最小素因子筛去正好一次。所以为线性时间。\n代码中体现在：\nif(i%prime[j]==0) break; $prime$ 数组中的素数是递增的,当 $i$ 能整除 $prime_j$，那么 $i\\cdot prime_{j+1}$ 这个合数肯定也可以被 $prime_j$ 筛掉，因为 $i$ 中含有 $prime_j$, $prime_j$ 比 $prime_{j+1}$ 小。\n接下去的素数同理，所以不用筛下去了。 在满足 $i\\ \\bmod \\ prime_j = 0$ 这个条件之前以及第一次满足该条件时,$prime_j$ 必定是 $prime_j\\cdot i$ 的最小因子\n版权声明：本文为lyf_018原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_41653433/article/details/88976544 ","date":"2022-10-08T11:36:49Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95/","title":"质数筛法"},{"content":"DFS与BFS 深度优先搜索： 一棵树从一个枝向下搜索，搜到头之后回溯，继续搜下一个枝\n宽度优先搜索（Breath First Search 而不是 Brain Fuck Scheduler）（后者已经停止维护了）： 一层一层搜到底部\nDFS 注意回溯需要“恢复现场”\n一个例题\n#include \u0026lt;cstdio\u0026gt; const int N = 10; int n; // 层数 int path[N]; // 存储状态 bool state[N]; // 存储各个枝是否被使用 void dfs(int a) { if (a == n) { // 到达最底层 for (int i = 0; i \u0026lt; n; i ++) { printf(\u0026#34;%5d\u0026#34;,path[i]); } putchar(\u0026#39;\\n\u0026#39;); return ; } for (int i = 1; i \u0026lt;= n; i ++) { if (!state[i]) { // i没有被使用 path[a] = i; state[i] = 1; dfs(a+1); // 搜索下一层 state[i] = 0; // dfs结束之后，开始回溯，恢复现场 } } } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); dfs(0); return 0; } ","date":"2022-08-07T21:50:20Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%90%9C%E7%B4%A2/%E6%90%9C%E7%B4%A2%E5%9F%BA%E7%A1%80/","title":"搜索基础"},{"content":"STL vector 变长数组 需要引入头文件vector\n声明 vector\u0026lt;类型\u0026gt; 名称 多个vector组成的数组\nvector\u0026lt;类型\u0026gt; 名称[some_num] 此处的类型也可以是自定义的结构体、类\n示例\n#include\u0026lt;vector\u0026gt; vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; b[233]; 常用命令 迭代器 类似指针/数组下标之类的东西\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { vector\u0026lt;int\u0026gt; a({\u0026#34;NVIDIA\u0026#34;,\u0026#34;FUCK\u0026#34;,\u0026#34;YOU\u0026#34;,\u0026#34;EOF\u0026#34;}); std::cout \u0026lt;\u0026lt; *a.begin() \u0026lt;\u0026lt; std::endl; // a.begin() 指向 a 的第一个元素 此处相当于 a[0] std::cout \u0026lt;\u0026lt; *(a.end()-1) \u0026lt;\u0026lt; std::endl; // a.end() 指向 a 的最后一个元素的后一位，直接使用是越界访问，此处相当于 a[a.size()-1] vector\u0026lt;int\u0026gt;::iterator it = a.begin(); vector\u0026lt;int\u0026gt;::iterator it_end = a.end(); // C++11 显然使用 auto it=a.begin(); 更好写 std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 此时相当于 a[0] 与 *a.begin() // vector 的迭代器是一个随机访问迭代器，可以加减 std::cout \u0026lt;\u0026lt; *(it + 1) \u0026lt;\u0026lt; std::endl; // 相当于 a[1] std::cout \u0026lt;\u0026lt; *(it-it_end) \u0026lt;\u0026lt; std::endl; // 求两个下标之间的距离 return 0; } STL容器常用命令 sth.size(); // 返回容器 sth 的实际长度（包含的元素个数） sth.empty(); // 返回一个 bool 值，表示容器 sth 是否为空 sth.clear(); // 把容器 sth 清空 ","date":"2022-07-23T16:43:28Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/stl-%E5%AE%B9%E5%99%A8/","title":"STL"},{"content":"类 (class) 与 结构体 (struct) #include \u0026lt;iostream\u0026gt; using namespace std; class Person { private: // Person类私有 只能在 Person 这个类里面调用 int age, height; double money; public: string name; void say() { cout \u0026lt;\u0026lt; \u0026#34;I\u0026#39;m \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } int get_age() { return age; // Person 类中可以调用由 Person 类私有的量 } void add_money(int a){ money += a; } private: // private/public 可以有多个 string books[1000]; }; // 类定义结束要加分号 int main(){ Person pinghigh(); Person persons[10]; // 可以定义一个 Person 类的数组 pinghigh.name = \u0026#34;Tibrella\u0026#34;; // name 是公有变量，外部可以访问 // pinghigh.age = 15; //!错误， age 是私有变量，外部不可访问 pinghigh.add_money(12345); pinghigh.say(); cout \u0026lt;\u0026lt; pinghigh.get_age() \u0026lt;\u0026lt; endl; return 0; } 输出:\nI\u0026#39;m Tibrella 14 class 与 struct 的异同 唯一一点不同是 class 中的量默认为 private , struct 中的量默认为 public\n其他完全相同\n","date":"2022-07-19T14:34:12Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/%E7%B1%BB/","title":"类"},{"content":"可变长的字符序列，需要引入头文件 \u0026lt;string\u0026gt;\n赋值 #include \u0026lt;string\u0026gt; using namespace std; int main(){ string s1; // 默认空字符串 string s2 = s1; // string 类型可以互相赋值，无需 memcpy() 或 strcpy() 。 s2 是 s1 的一个副本 string s3 = \u0026#34;hiya\u0026#34;; // s3 是该字符串(\u0026#34;hiya\u0026#34;)字面值的一个副本（我也不知道是什么，总之 s3 的值是\u0026#34;hiya\u0026#34; string s4(5,\u0026#39;T\u0026#39;); // s4 的内容是“TTTTT” return 0; } 输入输出 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string s1, s2; //读入无空格字符串 cin \u0026gt;\u0026gt; s1; // scanf() fgets() 不能读入 string 类型 //读入一行 getline(cin,s2); //输出 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; /* printf() 不能直接输出string类型 需要写成 printf(\u0026#34;%s\u0026#34;,s1.c_str()) 这里 s.c_str() 作用是把 string 类型转化为字符数组 */ // 当然也可以 puts(s1.c_str()) return 0; } 后记 使用 getline(cin,str) 输入时需要注意回车符\n什么意思呢？举个例子\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string a,b; cin \u0026gt;\u0026gt; a; getline(cin, s); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 这时你输入\nNVIDIA FUCK U 程序会在你输入完第一行后直接输出一个NVIDIA与几个换行符 原因是cin遇到回车停止，此时getline直接把NVIDIA后的部分(空)读入然后再次遇到回车符，停止输入。\n为了避免这种情况，我们需要忽略掉一个回车符，可以使用getchar()。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string a,b; cin \u0026gt;\u0026gt; a; // NVIDIA getchar(); // \\n（跳过一个换行符） getline(cin, s); // FUCK U cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 常用操作 str.empty() 返回一个bool值。 如果string为空返回1，非空返回0。 str.size() 返回string的长度，等价于 s.length() strlen() 需要循环一遍数组，时间复杂度为O(n)。 str.size() 不需要循环，时间复杂度为O(1)。 比较 string 型之间按字典序比较直接 str1 \u0026lt; str2 即可，== != \u0026lt;= \u0026gt;= \u0026lt; \u0026gt;都支持。 相加 string 型之间相加直接 str1 += str2、str3 = str1 + str2 这样写即可。 与其他类型（字符、字符串）相加时会先把这些类型的量转化为 string 对象，可以直接加这些类型的量，如 str += 'a' 、 str1 = str2 + \u0026quot;abc\u0026quot; 相加运算时，必须保证等号两边都有 string 型，str1 = str2 + \u0026quot;hello\u0026quot; + 'a' 、 str1 += \u0026quot;hello\u0026quot; 是可以的， 但是 str1 = \u0026quot;hello\u0026quot; + 'a' 会报错。 注意运算顺序，如 string s1 = s2 + \u0026quot;abc\u0026quot; + 'd' 正确，因为会先将 s2 与 \u0026ldquo;abc\u0026rdquo; 相加得到另一个 string 对象，再继续运算。而 string s1 = \u0026quot;abc\u0026quot; + 'd' + s2 会报错，因为 \u0026ldquo;abc\u0026rdquo; 和 \u0026rsquo;d\u0026rsquo; 不能相加 （\u0026ldquo;abc\u0026quot;和\u0026quot;cde\u0026quot;也不行） 操作单个字符 可以当作字符数组处理，如 str[0] , str[3] 独特的遍历方式 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;So, NVIDIA,\u0026#34; \u0026lt;\u0026lt; endl; string s = \u0026#34;Fuck U\u0026#34;; for (char c : s) { // char c可以写作 auto c cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } return 0; } 输出： So, NVIDIA, F u c k U str.pop_back() 删除string型字符串的最后一个字符 str.substr(int i,int len) 输出字符串str从i开始长度为len的字符串 ","date":"2022-07-18T20:24:48Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/stl-string/","title":"STL string"},{"content":"字符数组 输出 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; int main(){ char str[3]=\u0026#34;ab\u0026#34;; // 以下三种输出方式都是遇到换行或空格不停止，而是遇到\u0026#39;\\0\u0026#39;才停止 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; printf(\u0026#34;%s\\n\u0026#34;,str); puts(str); // 等价于上面的printf语句 return 0; } 读入 分两种情况 1.读入一个字符串，遇到空格/回车停止 使用cin\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ char str[3]; cin \u0026gt;\u0026gt; str; //输入 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 或使用scanf\n#include \u0026lt;cstdio\u0026gt; int main(){ char str[3]; scanf(\u0026#34;%s\u0026#34;,str); //输入 /* 这里注意一点，str 不能写作 \u0026amp;str 数组名实际上是一个指针，存储数组的第一个元素的内存地址（指向数组的第一个元素） scanf(\u0026#34;%s\u0026#34;,__) 这里下划线部分应当是一个内存地址，而整型、浮点、字符等类型变量中存储的不是地址而是它对应的内容，所以需要用‘\u0026amp;’取出它的内存地址，如取出整型（int）变量a的内存地址就是 \u0026amp;a。 而数组名本身就存储着内存地址，所以不需要再用 \u0026amp; 取一遍内存地址 */ printf(\u0026#34;%s\u0026#34;,str); return 0; } 2.读入一行内容，输入空格不停止\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main(){ char str[100]; fgets(str,100,stdin); // gets() 函数在 C11 标准中因为容易溢出而被删除，取而代之的是 fgets() /* \u0026#34;str\u0026#34;为字符串名 “100”是读入的最大字符数（一般使用数组长度即可） “stdin”应该是一个接口，不用管，照着写就行 */ cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; return 0; } 或\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ char str[100]; string str1; cin.getline(str,100); // 字符数组使用 cin.getline() getline(cin,str1); // string 使用 getline() cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; return 0; } 常用函数1 strlen(str) 求字符串长度（不包含\u0026rsquo;\\0\u0026rsquo;） strcmp(a,b) 比较两个字符串大小(ASCII码)， a \u0026lt; b 返回 -1 ，a == b 返回 0， a \u0026gt; b 返回 1（比较方式为字典序2） strcpy(a,b) 将字符串b赋值给从a开始的字符数组 strlen()示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s[100]=\u0026#34;abc\u0026#34;; cout \u0026lt;\u0026lt; strlen(s) \u0026lt;\u0026lt; endl; return 0; } strcmp()示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s[100]; scanf(\u0026#34;%s\u0026#34;,s); cout \u0026lt;\u0026lt; strcmp(s,\u0026#34;abc\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 此处将输入的字符串与abc进行比较\n输入 #1 bac #2 abc #3 aac 输出 #1 1 #2 0 #3 -1 strcpy示例 #include \u0026lt;iostream\u0026gt; // 用于输出 #include \u0026lt;cstring\u0026gt; // 或者string.h，这是C语言的头文件 using namespace std; // 用于输出 int main(){ char s1[100]=\u0026#34;abc\u0026#34;,s2[100]; strcpy(s2,s1); // s1 复制到 s2 cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 输出为abc\n以下三个函数均需要把字符串中每个字符循环一遍，如果我们写循环时需要用到其中一个，会导致时间复杂度提升，需要改进。 如\nfor (int i = 0; i \u0026lt;= strlen(str); i++) 最好改写成\nfor (int i = 0, len=strlen(str); i \u0026lt;= len; i++) \u0026#160;\u0026#x21a9;\u0026#xfe0e; 字典序：从前向后比，如2与10，比较数字则10大，按字典序比较则是2大（因为2\u0026gt;1）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-17T19:20:54Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84/","title":"字符数组"},{"content":"浮点数比较要容忍误差（精度问题导致后几位出现误差）\n数组 数组初始化 #include \u0026lt;cstring\u0026gt; int main(){ int a[10]; memset(a,0,40); return 0; } 此处a为数组名，40为赋值范围（int为4byte,数组大小为10，4*10=40）\n不会把每个元素赋值为0，而是把每个字节赋值为0\n#include \u0026lt;cstring\u0026gt; int main(){ int a[10]; memset(a,1,40); return 0; } 此处 $a$ 中每一个 byte 赋值为0000 0001，取出 $a_1$ 为16843009，即0000 0001 0000 0001 0000 0001 0000 0001。\n为了达到初始化数组的目的，我们也可以把它每一位赋值为 1（-1 反码为 1111 1111）\n即\n#include \u0026lt;cstring\u0026gt; int main(){ int a[10]; memset(a,-1,40); return 0; } sizeof 输出一个量所占内存byte数\n用法：\nint a; sizeof a; 因此我们可以写作\n#include \u0026lt;cstring\u0026gt; int main(){ int a[10]; memset(a,0,sizeof a); //sizeof a等价于sizeof(a) return 0; } memcpy() #include \u0026lt;cstring\u0026gt; int main(){ int a[10],b[10]; memcpy (b,a,sizeof a); //sizeof a等价于sizeof(a) return 0; } 做题要点 1.例题\n这种题可以列表来找规律避免大脑便秘\n如下\ni 左 右 0 1 10 1 2 9 2 3 8 3 4 7 ......... i i+1 10-i ","date":"2022-07-15T11:36:49Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/","title":"数组相关"},{"content":"#include \u0026lt;stdio.h\u0026gt; int main() { int k,sum=0; while (scanf(\u0026#34;%d\u0026#34;,\u0026amp;k) != EOF) // EOF是读取结束标识 // 又因为 scanf 在读取到 EOF 会返回 -1，所以也可以写成 while (~scanf(\u0026#34;%d\u0026#34;,\u0026amp;k)) { sum += 1; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } 另外一点值得注意的是，关于使用 cin \u0026gt;\u0026gt; x 时的返回值并不是 cin 的返回值，cin 只是一个对象，而实际进行运算的是流运算符 \u0026gt;\u0026gt;。\nWindows 系统输入 1\n1 2 3 ^z GNU/Linux 输入\n1 2 3 ^d 输出\n3 本文中^z、^d 都指组合键，^d 为 Ctrl+D，^z 为 Ctrl+Z。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-14T22:01:08Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/c++/%E8%AF%BB%E5%85%A5%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE/","title":"读入未知数量的数据"},{"content":"最大公约数 辗转相除法求最大公约数 例：\n70 % 50 = 20 50 % 20 = 10 20 % 10 = 0 取模到0为止，此时10就是70、50最大公约数\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a,b,r; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; while (a % b != 0){ r = a % b; a = b; b = r; } cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 更相减损术求最大公约数 54 24 | 除以2（可除可不除，除后方便计算） V 27 12 27-12=15 大减小 ... ... 6-3=3 此处3=3,所以最大公约数为3\n","date":"2022-07-14T11:36:49Z","image":"https://pic.imgdb.cn/item/6416687ca682492fccfb973a.jpg","permalink":"https://blog.tibrella.top/notes/%E6%95%B0%E5%AD%A6/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/","title":"gcd 最大公约数"},{"content":"这是一个测试页\n#include \u0026lt;iostream\u0026gt; using std::cout; #define endl \u0026#39;\\n\u0026#39; int main() { std::ios::sync_with_stdio(0); cout.tie(0); cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } $Test Math$ 好吧，数学好像还不支持 添加了支持\n$$ Test $$\n这个代码块目测有点丑，还得改改1 改了一下，感觉好点了\n注释测试\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1970-01-01T00:00:00+08:00","permalink":"https://blog.tibrella.top/notes/hello-world/","title":"Hello World"}]